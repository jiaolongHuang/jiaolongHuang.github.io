<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 【JavaScript高级程序设计】对象的创建与继承 · 小路口</title><meta name="description" content="【JavaScript高级程序设计】对象的创建与继承 - jiaolongHuang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jiaolongHuang.github.io/atom.xml" title="小路口"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/minel" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/jiaolonghuang" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">【JavaScript高级程序设计】对象的创建与继承</h1><div class="post-info">May 8, 2013</div><div class="post-content"><p>关于JS面向对象的部分中，关于对象的创建和继承的各种方法，以及这些方法之间的区别和适用场景是经常被问到的。</p>
<p>首先，关于对象的创建。 </p>
<p>1.最简单的方法，大括号创建，var o = {}；或者是用对象字面量方法，var 0 = {name:”jack”,age = 10}; 问题：当使用相同接口创建很多对象时，会产生大量重复的代码。</p>
<p>2.工厂模式方法：将创建对象的细节封装起来，这样可以解决创建多个相似对象的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createA</span>(<span class="params"></span>)</span>&#123; </div><div class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name = <span class="string">"jack"</span>; </div><div class="line">	 o.age = <span class="number">10</span>;      </div><div class="line">	<span class="keyword">return</span> o;  </div><div class="line">&#125;      </div><div class="line"><span class="keyword">var</span> A = createA();</div></pre></td></tr></table></figure>
<p>问题：带来了对象识别问题，不能知道一个对象的类型。也就是说用instansOf()方法无法确定对象的类型。 注意：不能用new来调用创建对象的函数，并且在函数的内部要返回那个Object对象。</p>
<p>3.构造函数方法<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,age)</span></span>&#123;          </div><div class="line">	<span class="keyword">this</span>.name = name;          </div><div class="line">	<span class="keyword">this</span>.age = age;          </div><div class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;              </div><div class="line">		alert(<span class="keyword">this</span>.name);          </div><div class="line">	&#125;      </div><div class="line">&#125;          </div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"jack"</span>,<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p>通过检查实例的constructor属性，或者使用instanceof()方法可以确定对象的类型。<br>问题：每个方法都要在每个实例上创建；创建多个完成相同任务的Function实例是没必要的。             如果把这样的Funtion从构造函数中移除来，则函数会变成为全局环境中的成员，破坏了封装性。 </p>
<p>4.原型模式<br>原型:是指向一个对象的，这个对象包含由所有实例共享的方法和属性。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span></span>&#123;   &#125;      </div><div class="line">Person.prototype.name = <span class="string">"jack"</span>;      </div><div class="line">Person.prototype.age = <span class="number">10</span>;      </div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;          </div><div class="line">	alert(<span class="keyword">this</span>.name);      </div><div class="line">&#125;  </div><div class="line"><span class="keyword">var</span> wang = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p>
<p>注意：所有的实例保存的仅是指向对象原型的指针。所有实例共享原型的属性和方法。实例可以重写属性，覆盖原型对象中的相同属性，但是并不改变原型中的这个属性。 可以使用hasOwnPropertyp()来判断，当属性存在于对象中时返回true。<code>if (wang.hasOwnProperty(&quot;name&quot;)) {alert(true);}</code><br>比如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wang = <span class="keyword">new</span> Person();</div><div class="line">	<span class="built_in">console</span>.log(wang.age); <span class="comment">//10</span></div><div class="line">	wang.age = <span class="number">20</span>;</div><div class="line">	<span class="built_in">console</span>.log(wang.age); <span class="comment">//20</span></div><div class="line">	<span class="keyword">var</span> li = <span class="keyword">new</span> Person();</div><div class="line">	<span class="built_in">console</span>.log(li.age);   <span class="comment">//10</span></div></pre></td></tr></table></figure></p>
<p>问题：省略了为构造函数传参，所有实例在默认情况下都取得相同的属性值。尤其当属性为引用值时，会相互干扰。<br>5.组合构造函数和原型模式 将实例属性在构造函数中定义。 所有实例共享的属性和方法在原型中定义。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,age)</span></span>&#123;          </div><div class="line">	<span class="keyword">this</span>.name = name;          </div><div class="line">	<span class="keyword">this</span>.age = age;      </div><div class="line">&#125;          </div><div class="line">Person.prototype = &#123;          </div><div class="line">	constructor: Person,          </div><div class="line">	sayName: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;              </div><div class="line">		alert(<span class="keyword">this</span>.name);          </div><div class="line">	&#125;      </div><div class="line">&#125;;      </div><div class="line"><span class="keyword">var</span> wang = <span class="keyword">new</span> Person(<span class="string">"jack"</span>,<span class="number">10</span>);     </div><div class="line">wang.sayName();      </div><div class="line"><span class="keyword">var</span> li = <span class="keyword">new</span> Person(<span class="string">"nike"</span>, <span class="number">10</span>);      </div><div class="line">li.sayName();</div></pre></td></tr></table></figure></p>
<p>说完了对象的创建，再说一下对象的继承。<br>1.原型链继承 每一个构造函数中都有一个指针prototype，这个指针指向原型对象，而原型对象中又都有一个属性constructor，指向这个构造函数。同时每个实例中都有一个指向原型对象的指针。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span></span>&#123;      &#125; </div><div class="line"> SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;      &#125;;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">subType</span><span class="params">()</span></span>&#123;      &#125;  </div><div class="line">subType.prototype = <span class="keyword">new</span> SuperType();<span class="comment">//重写了subType的原型,此时constructor指向superType的原型对象  </span></div><div class="line">subType.prototype.getSubValue = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;      &#125;;</div></pre></td></tr></table></figure></p>
<p>注意：新加的子类原型方法，应该在继承了父亲原型之后。            使用原型链方法继承时，不能用对象字面量来创建原型方法，这样会重写子类原型，使得constructor指向Object。<br>问题：<br>a.由于包含引用型的原型属性会被所有实例共享。所以，如果父类的构造函数中有一个引用型数组，则对父类的每一个实例间无影响。 但是子类的原型是父类的一个实例。子类的所有实例都会共享这个属性<br>b.创建子类实例时无法向父类的构造函数传参。 </p>
<p>2.借用构造函数<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">superType</span><span class="params">(name)</span></span>&#123;      </div><div class="line">	<span class="keyword">this</span>.name = name;      </div><div class="line">	<span class="keyword">this</span>.colors = [<span class="string">"black"</span>,<span class="string">"green"</span>];  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">subType</span><span class="params">()</span></span>&#123;      </div><div class="line">	superType.call(<span class="keyword">this</span>,<span class="string">"jack"</span>);      </div><div class="line">	<span class="keyword">this</span>.age = <span class="number">10</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在调用subType()时，会借调superType()的所有代码，子类的实例创建实例自己的colors副本。<br>问题：方法都在构造函数中定义，没有了函数的复用。<br>同时，在父类原型中定义的方法和属性，子类无法继承到。 </p>
<p>3.组合继承 通过原型链来实现对原型属性和方法的继承；借用构造函数来实现对实例属性的继承。<br>问题：无论在什么情况下，都会调用2次父类构造函数。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">superType</span><span class="params">(name)</span></span>&#123;</div><div class="line">			<span class="keyword">this</span>.name = name;</div><div class="line">		&#125;</div><div class="line">		superType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">		&#125;;</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">subType</span><span class="params">(name,age)</span></span>&#123;</div><div class="line">			superType.call(<span class="keyword">this</span>,name);</div><div class="line">			<span class="keyword">this</span>.age = age;</div><div class="line">		&#125;</div><div class="line">		subType.prototype = <span class="keyword">new</span> superType();</div><div class="line">		subType.prototype.constructor = subType;</div><div class="line">		subType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>4.原型式继承<br>基于现有的对象，再创建一个新对象。<br>适用场景：只想让一个对象与另一个对象保持相似的情况下。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;      </div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//创建临时性的构造函数      </span></div><div class="line">	F.prototype = o;<span class="comment">//将传入的对象作为这个构造函数的原型      </span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();<span class="comment">//返回这个临时类型的新实例  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>object()对传入的对象进行了浅复制。<br><code>person1 = object(Person); person2 = object(Person);</code> 相当于创建了2个person的副本。 </p>
<p>5.寄生式继承<br>与创建对象的工厂模式类似<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">another</span><span class="params">(o)</span></span>&#123;</div><div class="line">			<span class="keyword">var</span> <span class="keyword">clone</span> = object(o);</div><div class="line">			<span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">			&#125;;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">clone</span>;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>问题：无法做到函数的复用。 </p>
<p>6.寄生组合式<br>这是最有效的一种继承方式。只调用了一次superType()构造函数，同时还没有改变原型链。<br>首先创建如下函数：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="title">function</span> ip(subType,superType)&#123;      </div><div class="line">	var proto<span class="keyword">type</span> = object(superType.prototype);      </div><div class="line">	proto<span class="keyword">type</span>.constructor = subType;      </div><div class="line">	subType.proto<span class="keyword">type</span> = prototype;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后使用时，与组合继承类似，但是不同的是将<code>subType.prototype = new superType();subType.prototype.constructor = subType;</code>这两句代码换成，<code>ip(subType,superType);</code><br> 最后，理解对象的创建和继承，关键是理解构造函数，原型对象以及实例之间的关系。这个稍后上图。 </p>
<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2013/05/17/16/" class="prev">PREV</a><a href="/2013/05/07/18/" class="next">NEXT</a></div><div data-thread-key="2013/05/08/17/" data-title="【JavaScript高级程序设计】对象的创建与继承" data-url="http://jiaolongHuang.github.io/2013/05/08/17/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"minel"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>友情链接：<a href="https://imququ.com" class="links-item">QuQu</a><a href="http://anjia.github.io" class="links-item">跑跑佳</a><a href="http://www.imwineki.cn/" class="links-item">Wineki</a><a href="http://westpsk.com/" class="links-item">ivan</a></p><p>© 2015 - 2016 <a href="http://jiaolongHuang.github.io">jiaolongHuang</a>. Love this theme <a href="https://github.com/pinggod/hexo-theme-apollo">apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>