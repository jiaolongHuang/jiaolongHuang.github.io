{
	"meta": {
		"exported_on": 1508578539880,
		"version": "008"
	},
	"data": {
		"posts": [
			{
				"id": "cj914pnz6002ke0hyu1hk4anc",
				"title": "博客地址迁移",
				"slug": "change",
				"markdown": "\n本博客已全部迁移至[小路口](https://imjiaolong.cn/)\n<!-- more -->\n\n",
				"html": "<p>本博客已全部迁移至<a href=\"https://imjiaolong.cn/\" target=\"_blank\" rel=\"external\">小路口</a><br><a id=\"more\"></a></p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1508578358000,
				"created_by": 2,
				"updated_at": 1508578516000,
				"updated_by": 2,
				"published_at": 1508578358000,
				"published_by": 2
			},
			{
				"id": "cj914po0s0055e0hy78pn1mfz",
				"title": "使用Webpack打包兼容低版本IE<9",
				"slug": "webpack-IE",
				"markdown": "\n对Webpack打包兼容低版本IE<9时遇到问题的排查过程。\n\n<!-- more -->\n\n最近在使用webpack打包时，遇到一个问题:\n已经添加了polyfill，且转成es3语法的前提下，新增uglify之后IE<9浏览器报错。故，怀疑是uglify做了坏事，一步步追踪下去，发现原来是不太规范的一个写法引起的IE老版本下自身bug。\n\n## 关于版本\n使用不同版本的webpack2,错误依旧复现。\n以下讨论的是webpack2.5.1，内置uglify-js2.8.5。\n\n## 错误1，缺少标识符\n这种错误大多是压缩后，对象的属性没有了引号，或是以一些保留字作为了对象的属性，比如\"default\"。\n这种通过对uglify的配置即可解决。这篇文章总结的很好[煦涵说Webpack-IE低版本兼容指南](http://www.zuojj.com/archives/2157.html)。\n具体配置可以参考本博客上一篇文章中关于的uglifyJS的配置。\n\n## 错误2，没有找到某个对象的方法、属性（重点来了！！！）\n这个就比较坑了。\n表现是，初次访问，没有报错，只有执行某个操作时，才报错。可以推测，仅是进入到某个代码内才报错，也就是说是局部报错。\n首先我们通过定位报错的那段代码，发现是个命名函数表达式。类似这样：\n```\nA:\nvar a = function b() {\n  console.log(b.list['name']);\n  b.log();\n};\n\na.list = {};\na.list['name'] = 'jack';\na.log = function(){\n  console.log('log')\n}\n```\n\n再对应至压缩之前的代码是这样的：\n```\nB:\nvar test = function test() {\n  console.log(test.list['name']);\n  test.log();\n};\n\ntest.list = {};\ntest.list['name'] = 'jack';\ntest.log = function(){\n  console.log('log')\n}\n```\n从未压缩的代码可以看到，其实b是一个在函数体内对a的一个引用。\n然后简单的把b改成a，再执行，发现没有报错了。\n\n根据MDN上关于[命名函数表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function)的定义，可以知道function 的 test 和外部的 test 变量不是一回事。test 这个变量作用域链的原因，在函数内部使用的时候优先找到了 test 这个 function 定义了。\n\n所以uglify把`B -> A` 是没有问题的。\n\n## 那么为什么只会在IE<9会报错呢。\n这是因为命名表达式在IE<9的一个[JScript bugs](http://kangax.github.io/nfe/#jscript-bugs).\n\n简单来说，是这样的：正常情况下，b只能在函数体内使用，a与b指向同一个内存地址。如果在函数外引用，会报错，未定义。\n但是在IE<9，会创建2个独立的函数，分别给a，和b。以至于a !== b.这样上面这个函数在IE9以下执行的时候，会报函数体内的对象找不到对应的方法或属性。在函数外引用，反而不报错。\n看[这里的讨论](https://stackoverflow.com/questions/14732107/javascript-inconsistency-when-assigning-a-named-function-to-a-variable-named-f)\n\n```\nvar a = function b() {\n\t// chrome: true, IE8: false\n\tconsole.log(a === b);\n  console.log(b.list['name']);\n  b.log();\n};\n\n// chrome: ReferenceError: b is not defined\n// IE8: function\nconsole.log(typeof b)\n```\n\n## 解决方案\n1. 我们在写原始代码时，不要采用匿名函数表达式。而是需要采用具名函数表达式，且与赋值变量不同的名字。\n2. babel6时，去掉`presets: [\"es2015\"]`，穷举[preset-es2015列表](https://babeljs.io/docs/plugins/preset-es2015/)中除了`transform-es2015-function-name`之外的其他相关plguins。不需要单独安装每一个transform-es2015-*的plugin， 安装`babel-preset-es2015`就可以了。\n\n\n## 为什么babel按照es2015转换时，会自动添加function的name呢\n\nfunciton添加name的好处大多是为了方便调试。可以观察到调用栈Call Stack。虽然现在大多数高级浏览器都可以自己找到这个匿名函数，但是，当匿名函数的层级比较深时，就找不到了。或者不太高级的浏览器，自己也找不到。加了这个之后，就可以方便的看到调用栈了。\n另外呢，还可以便于元编程。函数名也已是ES6的标准之一了，会被自动添加。\n\n* babel6 打包时配置`presets: [\"es2015\"]`，会包括`transform-es2015-function-name`, 它的作用就是将es2015 function.name特性应用到所有function中。\n\n* 在babel5的时候有个blacklist选项可以关掉一些不想要的特性。但是babel6的时候去掉了这个配置选项。解决办法是穷举babel的plugins，里面剔除transform-es2015-function-name。\n\n```\n比如：\npresets: [\n    ['env', {\n        blacklist: ['babel-plugin-transform-async-to-generator']\n    }]\n]\n```\n\n* 也有讨论在`loose mode`下去掉add function name的特性.[transform-es2015-classes loose mode shouldnt add function names](https://github.com/babel/babel/issues/5998)\n\n```\n这样就使得，如果一个函数采用匿名表达式的方式，经过babel转义过后会被转换成：\nvar test = function () {\n\tconsole.log(test.age)\n};\ntest.age = 9;\n\nvar test = function test() {\n\tconsole.log(test.age)\n};\ntest.age = 9;\n```\n\n## 最后一个问题\n按照[UglifyJS2文档](https://github.com/mishoo/UglifyJS2)，配置了`support-ie8: true`之后，就可以避免NFE的问题了。但为啥实际测试中还是未果呢。源码继续追踪中。。\n\n## 参考文章\n* [The names of functions in ES6](The names of functions in ES6)\n* [Babel 基础及代码转换简单探究\n](http://www.qcyoung.com/2017/02/06/Babel%20%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E7%AE%80%E5%8D%95%E6%8E%A2%E7%A9%B6/)\n* [IE8 下访问webpack.UglifyJsPlugin 压缩的代码出错](https://github.com/SamHwang1990/blog/issues/6)\n\n## 写在最最后\n一开始怀疑是webpack版本问题，验证不是之后。\n\n进而怀疑是因为webpack默认为匿名函数添加函数名，认为是webpack做的这件事。这里遗漏了，webpack其实自身什么都不做，只是一个框架。其他的转换什么的是由各插件做的。\n\n后来在[babel在线实验](http://babeljs.cn/repl/)上验证通用会为匿名函数添加函数名。这时可以证实是babel做了这件事。\n\n接下来，怀疑是uglify的问题，但却忘了，只有在IE<9才会报错，在Chrome下是正常的，这时应该怀疑是某种写法在IE下有兼容性问题。",
				"html": "<p>对Webpack打包兼容低版本IE&lt;9时遇到问题的排查过程。</p>\n<a id=\"more\"></a>\n<p>最近在使用webpack打包时，遇到一个问题:<br>已经添加了polyfill，且转成es3语法的前提下，新增uglify之后IE&lt;9浏览器报错。故，怀疑是uglify做了坏事，一步步追踪下去，发现原来是不太规范的一个写法引起的IE老版本下自身bug。</p>\n<h2 id=\"关于版本\"><a href=\"#关于版本\" class=\"headerlink\" title=\"关于版本\"></a>关于版本</h2><p>使用不同版本的webpack2,错误依旧复现。<br>以下讨论的是webpack2.5.1，内置uglify-js2.8.5。</p>\n<h2 id=\"错误1，缺少标识符\"><a href=\"#错误1，缺少标识符\" class=\"headerlink\" title=\"错误1，缺少标识符\"></a>错误1，缺少标识符</h2><p>这种错误大多是压缩后，对象的属性没有了引号，或是以一些保留字作为了对象的属性，比如”default”。<br>这种通过对uglify的配置即可解决。这篇文章总结的很好<a href=\"http://www.zuojj.com/archives/2157.html\" target=\"_blank\" rel=\"external\">煦涵说Webpack-IE低版本兼容指南</a>。<br>具体配置可以参考本博客上一篇文章中关于的uglifyJS的配置。</p>\n<h2 id=\"错误2，没有找到某个对象的方法、属性（重点来了！！！）\"><a href=\"#错误2，没有找到某个对象的方法、属性（重点来了！！！）\" class=\"headerlink\" title=\"错误2，没有找到某个对象的方法、属性（重点来了！！！）\"></a>错误2，没有找到某个对象的方法、属性（重点来了！！！）</h2><p>这个就比较坑了。<br>表现是，初次访问，没有报错，只有执行某个操作时，才报错。可以推测，仅是进入到某个代码内才报错，也就是说是局部报错。<br>首先我们通过定位报错的那段代码，发现是个命名函数表达式。类似这样：<br><figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">A:</div><div class=\"line\">var a = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span><span class=\"params\">()</span> &#123;</span></div><div class=\"line\">  console.<span class=\"built_in\">log</span>(b.<span class=\"built_in\">list</span>[<span class=\"string\">'name'</span>]);</div><div class=\"line\">  b.<span class=\"built_in\">log</span>();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">a.<span class=\"built_in\">list</span> = &#123;&#125;;</div><div class=\"line\">a.<span class=\"built_in\">list</span>[<span class=\"string\">'name'</span>] = <span class=\"string\">'jack'</span>;</div><div class=\"line\">a.<span class=\"built_in\">log</span> = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span>&#123;</span></div><div class=\"line\">  console.<span class=\"built_in\">log</span>(<span class=\"string\">'log'</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>再对应至压缩之前的代码是这样的：<br><figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">B:</div><div class=\"line\">var test = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span><span class=\"params\">()</span> &#123;</span></div><div class=\"line\">  console.<span class=\"built_in\">log</span>(test.<span class=\"built_in\">list</span>[<span class=\"string\">'name'</span>]);</div><div class=\"line\">  test.<span class=\"built_in\">log</span>();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">test.<span class=\"built_in\">list</span> = &#123;&#125;;</div><div class=\"line\">test.<span class=\"built_in\">list</span>[<span class=\"string\">'name'</span>] = <span class=\"string\">'jack'</span>;</div><div class=\"line\">test.<span class=\"built_in\">log</span> = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span>&#123;</span></div><div class=\"line\">  console.<span class=\"built_in\">log</span>(<span class=\"string\">'log'</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>从未压缩的代码可以看到，其实b是一个在函数体内对a的一个引用。<br>然后简单的把b改成a，再执行，发现没有报错了。</p>\n<p>根据MDN上关于<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function\" target=\"_blank\" rel=\"external\">命名函数表达式</a>的定义，可以知道function 的 test 和外部的 test 变量不是一回事。test 这个变量作用域链的原因，在函数内部使用的时候优先找到了 test 这个 function 定义了。</p>\n<p>所以uglify把<code>B -&gt; A</code> 是没有问题的。</p>\n<h2 id=\"那么为什么只会在IE-lt-9会报错呢。\"><a href=\"#那么为什么只会在IE-lt-9会报错呢。\" class=\"headerlink\" title=\"那么为什么只会在IE&lt;9会报错呢。\"></a>那么为什么只会在IE&lt;9会报错呢。</h2><p>这是因为命名表达式在IE&lt;9的一个<a href=\"http://kangax.github.io/nfe/#jscript-bugs\" target=\"_blank\" rel=\"external\">JScript bugs</a>.</p>\n<p>简单来说，是这样的：正常情况下，b只能在函数体内使用，a与b指向同一个内存地址。如果在函数外引用，会报错，未定义。<br>但是在IE&lt;9，会创建2个独立的函数，分别给a，和b。以至于a !== b.这样上面这个函数在IE9以下执行的时候，会报函数体内的对象找不到对应的方法或属性。在函数外引用，反而不报错。<br>看<a href=\"https://stackoverflow.com/questions/14732107/javascript-inconsistency-when-assigning-a-named-function-to-a-variable-named-f\" target=\"_blank\" rel=\"external\">这里的讨论</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// chrome: true, IE8: false</span></div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(a === b);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(b.list[<span class=\"string\">'name'</span>]);</div><div class=\"line\">  b.log();</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// chrome: ReferenceError: b is not defined</span></div><div class=\"line\"><span class=\"comment\">// IE8: function</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> b)</div></pre></td></tr></table></figure>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li>我们在写原始代码时，不要采用匿名函数表达式。而是需要采用具名函数表达式，且与赋值变量不同的名字。</li>\n<li>babel6时，去掉<code>presets: [&quot;es2015&quot;]</code>，穷举<a href=\"https://babeljs.io/docs/plugins/preset-es2015/\" target=\"_blank\" rel=\"external\">preset-es2015列表</a>中除了<code>transform-es2015-function-name</code>之外的其他相关plguins。不需要单独安装每一个transform-es2015-*的plugin， 安装<code>babel-preset-es2015</code>就可以了。</li>\n</ol>\n<h2 id=\"为什么babel按照es2015转换时，会自动添加function的name呢\"><a href=\"#为什么babel按照es2015转换时，会自动添加function的name呢\" class=\"headerlink\" title=\"为什么babel按照es2015转换时，会自动添加function的name呢\"></a>为什么babel按照es2015转换时，会自动添加function的name呢</h2><p>funciton添加name的好处大多是为了方便调试。可以观察到调用栈Call Stack。虽然现在大多数高级浏览器都可以自己找到这个匿名函数，但是，当匿名函数的层级比较深时，就找不到了。或者不太高级的浏览器，自己也找不到。加了这个之后，就可以方便的看到调用栈了。<br>另外呢，还可以便于元编程。函数名也已是ES6的标准之一了，会被自动添加。</p>\n<ul>\n<li><p>babel6 打包时配置<code>presets: [&quot;es2015&quot;]</code>，会包括<code>transform-es2015-function-name</code>, 它的作用就是将es2015 function.name特性应用到所有function中。</p>\n</li>\n<li><p>在babel5的时候有个blacklist选项可以关掉一些不想要的特性。但是babel6的时候去掉了这个配置选项。解决办法是穷举babel的plugins，里面剔除transform-es2015-function-name。</p>\n</li>\n</ul>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">比如：</div><div class=\"line\">presets: [</div><div class=\"line\">    [<span class=\"string\">'env'</span>, &#123;</div><div class=\"line\">        blacklist: [<span class=\"string\">'babel-plugin-transform-async-to-generator'</span>]</div><div class=\"line\">    &#125;]</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<ul>\n<li>也有讨论在<code>loose mode</code>下去掉add function name的特性.<a href=\"https://github.com/babel/babel/issues/5998\" target=\"_blank\" rel=\"external\">transform-es2015-classes loose mode shouldnt add function names</a></li>\n</ul>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">这样就使得，如果一个函数采用匿名表达式的方式，经过babel转义过后会被转换成：</div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">test</span> = function () &#123;</div><div class=\"line\">\tconsole.<span class=\"built_in\">log</span>(<span class=\"keyword\">test</span>.age)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">test</span>.age = 9;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">test</span> = function <span class=\"keyword\">test</span>() &#123;</div><div class=\"line\">\tconsole.<span class=\"built_in\">log</span>(<span class=\"keyword\">test</span>.age)</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">test</span>.age = 9;</div></pre></td></tr></table></figure>\n<h2 id=\"最后一个问题\"><a href=\"#最后一个问题\" class=\"headerlink\" title=\"最后一个问题\"></a>最后一个问题</h2><p>按照<a href=\"https://github.com/mishoo/UglifyJS2\" target=\"_blank\" rel=\"external\">UglifyJS2文档</a>，配置了<code>support-ie8: true</code>之后，就可以避免NFE的问题了。但为啥实际测试中还是未果呢。源码继续追踪中。。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"The names of functions in ES6\">The names of functions in ES6</a></li>\n<li><a href=\"http://www.qcyoung.com/2017/02/06/Babel%20%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%BB%A3%E7%A0%81%E8%BD%AC%E6%8D%A2%E7%AE%80%E5%8D%95%E6%8E%A2%E7%A9%B6/\" target=\"_blank\" rel=\"external\">Babel 基础及代码转换简单探究\n</a></li>\n<li><a href=\"https://github.com/SamHwang1990/blog/issues/6\" target=\"_blank\" rel=\"external\">IE8 下访问webpack.UglifyJsPlugin 压缩的代码出错</a></li>\n</ul>\n<h2 id=\"写在最最后\"><a href=\"#写在最最后\" class=\"headerlink\" title=\"写在最最后\"></a>写在最最后</h2><p>一开始怀疑是webpack版本问题，验证不是之后。</p>\n<p>进而怀疑是因为webpack默认为匿名函数添加函数名，认为是webpack做的这件事。这里遗漏了，webpack其实自身什么都不做，只是一个框架。其他的转换什么的是由各插件做的。</p>\n<p>后来在<a href=\"http://babeljs.cn/repl/\" target=\"_blank\" rel=\"external\">babel在线实验</a>上验证通用会为匿名函数添加函数名。这时可以证实是babel做了这件事。</p>\n<p>接下来，怀疑是uglify的问题，但却忘了，只有在IE&lt;9才会报错，在Chrome下是正常的，这时应该怀疑是某种写法在IE下有兼容性问题。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1501042641000,
				"created_by": 2,
				"updated_at": 1501081005000,
				"updated_by": 2,
				"published_at": 1501042641000,
				"published_by": 2
			},
			{
				"id": "cj914po0u0058e0hyp2k82hew",
				"title": "常用Webpack2优化要点",
				"slug": "webpack2",
				"markdown": "\n基于webpack自身配置的优化，不涉及到happypack和DLL.\n\n<!-- more -->\n\n## 总述\nwebpack自身是单进程的。优化的总思路是，时间上，小范围，扫描次数少；空间上，能分离即分离，能不打包不打包，在http请求数与文件大小之间找到平衡。\n\n## 1.entry\n根据指定目录下动态生成entry对象，可根据不同场景区分entry中的数量。间接提高开发效率。\n或者遍历文件夹，生成entry对象。\n```\nlet srcDir = path.resolve(process.cwd(), 'static/\\$dev')\nlet componentsDir = path.resolve(process.cwd(), 'static/\\$dev/components')\n\nlet entries = (() => {\n\tlet entryFiles = (process.env.NODE_ENV === 'production')\n\t\t\t\t\t? glob.sync(srcDir+\"/+(index|service|tryout|app|user|stat|knowledge|doc|plan|tech|example|semservice|semutterance)/*.js\")\n\t \t\t\t\t: glob.sync(srcDir+\"/+(index|semservice|semutterance|knowledge|app)/*.js\")\n\tlet map = {}\n\tentryFiles.forEach(function(filepath){\n\t\tlet filename = filepath.substring(filepath.lastIndexOf('\\/') + 1,filepath.lastIndexOf(\".\"))\n\t\tmap[filename] = filepath;\n\t});\n\treturn map\n}())\n```\n\n## 2.resolve\n**modules**默认只包括**node_modules**，如果需要添加其他的目录，需要保证**node_modules**在最后一位。\n```\nresolve:{\n\t// 使用绝对路径，将只在给定目录中搜索。\n\tmodules: [path.resolve(__dirname, \"src\"), \"node_modules\"],\n\t// 可省略文件后缀\n\textensions: ['.js', '.vue'],\n\t// 减少webpack扫描时，每次查找相同包的时间。\n\talias:{\n\t\techarts:\"components/echarts.min.js\", // echarts\n\t\tcitySelector:\"components/citySelector.js\" // 城市选择\n\t}\n},\n\n// 文件内引用时\nimport echarts from 'echarts';\n```\n\n## 3.module中的rules\n总的来说就是，尽量添加**include**, **exclude**，限定范围。\n在rules进行test时，尽量精准匹配，比如如果没有jsx的文件，只有js的，test就可以写为**/\\.js$/**，而不是**/\\.jsx?$/**。（具体正则匹配的效率上，没有实际验证过。。）\n\n其中babel, babel对文件的编译时间是比较久的，里面东西比较多，这里简单说几点。\n配置中可以开启cache，这样在文件没有修改的时候，babel不会重新编译，以节约时间。\n另一个是，`babel-pollyfill`和`transform-runtime`。\n```\n{\n\ttest: /\\.js$/,\n  loader: 'babel-loader?cacheDirectory',\n  include: [path.resolve(__dirname, \"src\")],\n  exclude: [path.resolve(__dirname, \"src\", \"assets\"), /node_modules/]\n}\n```\n\n```\n.babelrc\n{\n  \"presets\": [\n  \t[\n  \t\t\"es2015\",\n  \t{\n  \t\t// 对modules语法不做转换，defaults to 'commonjs'\n  \t\t\"modules\": false\n  \t}],\n  \t// 0 -> n, 0打包后的代码量最大。\n  \t\"stage-0\"\n  ],\n  // 动态对babel不能转换的新的API进行‘填补’\n  \"plugins\": [\"transform-runtime\"],\n  \"comments\": false\n}\n```\n\n## 4.module中的noParse\n```\nmodule{\n\t//忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制\n\t// noParse:[componentsDir]\n\tnoParse:['jquery', 'lodash'],\n\trules: [\n\t\t....\n\t]\n}\n```\n\n## 5.只在production环境下的，tree-shaking\n实际验证现阶段（2017.7.27）tree-shaking之后，文件大小变化并不明显。主要受写法限制。尤其是引用大量第三方非ES6写法的库，其实作用不是很大。如果是从头自己写，在遵循ES6标准的基础上，控制性更好些。\n同时uglify本身时间还比较长。用时间换空间的性价比不高。\n\n因为tree-shaking必须配置一些压缩插件才能实现，默认是使用**webpack-uglifyJS**,但是由于是单进程的，处理比较慢。可选用**webpack-parallel-uglify-plugin**，多核处理。\n\n```\nnew UglifyJsparallelPlugin({\n  cacheDir: '.cache/',\n  workerCount: os.cpus().length,\n  uglifyJS: {\n  \t// 可以用uglifyJS自身的配置\n  \t// 这里用于支持低版本IE\n    supper_ie8: true,\n    compress: {\n        screw_ie8: false,\n        properties: false,\n        warnings: false\n    },\n    output: {\n        screw_ie8: false,\n        beautify: true,\n        quote_keys: true\n    },\n    mangle: {\n        screw_ie8: false\n    },\n    sourceMap: false\n  }\n})\n```\n\n## 6. 只在dev环境下\n`module.exports.devtool = '#cheap-module-eval-source-map';`\n\n## 7. 编译成es3\n关于在IE低版本下运行，这里会遇到一些坑，另开一篇具体说说。\n```\nconst es3ifyPlugin = require('es3ify-webpack-plugin');\n```\n\n## 好了，做完上述优化，你会发现时间上变化并不明显。。。其实最主要的还是需要DLL，拆分，分步。\n\n## webpack.optimize.CommonsChunkPlugin\n```\nentry中，\n//需要配合下面的CommonsChunkPlugin才能把库文件从index中分类出来\nvendor: [\"vue\", \"vue-router\", \"axios\"]\n\nnew CommonsChunkPlugin({\n  name: 'vendor',\n  filename: \"vendor.js\"\n})\n```\n\n## 其他一些常用配置\n\n### package.json\n**npm run build** \n```\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --hot --quiet --host 127.0.0.1 --port 8300\",\n    \"build\": \"../node_modules/.bin/cross-env NODE_ENV=production DEBUG_ENV=online webpack --progress --hide-modules --colors --profile\"\n  },\n```\n\n### 查看打包后的文件大小\nhttp://alexkuz.github.io/webpack-chart/\nwebpack --json --profile > stats.json\n\n### webpack-dev-server\n与webpack -w 的区别\nwebpack -w 增量打包，在界面不会有任何体现，需要手动刷新。\n\nwebpack-dev-server，基于express的8080 Node服务器。可以设置代理等等。\n具有HMR(热替换), LiveReload(自动刷新整个页面)。\n实时编译，在内存中的。比webpack -w更快。\n打包的静态资源路径相对于publicPath，如果不设置，相对于当前目录下。publicPath的优先级高于content-base的\n\n**这里面有个content-base, 还没弄清楚干啥的？？。。**\ncontent-base是webpack-dev-server的HTTP服务启动后的根目录。最直接的就是如何访问到那个index.html的途径，与其物理存放位置的关系。\n\n\n\n\n\n\n\n",
				"html": "<p>基于webpack自身配置的优化，不涉及到happypack和DLL.</p>\n<a id=\"more\"></a>\n<h2 id=\"总述\"><a href=\"#总述\" class=\"headerlink\" title=\"总述\"></a>总述</h2><p>webpack自身是单进程的。优化的总思路是，时间上，小范围，扫描次数少；空间上，能分离即分离，能不打包不打包，在http请求数与文件大小之间找到平衡。</p>\n<h2 id=\"1-entry\"><a href=\"#1-entry\" class=\"headerlink\" title=\"1.entry\"></a>1.entry</h2><p>根据指定目录下动态生成entry对象，可根据不同场景区分entry中的数量。间接提高开发效率。<br>或者遍历文件夹，生成entry对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> srcDir = path.resolve(process.cwd(), <span class=\"string\">'static/\\$dev'</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> componentsDir = path.resolve(process.cwd(), <span class=\"string\">'static/\\$dev/components'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> entries = <span class=\"function\">(<span class=\"params\">(</span>) =&gt;</span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">let</span> entryFiles = (process.env.NODE_ENV === <span class=\"string\">'production'</span>)</div><div class=\"line\">\t\t\t\t\t? glob.sync(srcDir+<span class=\"string\">\"/+(index|service|tryout|app|user|stat|knowledge|doc|plan|tech|example|semservice|semutterance)/*.js\"</span>)</div><div class=\"line\">\t \t\t\t\t: glob.sync(srcDir+<span class=\"string\">\"/+(index|semservice|semutterance|knowledge|app)/*.js\"</span>)</div><div class=\"line\">\t<span class=\"keyword\">let</span> map = &#123;&#125;</div><div class=\"line\">\tentryFiles.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filepath</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">let</span> filename = filepath.substring(filepath.lastIndexOf(<span class=\"string\">'\\/'</span>) + <span class=\"number\">1</span>,filepath.lastIndexOf(<span class=\"string\">\".\"</span>))</div><div class=\"line\">\t\tmap[filename] = filepath;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t<span class=\"keyword\">return</span> map</div><div class=\"line\">&#125;())</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-resolve\"><a href=\"#2-resolve\" class=\"headerlink\" title=\"2.resolve\"></a>2.resolve</h2><p><strong>modules</strong>默认只包括<strong>node_modules</strong>，如果需要添加其他的目录，需要保证<strong>node_modules</strong>在最后一位。<br><figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">resolve:&#123;</div><div class=\"line\">\t<span class=\"comment\">// 使用绝对路径，将只在给定目录中搜索。</span></div><div class=\"line\">\tmodules: [path.resolve(<span class=\"number\">__</span>dirname, <span class=\"string\">\"src\"</span>), <span class=\"string\">\"node_modules\"</span>],</div><div class=\"line\">\t<span class=\"comment\">// 可省略文件后缀</span></div><div class=\"line\">\textensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.vue'</span>],</div><div class=\"line\">\t<span class=\"comment\">// 减少webpack扫描时，每次查找相同包的时间。</span></div><div class=\"line\">\t<span class=\"keyword\">alias</span>:&#123;</div><div class=\"line\">\t\techarts:<span class=\"string\">\"components/echarts.min.js\"</span>, <span class=\"comment\">// echarts</span></div><div class=\"line\">\t\tcitySelector:<span class=\"string\">\"components/citySelector.js\"</span> <span class=\"comment\">// 城市选择</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 文件内引用时</span></div><div class=\"line\"><span class=\"keyword\">import</span> echarts from <span class=\"string\">'echarts'</span>;</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-module中的rules\"><a href=\"#3-module中的rules\" class=\"headerlink\" title=\"3.module中的rules\"></a>3.module中的rules</h2><p>总的来说就是，尽量添加<strong>include</strong>, <strong>exclude</strong>，限定范围。<br>在rules进行test时，尽量精准匹配，比如如果没有jsx的文件，只有js的，test就可以写为<strong>/.js$/</strong>，而不是<strong>/.jsx?$/</strong>。（具体正则匹配的效率上，没有实际验证过。。）</p>\n<p>其中babel, babel对文件的编译时间是比较久的，里面东西比较多，这里简单说几点。<br>配置中可以开启cache，这样在文件没有修改的时候，babel不会重新编译，以节约时间。<br>另一个是，<code>babel-pollyfill</code>和<code>transform-runtime</code>。<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"attribute\">test</span>: /\\.js$/,</div><div class=\"line\">  loader: <span class=\"string\">'babel-loader?cacheDirectory'</span>,</div><div class=\"line\">  include: [path.<span class=\"built_in\">resolve</span>(__dirname, <span class=\"string\">\"src\"</span>)],</div><div class=\"line\">  exclude: [path.<span class=\"built_in\">resolve</span>(__dirname, <span class=\"string\">\"src\"</span>, <span class=\"string\">\"assets\"</span>), /node_modules/]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">.babelrc</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"presets\"</span>: [</div><div class=\"line\">  \t[</div><div class=\"line\">  \t\t<span class=\"string\">\"es2015\"</span>,</div><div class=\"line\">  \t&#123;</div><div class=\"line\">  \t\t<span class=\"regexp\">//</span> 对modules语法不做转换，defaults to <span class=\"string\">'commonjs'</span></div><div class=\"line\">  \t\t<span class=\"string\">\"modules\"</span>: <span class=\"keyword\">false</span></div><div class=\"line\">  \t&#125;],</div><div class=\"line\">  \t<span class=\"regexp\">//</span> <span class=\"number\">0</span> -&gt; n, <span class=\"number\">0</span>打包后的代码量最大。</div><div class=\"line\">  \t<span class=\"string\">\"stage-0\"</span></div><div class=\"line\">  ],</div><div class=\"line\">  <span class=\"regexp\">//</span> 动态对babel不能转换的新的API进行‘填补’</div><div class=\"line\">  <span class=\"string\">\"plugins\"</span>: [<span class=\"string\">\"transform-runtime\"</span>],</div><div class=\"line\">  <span class=\"string\">\"comments\"</span>: <span class=\"keyword\">false</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-module中的noParse\"><a href=\"#4-module中的noParse\" class=\"headerlink\" title=\"4.module中的noParse\"></a>4.module中的noParse</h2><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">module</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制</span></div><div class=\"line\">\t<span class=\"comment\">// noParse:[componentsDir]</span></div><div class=\"line\">\t<span class=\"attribute\">noParse</span>:[<span class=\"string\">'jquery'</span>, <span class=\"string\">'lodash'</span>],</div><div class=\"line\">\t<span class=\"attribute\">rules</span>: [</div><div class=\"line\">\t\t....</div><div class=\"line\">\t]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"5-只在production环境下的，tree-shaking\"><a href=\"#5-只在production环境下的，tree-shaking\" class=\"headerlink\" title=\"5.只在production环境下的，tree-shaking\"></a>5.只在production环境下的，tree-shaking</h2><p>实际验证现阶段（2017.7.27）tree-shaking之后，文件大小变化并不明显。主要受写法限制。尤其是引用大量第三方非ES6写法的库，其实作用不是很大。如果是从头自己写，在遵循ES6标准的基础上，控制性更好些。<br>同时uglify本身时间还比较长。用时间换空间的性价比不高。</p>\n<p>因为tree-shaking必须配置一些压缩插件才能实现，默认是使用<strong>webpack-uglifyJS</strong>,但是由于是单进程的，处理比较慢。可选用<strong>webpack-parallel-uglify-plugin</strong>，多核处理。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">new UglifyJsparallelPlugin(&#123;</div><div class=\"line\"><span class=\"attr\">  cacheDir:</span> <span class=\"string\">'.cache/'</span>,</div><div class=\"line\"><span class=\"attr\">  workerCount:</span> os.cpus().length,</div><div class=\"line\"><span class=\"attr\">  uglifyJS:</span> &#123;</div><div class=\"line\">  \t// 可以用uglifyJS自身的配置</div><div class=\"line\">  \t// 这里用于支持低版本IE</div><div class=\"line\"><span class=\"attr\">    supper_ie8:</span> <span class=\"literal\">true</span>,</div><div class=\"line\"><span class=\"attr\">    compress:</span> &#123;</div><div class=\"line\"><span class=\"attr\">        screw_ie8:</span> <span class=\"literal\">false</span>,</div><div class=\"line\"><span class=\"attr\">        properties:</span> <span class=\"literal\">false</span>,</div><div class=\"line\"><span class=\"attr\">        warnings:</span> <span class=\"literal\">false</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"><span class=\"attr\">    output:</span> &#123;</div><div class=\"line\"><span class=\"attr\">        screw_ie8:</span> <span class=\"literal\">false</span>,</div><div class=\"line\"><span class=\"attr\">        beautify:</span> <span class=\"literal\">true</span>,</div><div class=\"line\"><span class=\"attr\">        quote_keys:</span> <span class=\"literal\">true</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"><span class=\"attr\">    mangle:</span> &#123;</div><div class=\"line\"><span class=\"attr\">        screw_ie8:</span> <span class=\"literal\">false</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"><span class=\"attr\">    sourceMap:</span> <span class=\"literal\">false</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"6-只在dev环境下\"><a href=\"#6-只在dev环境下\" class=\"headerlink\" title=\"6. 只在dev环境下\"></a>6. 只在dev环境下</h2><p><code>module.exports.devtool = &#39;#cheap-module-eval-source-map&#39;;</code></p>\n<h2 id=\"7-编译成es3\"><a href=\"#7-编译成es3\" class=\"headerlink\" title=\"7. 编译成es3\"></a>7. 编译成es3</h2><p>关于在IE低版本下运行，这里会遇到一些坑，另开一篇具体说说。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> es3ifyPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'es3ify-webpack-plugin'</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"好了，做完上述优化，你会发现时间上变化并不明显。。。其实最主要的还是需要DLL，拆分，分步。\"><a href=\"#好了，做完上述优化，你会发现时间上变化并不明显。。。其实最主要的还是需要DLL，拆分，分步。\" class=\"headerlink\" title=\"好了，做完上述优化，你会发现时间上变化并不明显。。。其实最主要的还是需要DLL，拆分，分步。\"></a>好了，做完上述优化，你会发现时间上变化并不明显。。。其实最主要的还是需要DLL，拆分，分步。</h2><h2 id=\"webpack-optimize-CommonsChunkPlugin\"><a href=\"#webpack-optimize-CommonsChunkPlugin\" class=\"headerlink\" title=\"webpack.optimize.CommonsChunkPlugin\"></a>webpack.optimize.CommonsChunkPlugin</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">entry中，</div><div class=\"line\"><span class=\"comment\">//需要配合下面的CommonsChunkPlugin才能把库文件从index中分类出来</span></div><div class=\"line\"><span class=\"string\">vendor:</span> [<span class=\"string\">\"vue\"</span>, <span class=\"string\">\"vue-router\"</span>, <span class=\"string\">\"axios\"</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">new</span> CommonsChunkPlugin(&#123;</div><div class=\"line\"><span class=\"symbol\">  name:</span> <span class=\"string\">'vendor'</span>,</div><div class=\"line\"><span class=\"symbol\">  filename:</span> <span class=\"string\">\"vendor.js\"</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h2 id=\"其他一些常用配置\"><a href=\"#其他一些常用配置\" class=\"headerlink\" title=\"其他一些常用配置\"></a>其他一些常用配置</h2><h3 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h3><p><strong>npm run build</strong><br><figure class=\"highlight brainfuck\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">\"scripts\":</span> <span class=\"comment\">&#123;</span></div><div class=\"line\">    <span class=\"comment\">\"dev\":</span> <span class=\"comment\">\"webpack</span><span class=\"literal\">-</span><span class=\"comment\">dev</span><span class=\"literal\">-</span><span class=\"comment\">server</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">inline</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">hot</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">quiet</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">host</span> <span class=\"comment\">127</span><span class=\"string\">.</span><span class=\"comment\">0</span><span class=\"string\">.</span><span class=\"comment\">0</span><span class=\"string\">.</span><span class=\"comment\">1</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">port</span> <span class=\"comment\">8300\"</span><span class=\"string\">,</span></div><div class=\"line\">    <span class=\"comment\">\"build\":</span> <span class=\"comment\">\"</span><span class=\"string\">.</span><span class=\"string\">.</span><span class=\"comment\">/node_modules/</span><span class=\"string\">.</span><span class=\"comment\">bin/cross</span><span class=\"literal\">-</span><span class=\"comment\">env</span> <span class=\"comment\">NODE_ENV=production</span> <span class=\"comment\">DEBUG_ENV=online</span> <span class=\"comment\">webpack</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">progress</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">hide</span><span class=\"literal\">-</span><span class=\"comment\">modules</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">colors</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">profile\"</span></div><div class=\"line\">  <span class=\"comment\">&#125;</span><span class=\"string\">,</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"查看打包后的文件大小\"><a href=\"#查看打包后的文件大小\" class=\"headerlink\" title=\"查看打包后的文件大小\"></a>查看打包后的文件大小</h3><p><a href=\"http://alexkuz.github.io/webpack-chart/\" target=\"_blank\" rel=\"external\">http://alexkuz.github.io/webpack-chart/</a><br>webpack –json –profile &gt; stats.json</p>\n<h3 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack-dev-server\"></a>webpack-dev-server</h3><p>与webpack -w 的区别<br>webpack -w 增量打包，在界面不会有任何体现，需要手动刷新。</p>\n<p>webpack-dev-server，基于express的8080 Node服务器。可以设置代理等等。<br>具有HMR(热替换), LiveReload(自动刷新整个页面)。<br>实时编译，在内存中的。比webpack -w更快。<br>打包的静态资源路径相对于publicPath，如果不设置，相对于当前目录下。publicPath的优先级高于content-base的</p>\n<p><strong>这里面有个content-base, 还没弄清楚干啥的？？。。</strong><br>content-base是webpack-dev-server的HTTP服务启动后的根目录。最直接的就是如何访问到那个index.html的途径，与其物理存放位置的关系。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1501042511000,
				"created_by": 2,
				"updated_at": 1501081335000,
				"updated_by": 2,
				"published_at": 1501042511000,
				"published_by": 2
			},
			{
				"id": "cj914po070043e0hyvj526fim",
				"title": "选中文本换背景色的实现",
				"slug": "range",
				"markdown": "\n最近遇到的一个需求是，选择某段文字中的部分，为选中区域加颜色<!-- more -->主要是用到`window.getSelection()`和`rangeObject`\n\n## 主要方法\n需要区分高级浏览器和IE。这里只讨论高级浏览器下的用法。\n* `userSelection = window.getSelection()`\n* `userSelection.toString()`\n* `rangeObject = userSelection.getRangeAt(0)`\n* `rangeObject.startContainer`\n* `rangeObject.getClientRects()`\n* `rangeObject.deleteContents()`\n* `rangeObject.insertNode(span)`\n\n1. [MDN Range](https://developer.mozilla.org/en-US/docs/Web/API/Range)\n2. [MDN Selection](https://developer.mozilla.org/en-US/docs/Web/API/Selection)\n3. 《Javasctipt高级程序设计》P438\n\n\n## 代码\n前方高能，大段代码。。。\n\n\n```\n/*是否在合法选择范围内*/\nfunction rangeIsOk(sContainer, eContainer){\n\t\n}\n\n$('html, body').on('mousedown', function(e){\n    if(!$(e.target).is('.tip-entity-list *')){\n        // 先清空选区，否则再次点击选区会再次获得选区内容\n        userSelection && userSelection.removeAllRanges();\n        selTip.hide();\n    }else if($(e.target).is('*[unselectable=on]')){\n        e.preventDefault();\n        return false;\n    }\n});\n\n\n$('body').on('mouseup', function(e){\n    var me = $(this);\n\n    // 优先用高级浏览器的\n    if(window.getSelection()){\n        userSelection = window.getSelection();\n        selText = userSelection.toString();\n    }\n    \n    // 没有选中的文字，或者click事件直接返回\n    if(!selText.length) return false;\n\t\t\n\t\t// 获得多个选区中的第一个选区\n    rangeObject = userSelection;\n    if (userSelection && userSelection.getRangeAt) {\n        rangeObject = userSelection.getRangeAt(0);\n    }\n\t\n    if(!rangeObject.collapsed){\n        var sContainer = rangeObject.startContainer.parentNode;\n        var eContainer = rangeObject.endContainer.parentNode;\n        \n        // 下面这个是为了定位选中后提示框的位置\n        if(rangeIsOk(sContainer, eContainer)){\n        \t\t// 获得选中区域的一个矩阵\n            var rangeRects = rangeObject.getClientRects();\n            var maxTop = 0, num = 0, pHeight = 20;\n            for(var i = 0, len = rangeRects.length; i < len; i++){\n                //pHeight：一行文字的高度，为了避免双击选中整个大的区域\n                if(rangeRects[i].height <= pHeight && rangeRects[i].width && maxTop < rangeRects[i].top){\n                    maxTop = rangeRects[i].top;\n                    num = i;\n                }\n            }\n\t\t\t\n            var lastLeft = Math.floor(rangeRects[num].left + rangeRects[num].width);\n            var lastTop =  Math.ceil(rangeRects[num].top + rangeRects[num].height);\n            \n            tipX = lastLeft;\n            tipY = lastTop + $(window).scrollTop();\n            \n            var tipEntityLen = $('.tip-entity-item').length;\n            if(tipEntityLen){\n                // 不trim会获得选中的空格\n                if($.trim(selText)){\n                    tipShow(selText, tipX, tipY);\n                }\n            }else{\n                // open dialog\n                showTipPanel($(\"#messPanel\"), \"没有待选项\");\n            }\n            \n        }\n    }\n\n});\n\nfunction tipShow(text, tipX, tipY){\n    selTip.css('left',tipX).css('top',tipY).show();\n}\n```\n\n```\n// 加上颜色\n$('body').on('click', '.tip-entity-item', function(e){\n    \n    var me = $(this);\n    var color = me.attr('data-color');\n    var title = me.attr('data-title');\n    var type = me.attr('data-type');\n    \n    var sContainer = rangeObject.startContainer.parentNode;\n    var eContainer = rangeObject.endContainer.parentNode;\n\n    if(rangeIsOk(sContainer, eContainer)){\n        var span = document.createElement('span');\n        span.innerHTML = selText;\n        span.style.background = color;\n        span.title = title;\n        span.setAttribute('data-eid', type);\n        \n        rangeObject.deleteContents();\n        rangeObject.insertNode(span);\n\n    }else if(sNodeName == 'SPAN' || eNodeName == 'SPAN'){\n        alert('已经有选中了的，点击取消后再进行重新选择')\n    }\n\n    selTip.hide();\n});\n```\n\n```\n递归的为某节点添加不可选择属性\nfunction makeUnselectable(node) {\n\t\t//Node.ELEMENT_NODE\n    if (node.nodeType == 1) {\n        node.setAttribute(\"unselectable\", \"on\");\n    }\n    var child = node.firstChild;\n    while (child) {\n        makeUnselectable(child);\n        child = child.nextSibling;\n    }\n}\n```\n",
				"html": "<p>最近遇到的一个需求是，选择某段文字中的部分，为选中区域加颜色<a id=\"more\"></a>主要是用到<code>window.getSelection()</code>和<code>rangeObject</code></p>\n<h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><p>需要区分高级浏览器和IE。这里只讨论高级浏览器下的用法。</p>\n<ul>\n<li><code>userSelection = window.getSelection()</code></li>\n<li><code>userSelection.toString()</code></li>\n<li><code>rangeObject = userSelection.getRangeAt(0)</code></li>\n<li><code>rangeObject.startContainer</code></li>\n<li><code>rangeObject.getClientRects()</code></li>\n<li><code>rangeObject.deleteContents()</code></li>\n<li><code>rangeObject.insertNode(span)</code></li>\n</ul>\n<ol>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Range\" target=\"_blank\" rel=\"external\">MDN Range</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Selection\" target=\"_blank\" rel=\"external\">MDN Selection</a></li>\n<li>《Javasctipt高级程序设计》P438</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>前方高能，大段代码。。。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*是否在合法选择范围内*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rangeIsOk</span>(<span class=\"params\">sContainer, eContainer</span>)</span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'html, body'</span>).on(<span class=\"string\">'mousedown'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(!$(e.target).is(<span class=\"string\">'.tip-entity-list *'</span>))&#123;</div><div class=\"line\">        <span class=\"comment\">// 先清空选区，否则再次点击选区会再次获得选区内容</span></div><div class=\"line\">        userSelection &amp;&amp; userSelection.removeAllRanges();</div><div class=\"line\">        selTip.hide();</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>($(e.target).is(<span class=\"string\">'*[unselectable=on]'</span>))&#123;</div><div class=\"line\">        e.preventDefault();</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$(<span class=\"string\">'body'</span>).on(<span class=\"string\">'mouseup'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> me = $(<span class=\"keyword\">this</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 优先用高级浏览器的</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.getSelection())&#123;</div><div class=\"line\">        userSelection = <span class=\"built_in\">window</span>.getSelection();</div><div class=\"line\">        selText = userSelection.toString();</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 没有选中的文字，或者click事件直接返回</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(!selText.length) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"comment\">// 获得多个选区中的第一个选区</span></div><div class=\"line\">    rangeObject = userSelection;</div><div class=\"line\">    <span class=\"keyword\">if</span> (userSelection &amp;&amp; userSelection.getRangeAt) &#123;</div><div class=\"line\">        rangeObject = userSelection.getRangeAt(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"keyword\">if</span>(!rangeObject.collapsed)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> sContainer = rangeObject.startContainer.parentNode;</div><div class=\"line\">        <span class=\"keyword\">var</span> eContainer = rangeObject.endContainer.parentNode;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 下面这个是为了定位选中后提示框的位置</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(rangeIsOk(sContainer, eContainer))&#123;</div><div class=\"line\">        \t\t<span class=\"comment\">// 获得选中区域的一个矩阵</span></div><div class=\"line\">            <span class=\"keyword\">var</span> rangeRects = rangeObject.getClientRects();</div><div class=\"line\">            <span class=\"keyword\">var</span> maxTop = <span class=\"number\">0</span>, num = <span class=\"number\">0</span>, pHeight = <span class=\"number\">20</span>;</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = rangeRects.length; i &lt; len; i++)&#123;</div><div class=\"line\">                <span class=\"comment\">//pHeight：一行文字的高度，为了避免双击选中整个大的区域</span></div><div class=\"line\">                <span class=\"keyword\">if</span>(rangeRects[i].height &lt;= pHeight &amp;&amp; rangeRects[i].width &amp;&amp; maxTop &lt; rangeRects[i].top)&#123;</div><div class=\"line\">                    maxTop = rangeRects[i].top;</div><div class=\"line\">                    num = i;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">\t\t\t</div><div class=\"line\">            <span class=\"keyword\">var</span> lastLeft = <span class=\"built_in\">Math</span>.floor(rangeRects[num].left + rangeRects[num].width);</div><div class=\"line\">            <span class=\"keyword\">var</span> lastTop =  <span class=\"built_in\">Math</span>.ceil(rangeRects[num].top + rangeRects[num].height);</div><div class=\"line\">            </div><div class=\"line\">            tipX = lastLeft;</div><div class=\"line\">            tipY = lastTop + $(<span class=\"built_in\">window</span>).scrollTop();</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">var</span> tipEntityLen = $(<span class=\"string\">'.tip-entity-item'</span>).length;</div><div class=\"line\">            <span class=\"keyword\">if</span>(tipEntityLen)&#123;</div><div class=\"line\">                <span class=\"comment\">// 不trim会获得选中的空格</span></div><div class=\"line\">                <span class=\"keyword\">if</span>($.trim(selText))&#123;</div><div class=\"line\">                    tipShow(selText, tipX, tipY);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                <span class=\"comment\">// open dialog</span></div><div class=\"line\">                showTipPanel($(<span class=\"string\">\"#messPanel\"</span>), <span class=\"string\">\"没有待选项\"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tipShow</span>(<span class=\"params\">text, tipX, tipY</span>)</span>&#123;</div><div class=\"line\">    selTip.css(<span class=\"string\">'left'</span>,tipX).css(<span class=\"string\">'top'</span>,tipY).show();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 加上颜色</span></div><div class=\"line\">$(<span class=\"string\">'body'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'.tip-entity-item'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">var</span> me = $(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> color = me.attr(<span class=\"string\">'data-color'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> title = me.attr(<span class=\"string\">'data-title'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">type</span> = me.attr(<span class=\"string\">'data-type'</span>);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">var</span> sContainer = rangeObject.startContainer.parentNode;</div><div class=\"line\">    <span class=\"keyword\">var</span> eContainer = rangeObject.endContainer.parentNode;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(rangeIsOk(sContainer, eContainer))&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> span = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'span'</span>);</div><div class=\"line\">        span.innerHTML = selText;</div><div class=\"line\">        span.style.background = color;</div><div class=\"line\">        span.title = title;</div><div class=\"line\">        span.setAttribute(<span class=\"string\">'data-eid'</span>, <span class=\"keyword\">type</span>);</div><div class=\"line\">        </div><div class=\"line\">        rangeObject.deleteContents();</div><div class=\"line\">        rangeObject.insertNode(span);</div><div class=\"line\"></div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sNodeName == <span class=\"string\">'SPAN'</span> || eNodeName == <span class=\"string\">'SPAN'</span>)&#123;</div><div class=\"line\">        alert(<span class=\"string\">'已经有选中了的，点击取消后再进行重新选择'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    selTip.hide();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">递归的为某节点添加不可选择属性</div><div class=\"line\">function makeUnselectable(<span class=\"keyword\">node</span><span class=\"title\">) &#123;</span></div><div class=\"line\">\t\t//Node.ELEMENT_NODE</div><div class=\"line\">    if (<span class=\"keyword\">node</span>.<span class=\"title\">nodeType</span> == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">node</span>.<span class=\"title\">setAttribute</span>(<span class=\"string\">\"unselectable\"</span>, <span class=\"string\">\"on\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    var child = <span class=\"keyword\">node</span>.<span class=\"title\">firstChild</span>;</div><div class=\"line\">    while (child) &#123;</div><div class=\"line\">        makeUnselectable(child);</div><div class=\"line\">        child = child.nextSibling;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1473590340000,
				"created_by": 2,
				"updated_at": 1477907280000,
				"updated_by": 2,
				"published_at": 1473590340000,
				"published_by": 2
			},
			{
				"id": "cj914po080045e0hy30ccl5ts",
				"title": "React系列之-使用React+Redux中遇到的坑",
				"slug": "react-summary",
				"markdown": "\n初次相遇总是美好的，相识久了总是会遇到很多问题。<!-- more -->随着开发的不断深入，也逐渐遇到了很多问题，并预计还在不断更新中，因为项目还未完成。\n\n## 路由\n* onEnter中的callback(), 当获取判断状态是异步操作时，特别有用。react-router文档中这么写到：\n```\nonEnter(nextState, replaceState, callback?)\n当 route 即将进入时调用。它提供了下一个路由的 state，一个函数重定向到另一个路径。this 会触发钩子去创建 route 实例。\n当 callback 作为函数的第三个参数传入时，这个钩子将是异步执行的，并且跳转会阻塞直到 callback 被调用。\n```\n\n* onEnter往往用来做权限验证，登录验证\n* 需要注意的是，dispatch是异步的，等待获取结果需要在之后的`then()`里使用\n\n## redux中的state和react内部的state\n* 这两者之间没什么关系。各干各的事。\n* redux中的state实际上也就是通过reducer处理之后挂在store树上一个状态。\n* 通过redux的connect()方法可以将这个state值变成组件的props，供组件使用。\n\n## reducer返回的state\n* 一个reducer文件中可能会有多个子reducer，每个一个子reducer中的state参数对应自己那部分的state数据，不是全局state本身。\n* Redux提供了`combineReducers()`来管理各个子reducer \n* 不能修改state, 需要返回一个新的state。这样便于做到“回退/撤销”，追踪全局状态。\n另外在react的components里往往还需要通过`shouldComponentUpdate(nextProps, nextState) `函数来进行性能优化\n* 并且需要有default的处理，即遇到未知actioin时，一定要返回旧的state\n\n## 关于reducer的划分\n依据对state对象的设计。可以理解为数据库中的一张表；关于层级保持多深，还没有很好的实践\n\n## 多个异步的action creator\n* 在进行某些操作的时候，我们可能需要触发好几个action来完成这个操作。同时呢这些action或者有先后依赖顺序，或许需要一起完成才可能拿到最终的值。这时我们就需要用promise来帮助我们。\n* 在redux中我们可以用redux-thunk中间件来构建异步action。（还可以dispatch函数或者Promise, 比如从异步接口取到数据）\n* 对于同步的action我们可以使用`Promise.resolve()`来包装下。\n* 需要记得每一层都要return， 否则最外层被调用之后是undefined的\n\n```\nreturn (dispatch, getStore) => {\n\treturn api.login(data).then(res => {\n\t\tif(res.code == 1){\n\t\t\treturn Promise.resolve( dispatch(loginSuccess(res.data)) )\n\t\t\t\t\t\t\t.then( () => {\n\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\t})\n\t\t}else if(res.code == -1){\n\t\t\treturn Promise.resolve( dispatch(loginError(res.message)) )\n\t\t\t\t\t\t\t.then( () => {\n\t\t\t\t\t\t\t\treturn Promise.resolve(\n\t\t\t\t\t\t\t\t\tdispatch(showDialog('登录失败')).then( () => {\n\t\t\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t\t\t})\t\n\t\t\t\t\t\t\t})\n\t\t}\n\t})\n}\n```\n\n## redux-form\n* 组件更新很多，但是小问题也很多。\n* 建议是，如果表单中的标准控件很多，适合使用。\n* 但如果控件个数不多，但是里面自定义的控件又居多，那么建议还是不用。因为可能需要单独处理自定义控件的状态，反而增加了工作量。\n\n* 设置初始值，`enableReinitialize: true`,`initialValues`是一个对象，它的key值与组件里的\"name\"对应;\n* `SubmissionError`触发后，store树上form的`submitFailed`变成`true`, 且目前找不到重新设置为false的方法\n* reset, 不能自动重置自定义组件的值，可能需要手动重置(一般通过内部state的方法来解决);\n* `sync error + field array`, field 被移除但是values里保存的依然是initvalue，没有改变。原因是渲染field array的值是从store树上拿的，改为initialValues初始化后解决。\n\n## 直接使用了数组的引用, 改变了原数组\n在组件内部使用了一个变量，这个变量指向了store树上的一个状态，在没有使用immutable的前提下，改变这个变量，实际上也把store树上的状态改变了。这种情况是一个双刃剑，有利有弊。使用时要比较明确可能会发生的后果。\n\n## 无状态component\n* 一般的组件有有完整的生命周期。无状态组件，则更像是一个函数返回一段html片段，只有render方法。\n* 它没有实例化的过程，不需要被分配多余的内存，可以提高整体渲染性能。\n* 它只涉及到props，而不涉及到state的操作。\n\n```\nconst HelloComponent = (props) => {\n  return <div>Hello {props.name}</div>\n}\n```\n\n## axios的Content-Type\n* 默认是`'application/json'`。\n* 这种情况下PHP无法直接从 $_POST 对象从上面的请求中获得内容。\n* 解决办法：\n1. 设置axios`Content-Type:application/x-www-form-urlencode`, [querystring](https://github.com/Gozala/querystring)转换要传参数的格式。\n2. php从`php://input`里获得原始输入流, 再`json_decode`成对象。具体见[四种常见的 POST 提交数据方式](https://imququ.com/post/four-ways-to-post-data-in-http.html)\n\n## 参考\n[Redux中文文档](http://cn.redux.js.org/)\n[深入到源码：解读 redux 的设计思路与用法](http://div.io/topic/1309)\n\n\n",
				"html": "<p>初次相遇总是美好的，相识久了总是会遇到很多问题。<a id=\"more\"></a>随着开发的不断深入，也逐渐遇到了很多问题，并预计还在不断更新中，因为项目还未完成。</p>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><ul>\n<li><p>onEnter中的callback(), 当获取判断状态是异步操作时，特别有用。react-router文档中这么写到：</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">on</span>Enter(nextState, replaceState, callback?)</div><div class=\"line\">当 route 即将进入时调用。它提供了下一个路由的 <span class=\"keyword\">state</span>，一个函数重定向到另一个路径。this 会触发钩子去创建 route 实例。</div><div class=\"line\">当 callback 作为函数的第三个参数传入时，这个钩子将是异步执行的，并且跳转会阻塞直到 callback 被调用。</div></pre></td></tr></table></figure>\n</li>\n<li><p>onEnter往往用来做权限验证，登录验证</p>\n</li>\n<li>需要注意的是，dispatch是异步的，等待获取结果需要在之后的<code>then()</code>里使用</li>\n</ul>\n<h2 id=\"redux中的state和react内部的state\"><a href=\"#redux中的state和react内部的state\" class=\"headerlink\" title=\"redux中的state和react内部的state\"></a>redux中的state和react内部的state</h2><ul>\n<li>这两者之间没什么关系。各干各的事。</li>\n<li>redux中的state实际上也就是通过reducer处理之后挂在store树上一个状态。</li>\n<li>通过redux的connect()方法可以将这个state值变成组件的props，供组件使用。</li>\n</ul>\n<h2 id=\"reducer返回的state\"><a href=\"#reducer返回的state\" class=\"headerlink\" title=\"reducer返回的state\"></a>reducer返回的state</h2><ul>\n<li>一个reducer文件中可能会有多个子reducer，每个一个子reducer中的state参数对应自己那部分的state数据，不是全局state本身。</li>\n<li>Redux提供了<code>combineReducers()</code>来管理各个子reducer </li>\n<li>不能修改state, 需要返回一个新的state。这样便于做到“回退/撤销”，追踪全局状态。<br>另外在react的components里往往还需要通过<code>shouldComponentUpdate(nextProps, nextState)</code>函数来进行性能优化</li>\n<li>并且需要有default的处理，即遇到未知actioin时，一定要返回旧的state</li>\n</ul>\n<h2 id=\"关于reducer的划分\"><a href=\"#关于reducer的划分\" class=\"headerlink\" title=\"关于reducer的划分\"></a>关于reducer的划分</h2><p>依据对state对象的设计。可以理解为数据库中的一张表；关于层级保持多深，还没有很好的实践</p>\n<h2 id=\"多个异步的action-creator\"><a href=\"#多个异步的action-creator\" class=\"headerlink\" title=\"多个异步的action creator\"></a>多个异步的action creator</h2><ul>\n<li>在进行某些操作的时候，我们可能需要触发好几个action来完成这个操作。同时呢这些action或者有先后依赖顺序，或许需要一起完成才可能拿到最终的值。这时我们就需要用promise来帮助我们。</li>\n<li>在redux中我们可以用redux-thunk中间件来构建异步action。（还可以dispatch函数或者Promise, 比如从异步接口取到数据）</li>\n<li>对于同步的action我们可以使用<code>Promise.resolve()</code>来包装下。</li>\n<li>需要记得每一层都要return， 否则最外层被调用之后是undefined的</li>\n</ul>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> (dispatch, getStore) =&gt; &#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> api.login(data).<span class=\"keyword\">then</span>(res =&gt; &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(res.code == <span class=\"number\">1</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> Promise.resolve( dispatch(loginSuccess(res.data)) )</div><div class=\"line\">\t\t\t\t\t\t\t.<span class=\"keyword\">then</span>( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">\t\t\t\t\t\t\t&#125;)</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(res.code == <span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> Promise.resolve( dispatch(loginError(res.message)) )</div><div class=\"line\">\t\t\t\t\t\t\t.<span class=\"keyword\">then</span>( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">return</span> Promise.resolve(</div><div class=\"line\">\t\t\t\t\t\t\t\t\tdispatch(showDialog(<span class=\"string\">'登录失败'</span>)).<span class=\"keyword\">then</span>( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">\t\t\t\t\t\t\t\t&#125;)\t</div><div class=\"line\">\t\t\t\t\t\t\t&#125;)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"redux-form\"><a href=\"#redux-form\" class=\"headerlink\" title=\"redux-form\"></a>redux-form</h2><ul>\n<li>组件更新很多，但是小问题也很多。</li>\n<li>建议是，如果表单中的标准控件很多，适合使用。</li>\n<li><p>但如果控件个数不多，但是里面自定义的控件又居多，那么建议还是不用。因为可能需要单独处理自定义控件的状态，反而增加了工作量。</p>\n</li>\n<li><p>设置初始值，<code>enableReinitialize: true</code>,<code>initialValues</code>是一个对象，它的key值与组件里的”name”对应;</p>\n</li>\n<li><code>SubmissionError</code>触发后，store树上form的<code>submitFailed</code>变成<code>true</code>, 且目前找不到重新设置为false的方法</li>\n<li>reset, 不能自动重置自定义组件的值，可能需要手动重置(一般通过内部state的方法来解决);</li>\n<li><code>sync error + field array</code>, field 被移除但是values里保存的依然是initvalue，没有改变。原因是渲染field array的值是从store树上拿的，改为initialValues初始化后解决。</li>\n</ul>\n<h2 id=\"直接使用了数组的引用-改变了原数组\"><a href=\"#直接使用了数组的引用-改变了原数组\" class=\"headerlink\" title=\"直接使用了数组的引用, 改变了原数组\"></a>直接使用了数组的引用, 改变了原数组</h2><p>在组件内部使用了一个变量，这个变量指向了store树上的一个状态，在没有使用immutable的前提下，改变这个变量，实际上也把store树上的状态改变了。这种情况是一个双刃剑，有利有弊。使用时要比较明确可能会发生的后果。</p>\n<h2 id=\"无状态component\"><a href=\"#无状态component\" class=\"headerlink\" title=\"无状态component\"></a>无状态component</h2><ul>\n<li>一般的组件有有完整的生命周期。无状态组件，则更像是一个函数返回一段html片段，只有render方法。</li>\n<li>它没有实例化的过程，不需要被分配多余的内存，可以提高整体渲染性能。</li>\n<li>它只涉及到props，而不涉及到state的操作。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> HelloComponent = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello &#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"axios的Content-Type\"><a href=\"#axios的Content-Type\" class=\"headerlink\" title=\"axios的Content-Type\"></a>axios的Content-Type</h2><ul>\n<li>默认是<code>&#39;application/json&#39;</code>。</li>\n<li>这种情况下PHP无法直接从 $_POST 对象从上面的请求中获得内容。</li>\n<li>解决办法：</li>\n</ul>\n<ol>\n<li>设置axios<code>Content-Type:application/x-www-form-urlencode</code>, <a href=\"https://github.com/Gozala/querystring\" target=\"_blank\" rel=\"external\">querystring</a>转换要传参数的格式。</li>\n<li>php从<code>php://input</code>里获得原始输入流, 再<code>json_decode</code>成对象。具体见<a href=\"https://imququ.com/post/four-ways-to-post-data-in-http.html\" target=\"_blank\" rel=\"external\">四种常见的 POST 提交数据方式</a></li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://cn.redux.js.org/\" target=\"_blank\" rel=\"external\">Redux中文文档</a><br><a href=\"http://div.io/topic/1309\" target=\"_blank\" rel=\"external\">深入到源码：解读 redux 的设计思路与用法</a></p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1473503760000,
				"created_by": 2,
				"updated_at": 1477905663000,
				"updated_by": 2,
				"published_at": 1473503760000,
				"published_by": 2
			},
			{
				"id": "cj914pnzs003me0hyobuv7y0x",
				"title": "我常用的Linux命令(ing)",
				"slug": "linux-cmd",
				"markdown": "\n自己常用Linux命令记录。<!-- more -->其实自己并不特别熟悉Linux的命令，得益于最近做一些项目的部署，常常用到一些Linux命令，这里记录下。\n\n* su aa\n切换身份为aa。常用`sudo su aa`\n\n* scp\nscp是有Security的文件copy，基于ssh登录\n\n* scp /home/daisy/full.tar.gz 自己的名字@要同步的开发机的ip:/home/root\n要把本地的文件/home/daisy/full.tar.gz copy到远程另外一台主机上\n\n* scp 自己的名字@要同步的开发机的ip:/home/root/1.txt ./\n把远程开发机上的1.txt文件copy到当前目录下\n\n* scp -r 自己的名字@要同步的开发机的ip:/home/root/ ./\n把远程开发机上的整个root目录copy到当前目录下\n\n* lsb_release -a\n查看linux版本\n\n* which mysql\nmysql的启动文件是在哪儿\n\n* mysql -h aa.aa.aa.aa  -P bbb -u username -ppwd\n以**bbb**的用户名，**pwd**的密码，登录地址为**aa.aa.aa.aa**，端口号为**bbb**的mysql数据库。注意密码与**-p**之间没有空格。\n\n* top\n进行性能监控的。比如当前cup，内存占用率，哪个进程占用的最多\n\n* chown -R -v jack: file\n改变指定目录以及其子目录下的所有文件的拥有者(jack)和群组(空缺)\n\n* chomd 777 file\n更改文件file，任何人都有读、写、运行三项权限\n\n* 不同身份用户所能操作的文件不同。比如a文件是属于jack的，那么当以mark身份登录时，就不能使用这个文件\n\n* find / -name my.cnf\n所有路径下查找名字是my.cnf的文件\n\n* find . -name .DS_Store | xargs rm -f\n当前路径下查找文件名为.DS_Store的文件，并强制删除它们\n\n* find . -name \"*.txt\"\n当前目录下搜索所有txt文件\n\n* netstat -tunlp|grep 5893\n查看端口号5893占用情况\n\n* jobs \n查看当前后台运行了哪些进程\n\n* ln –s 源文件 目标文件\n创建软链, 类似windows的快捷方式\n\n* mv shop school\n重命名文件夹， shop->school\n\n\n",
				"html": "<p>自己常用Linux命令记录。<a id=\"more\"></a>其实自己并不特别熟悉Linux的命令，得益于最近做一些项目的部署，常常用到一些Linux命令，这里记录下。</p>\n<ul>\n<li><p>su aa<br>切换身份为aa。常用<code>sudo su aa</code></p>\n</li>\n<li><p>scp<br>scp是有Security的文件copy，基于ssh登录</p>\n</li>\n<li><p>scp /home/daisy/full.tar.gz 自己的名字@要同步的开发机的ip:/home/root<br>要把本地的文件/home/daisy/full.tar.gz copy到远程另外一台主机上</p>\n</li>\n<li><p>scp 自己的名字@要同步的开发机的ip:/home/root/1.txt ./<br>把远程开发机上的1.txt文件copy到当前目录下</p>\n</li>\n<li><p>scp -r 自己的名字@要同步的开发机的ip:/home/root/ ./<br>把远程开发机上的整个root目录copy到当前目录下</p>\n</li>\n<li><p>lsb_release -a<br>查看linux版本</p>\n</li>\n<li><p>which mysql<br>mysql的启动文件是在哪儿</p>\n</li>\n<li><p>mysql -h aa.aa.aa.aa  -P bbb -u username -ppwd<br>以<strong>bbb</strong>的用户名，<strong>pwd</strong>的密码，登录地址为<strong>aa.aa.aa.aa</strong>，端口号为<strong>bbb</strong>的mysql数据库。注意密码与<strong>-p</strong>之间没有空格。</p>\n</li>\n<li><p>top<br>进行性能监控的。比如当前cup，内存占用率，哪个进程占用的最多</p>\n</li>\n<li><p>chown -R -v jack: file<br>改变指定目录以及其子目录下的所有文件的拥有者(jack)和群组(空缺)</p>\n</li>\n<li><p>chomd 777 file<br>更改文件file，任何人都有读、写、运行三项权限</p>\n</li>\n<li><p>不同身份用户所能操作的文件不同。比如a文件是属于jack的，那么当以mark身份登录时，就不能使用这个文件</p>\n</li>\n<li><p>find / -name my.cnf<br>所有路径下查找名字是my.cnf的文件</p>\n</li>\n<li><p>find . -name .DS_Store | xargs rm -f<br>当前路径下查找文件名为.DS_Store的文件，并强制删除它们</p>\n</li>\n<li><p>find . -name “*.txt”<br>当前目录下搜索所有txt文件</p>\n</li>\n<li><p>netstat -tunlp|grep 5893<br>查看端口号5893占用情况</p>\n</li>\n<li><p>jobs<br>查看当前后台运行了哪些进程</p>\n</li>\n<li><p>ln –s 源文件 目标文件<br>创建软链, 类似windows的快捷方式</p>\n</li>\n<li><p>mv shop school<br>重命名文件夹， shop-&gt;school</p>\n</li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1473400988000,
				"created_by": 2,
				"updated_at": 1473407050000,
				"updated_by": 2,
				"published_at": 1473400988000,
				"published_by": 2
			},
			{
				"id": "cj914po0a0049e0hy6dou6r1y",
				"title": "React系列之-开始使用React+Redux",
				"slug": "react",
				"markdown": "\nReact是一个让人使用后就想忘却jQuery的工具。<!-- more -->得益于最近一个新项目的开发，可以实践一下ReactJs。这里暂且先只讨论开始搭建一个应用的框架，不去过多介绍React背景，也不去对比React与其他框架，因为这样的文章随便一找就有很多写的很好的文章，关于开发过程中踩到的坑会另开一篇总结。\n\n## 框架选取与资源推荐\n* ReactJs: V15+\n* 状态管理: redux, react-redux\n* Redux中间件: redux-thunk(让action支持异步)\n* 路由管理: react-router, react-router-redux\n* html类名: classnames\n* HTTP客户端: axios\n* webpack: 静态资源管理\n* webpack-loader: babel, postcss, jsx\n* 其他库: react-bootstrap, antd, redux-form\n* Debug: [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi), [Redux DevTools](https://github.com/zalmoxisus/redux-devtools-extension)\n\n## Redux简单介绍\n数据驱动是与之前基于jQuery的过程化开发最大的不同。而Redux是目前为止公认的对Flux思想(单向数据流管理)比较好的实现。对它理解的如何，可以说在一定程度上决定了开发的难易程度。\n它是独立的，起源于React，但不止于支持React、Angular、Ember...,甚至是jQuery。但是显然更适用于状态驱动的框架。其基本架构如下图: \n<img src=\"/img/react-intro/redux.png\" alt=\"\" width=\"500px\">\n\n其核心可以理解为由3部分组成，aciton，reducer，store\n* action：用来描述需要进行一个怎样的行为。\n比如添加电影A和添加电影B，但这是两个不同的action。我们可以使用action creator叫做添加电影来创造之前的两个actioin。\n\n* reducer：每一个行为具体需要做什么才能改变state。\n可以理解为是数据库中的每一张表。最后通过Redux提供的combinReducers({})来组合所有的reducer并挂在到store树上。\n一个action可以对应多个不同的reducer，一个reducer也可以处理不同action。是多对多的关系。\n接收旧的state，并返回一个新的state。需要注意，不能返回之前state的引用。会用到Object.assign({}, state), [...state]。\n\n* store: 是一个对象，维护一个全局的，唯一的state。并且提供dispatch, subscribe, getState的方法。\n\n**Redux与React的结合：redux-react**\nRedux通过Redux组件的Provider为整个react注入store。这个Provider组件也是继承了React.Component.\n\n```\n<Provider store={store}>\n\t\t<Router history={history}>\n      {routes}\n    </Router>\n</Provider>\n```\n\nConnect方法为React组件提供stroe中的state和dispatch方法。简单来说，connect()可以把普通的react组件包装成Redux组件。\n```\nconst mapStateToProps = (state) => {\n  return {\n    services: getVisibleServices(state.services),\n    panelList: state.panelList\n  }\n}\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    actions: bindActionCreators(Object.assign({}, ServerActions, ServiceActions), dispatch)\n  }\n}\n\nServiceList.propTypes = {\n  services: PropTypes.array.isRequired,\n  actions: PropTypes.object.isRequired\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ServiceList)\n```\n\n* bindActionCreators: 对 store.dispatch(actionCreator(…args))的再次封装。直接写actions.xxx即可。\n\n参考：[React 数据流管理架构之 Redux 介绍](https://github.com/joeyguo/blog/issues/3)\n\n## 目录结构\n因为react推崇的是组件化开发，因此代码组织上也是按照组件，将每个组件相关的资源放在一起管理起来更方便(之前自己还是按照传统多页开发的结构搭建，后来证明很不方便)\n(这图截出来真是虚。。。)\n<img src=\"/img/react-intro/floder.png\" alt=\"\" >\n\n## React+Redux适用的场景\n可以从上面的目录图中看出，整个目录结构还是挺复杂的。所以在使用这套搭配之前，我们需要提前评估我们的应用这样去构建是否是性价比合理的。一般来说，这样的搭配适用于这样的场景：\n<img src=\"/img/react-intro/react-sence.png\" alt=\"\"  width=\"350px\">\n\n否则，就有些得不偿失，反而增加了开发成本。\n\n## 使用之后\n* 在整个应用中，我们只需要关注数据状态的变化，使得我们开发时更加专注。什么样的界面对应什么样的状态，什么样的操作会引起什么样状态的变化，从而呈现什么样的界面。我们不再需要像jQuery那样去关注，都是哪些DOM的操作会影响本DOM的变化。\n<img src=\"/img/react-intro/jquery.png\" alt=\"\"  width=\"500px\">\n\n* 整个html几乎全部由js生成（在不使用服务端渲染的前提下）。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n</head>\n<body>\n\t<div id=\"app\"></div>\n\t<script src=\"/build/index.js\"></script>\n</body>\n</html>\n```\n\n* 服务端渲染只适用于由NodeJs做开发语言的框架，像PHP, JAVA这类的是无法提供服务端渲染的。\n\n* 在后端不提供渲染模板的情况下，基本上只是把后端当做是异步接口的提供方。\n\n* 当redux+react更新state时，与这个state相关的组件都会被重新渲染。所以如果不需要，做shouldComponetUpdate()判断很重要。\n\n* 最后附上之前分享时的[PPT](http://jiaolonghuang.github.io/img/react-intro/reactjs.pdf)\n",
				"html": "<p>React是一个让人使用后就想忘却jQuery的工具。<a id=\"more\"></a>得益于最近一个新项目的开发，可以实践一下ReactJs。这里暂且先只讨论开始搭建一个应用的框架，不去过多介绍React背景，也不去对比React与其他框架，因为这样的文章随便一找就有很多写的很好的文章，关于开发过程中踩到的坑会另开一篇总结。</p>\n<h2 id=\"框架选取与资源推荐\"><a href=\"#框架选取与资源推荐\" class=\"headerlink\" title=\"框架选取与资源推荐\"></a>框架选取与资源推荐</h2><ul>\n<li>ReactJs: V15+</li>\n<li>状态管理: redux, react-redux</li>\n<li>Redux中间件: redux-thunk(让action支持异步)</li>\n<li>路由管理: react-router, react-router-redux</li>\n<li>html类名: classnames</li>\n<li>HTTP客户端: axios</li>\n<li>webpack: 静态资源管理</li>\n<li>webpack-loader: babel, postcss, jsx</li>\n<li>其他库: react-bootstrap, antd, redux-form</li>\n<li>Debug: <a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\" target=\"_blank\" rel=\"external\">React Developer Tools</a>, <a href=\"https://github.com/zalmoxisus/redux-devtools-extension\" target=\"_blank\" rel=\"external\">Redux DevTools</a></li>\n</ul>\n<h2 id=\"Redux简单介绍\"><a href=\"#Redux简单介绍\" class=\"headerlink\" title=\"Redux简单介绍\"></a>Redux简单介绍</h2><p>数据驱动是与之前基于jQuery的过程化开发最大的不同。而Redux是目前为止公认的对Flux思想(单向数据流管理)比较好的实现。对它理解的如何，可以说在一定程度上决定了开发的难易程度。<br>它是独立的，起源于React，但不止于支持React、Angular、Ember…,甚至是jQuery。但是显然更适用于状态驱动的框架。其基本架构如下图:<br><img src=\"/img/react-intro/redux.png\" alt=\"\" width=\"500px\"></p>\n<p>其核心可以理解为由3部分组成，aciton，reducer，store</p>\n<ul>\n<li><p>action：用来描述需要进行一个怎样的行为。<br>比如添加电影A和添加电影B，但这是两个不同的action。我们可以使用action creator叫做添加电影来创造之前的两个actioin。</p>\n</li>\n<li><p>reducer：每一个行为具体需要做什么才能改变state。<br>可以理解为是数据库中的每一张表。最后通过Redux提供的combinReducers({})来组合所有的reducer并挂在到store树上。<br>一个action可以对应多个不同的reducer，一个reducer也可以处理不同action。是多对多的关系。<br>接收旧的state，并返回一个新的state。需要注意，不能返回之前state的引用。会用到Object.assign({}, state), […state]。</p>\n</li>\n<li><p>store: 是一个对象，维护一个全局的，唯一的state。并且提供dispatch, subscribe, getState的方法。</p>\n</li>\n</ul>\n<p><strong>Redux与React的结合：redux-react</strong><br>Redux通过Redux组件的Provider为整个react注入store。这个Provider组件也是继承了React.Component.</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Provider</span> <span class=\"attr\">store</span>=</span></span><span class=\"template-variable\">&#123;store&#125;</span><span class=\"xml\"><span class=\"tag\">&gt;</span></span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">history</span>=</span><span class=\"template-variable\">&#123;history&#125;</span><span class=\"xml\"><span class=\"tag\">&gt;</span></span></div><div class=\"line\">      <span class=\"template-variable\">&#123;routes&#125;</span><span class=\"xml\"></span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Provider</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Connect方法为React组件提供stroe中的state和dispatch方法。简单来说，connect()可以把普通的react组件包装成Redux组件。<br><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">const mapStateToProps = (<span class=\"keyword\">state</span>) =&gt; &#123;</div><div class=\"line\">  return &#123;</div><div class=\"line\">    services: getVisibleServices(<span class=\"keyword\">state</span>.services),</div><div class=\"line\">    panelList: <span class=\"keyword\">state</span>.panelList</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const mapDispatchToProps = (dispatch) =&gt; &#123;</div><div class=\"line\">  return &#123;</div><div class=\"line\">    actions: bindActionCreators(Object.assign(&#123;&#125;, ServerActions, ServiceActions), dispatch)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">ServiceList.propTypes = &#123;</div><div class=\"line\">  services: PropTypes.array.isRequired,</div><div class=\"line\">  actions: PropTypes.object.isRequired</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">export <span class=\"keyword\">default</span> connect(</div><div class=\"line\">  mapStateToProps,</div><div class=\"line\">  mapDispatchToProps</div><div class=\"line\">)(ServiceList)</div></pre></td></tr></table></figure></p>\n<ul>\n<li>bindActionCreators: 对 store.dispatch(actionCreator(…args))的再次封装。直接写actions.xxx即可。</li>\n</ul>\n<p>参考：<a href=\"https://github.com/joeyguo/blog/issues/3\" target=\"_blank\" rel=\"external\">React 数据流管理架构之 Redux 介绍</a></p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>因为react推崇的是组件化开发，因此代码组织上也是按照组件，将每个组件相关的资源放在一起管理起来更方便(之前自己还是按照传统多页开发的结构搭建，后来证明很不方便)<br>(这图截出来真是虚。。。)<br><img src=\"/img/react-intro/floder.png\" alt=\"\"></p>\n<h2 id=\"React-Redux适用的场景\"><a href=\"#React-Redux适用的场景\" class=\"headerlink\" title=\"React+Redux适用的场景\"></a>React+Redux适用的场景</h2><p>可以从上面的目录图中看出，整个目录结构还是挺复杂的。所以在使用这套搭配之前，我们需要提前评估我们的应用这样去构建是否是性价比合理的。一般来说，这样的搭配适用于这样的场景：<br><img src=\"/img/react-intro/react-sence.png\" alt=\"\" width=\"350px\"></p>\n<p>否则，就有些得不偿失，反而增加了开发成本。</p>\n<h2 id=\"使用之后\"><a href=\"#使用之后\" class=\"headerlink\" title=\"使用之后\"></a>使用之后</h2><ul>\n<li><p>在整个应用中，我们只需要关注数据状态的变化，使得我们开发时更加专注。什么样的界面对应什么样的状态，什么样的操作会引起什么样状态的变化，从而呈现什么样的界面。我们不再需要像jQuery那样去关注，都是哪些DOM的操作会影响本DOM的变化。<br><img src=\"/img/react-intro/jquery.png\" alt=\"\" width=\"500px\"></p>\n</li>\n<li><p>整个html几乎全部由js生成（在不使用服务端渲染的前提下）。</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/build/index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>服务端渲染只适用于由NodeJs做开发语言的框架，像PHP, JAVA这类的是无法提供服务端渲染的。</p>\n</li>\n<li><p>在后端不提供渲染模板的情况下，基本上只是把后端当做是异步接口的提供方。</p>\n</li>\n<li><p>当redux+react更新state时，与这个state相关的组件都会被重新渲染。所以如果不需要，做shouldComponetUpdate()判断很重要。</p>\n</li>\n<li><p>最后附上之前分享时的<a href=\"http://jiaolonghuang.github.io/img/react-intro/reactjs.pdf\">PPT</a></p>\n</li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1473400988000,
				"created_by": 2,
				"updated_at": 1473416721000,
				"updated_by": 2,
				"published_at": 1473400988000,
				"published_by": 2
			},
			{
				"id": "cj914pnzr003je0hyem0i8q89",
				"title": "item2启动慢的解决",
				"slug": "item2",
				"markdown": "\nitem2启动慢了，多半是oh-my-zsh的问题。<!-- more -->\n\n* oh-my-zsh加载的插件太多\n终端输入`vi ~/.zshrc`\nplugins=(git autojump zsh-syntax-highlighting)\n\n* 缓存\n`sudo rm /private/var/log/asl/*.asl`\n第二种的可能性比较大,我这次就是这样解决的",
				"html": "<p>item2启动慢了，多半是oh-my-zsh的问题。<a id=\"more\"></a></p>\n<ul>\n<li><p>oh-my-zsh加载的插件太多<br>终端输入<code>vi ~/.zshrc</code><br>plugins=(git autojump zsh-syntax-highlighting)</p>\n</li>\n<li><p>缓存<br><code>sudo rm /private/var/log/asl/*.asl</code><br>第二种的可能性比较大,我这次就是这样解决的</p>\n</li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1461226329000,
				"created_by": 2,
				"updated_at": 1461226656000,
				"updated_by": 2,
				"published_at": 1461226329000,
				"published_by": 2
			},
			{
				"id": "cj914po00003te0hyfzabvnhx",
				"title": "charles调试指南一二",
				"slug": "mac-charles",
				"markdown": "\n在windows下可以使用fiddler作为调试代理工具，那么在mac下可以用什么呢？这里推荐使用[Charles](http://www.charlesproxy.com/)。<!-- more -->Charles可以理解为mac上的'fiddler'。下面就介绍一下如何使用这样类似的代理工具，下面是以charles为例，可能设置的位置不同，但是需要的步骤都是相似的，可类比。\n\n一般使用调试代理工具，是调试一些js文件，抓包，查看http请求与返回相关的信息。\n\n## 准备工作\n* 首先保证需要调试的设备(电脑或是手机)与Charles处于**同一网段**中，比如都连上了noway的无线网。\n\t* mac支持多网卡同时工作，插网线和无线网都可以同时连接。\n* 设置Charles的代理端口号，默认是8888(fiddler也一样)\n\t<img src=\"/img/charles/proxy_setting.png\" alt=\"\" >\n\t<img src=\"/img/charles/port.png\" alt=\"\" >\n\n## pc端如何使用\n* 在**charles**开启mac proxy\n<img src=\"/img/charles/macos_proxy.png\" alt=\"\">\n\n* **需要抓包的软件**关闭其他代理\n比如浏览器，看看是不是用了其他代理，需要选择系统代理。否则会抓不到用浏览器浏览时的包。\n\n* **浏览器清缓存**\n假设上面几个步骤都成功了，但是依然看不到加载的资源，需要看看是不是浏览器还是从**浏览器缓存**中读取的这些资源。\n\t* 如果是，那么就在charles获取到的请求资源中看不到文件信息。\n\t* 那么需要强制刷新，或是清除浏览器缓存后再刷新页面。这时就可以看到加载的资源了。\n\t* mac下`command+r`,是刷新网页。`command+shift+r`是强制刷新（但往往起不了效果）。可以使用chrome的插件**click&clean**来清除缓存。\n<img src=\"/img/charles/network_304.png\" alt=\"\" >\n<img src=\"/img/charles/network_200.png\" alt=\"\" >\n<img src=\"/img/charles/charles_package.png\" alt=\"\" >\n\n## 移动端如何调试\n* 手机设置代理\n\t* 设置电脑上的网络，保证第一个是以太网的\n\t* 连上与mac同一个无线网后，设置mac中wifi的ip(和以太网的ip不一样)，和端口号8888\n\t<img src=\"/img/charles/network.png\" alt=\"\" >\n* 这时如果前面的步骤都没问题，就会在charles界面上出现一个弹出框，选择**allow**即可。\n<img src=\"/img/charles/allow.png\" alt=\"\" >\n* 这样我们就可以像调试pc页面一样，对移动端页面进行脚本调试了。\n* 另外呢，连上这样的代理之后，手机相当于是电脑的另一个屏幕了。就是说，只要电脑能访问的页面，在手机上也都可以访问了。可以通过chrome的二维码插件，直接扫码访问，或者通过任意方式，能让手机获取到需要访问的地址即可。\n\n## 虚拟机中如何使用\n在虚拟机开启代理工具后，比如fiddler，在本机上的浏览器的代理地址设置成虚拟机中的代理地址即可。这样在虚拟机里就可以抓本机上的包了。其实就是相当于两台电脑之间的代理设置。\n\n## 替换文件\n**适用与pc和移动**\n\n有时我们需要对页面中的脚本进行调试，如果页面是线上的，或者由于环境的限制，不能直接修改已有的脚本看到效果，该怎么办？\n\n那么使用**map**大法好，map分为**map remote**和**map local**两种。都是替换已抓到的文件，不同的是前者是用线上地址的文件替换，后者使用本地文件替换。本地文件替换也是我们debug时最常用的。\n<img src=\"/img/charles/charles_map.png\" alt=\"\" height=\"400\">\n* 右键需要替换的文件后出现如下对话框\n<img src=\"/img/charles/map_local.png\" alt=\"\" >\n\n* 如果调试完了，不需要本地文件替换了，那么可以通过下面的设置remove掉设置(map remote也类似)。把前面的钩钩去掉，再点ok就ok了。\n<img src=\"/img/charles/map_remove.png\" alt=\"\" >\n\n## 安装破解charles\n(并不鼓励[doge脸])\n* [安装包](https://yunpan.cn/cqwqiHXcf2uKD) （提取码：ecf8）\n* 破解：用破解包里面的\"Mac/charles.jar\" 替换 Charles 安装文件里面的 \"Contents/Java/charles.jar\" 文件\n\n## 移动端页面的UI怎么调\n用**Chrome devTools**调试Android手机**各种app中的web页面**\n* 手机要满足Android系统为4.4或更高版本，低版本不支持这种方式。(也不是所有的手机都支持，比如有的华为就不支持)\n* 确保App已经开启了webview的debug调试模式。\n* 用usb数据线连接好手机与电脑。\n* 将手机中的 设置 - 开发人员工具 - USB调试功能打开。\n* 打开chrome://inspect/#devices，即单击chrome右上角控制按钮 - 更多工具 - 检查设备 - 勾选上Discover USB devices\n* 在app中访问一个web页面,对应的webview就可以出现在devices中，单击inspect即可调试。\n\n用**safari**调试iPhone中**safari里的web页面**\n\n由于iPhone安全性的限制，我们只能通过safari调试iPhone在safari中的页面，调试不了别的地方的webview。\n* 手机中，**设置 > Safari > 高级**开启**web检查器**\n* 用usb数据线连接好手机与电脑\n* 在手机的safari中打开一个网页\n* 在电脑的safari，点击 开发 - 自己iphone的名称 - 手机上打开页面的url\n\n## 参考\n* [charles使用教程指南](http://drops.wooyun.org/tips/2423)\n* [iOS开发工具——网络封包分析工具Charles](http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles/)\n",
				"html": "<p>在windows下可以使用fiddler作为调试代理工具，那么在mac下可以用什么呢？这里推荐使用<a href=\"http://www.charlesproxy.com/\" target=\"_blank\" rel=\"external\">Charles</a>。<a id=\"more\"></a>Charles可以理解为mac上的’fiddler’。下面就介绍一下如何使用这样类似的代理工具，下面是以charles为例，可能设置的位置不同，但是需要的步骤都是相似的，可类比。</p>\n<p>一般使用调试代理工具，是调试一些js文件，抓包，查看http请求与返回相关的信息。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li>首先保证需要调试的设备(电脑或是手机)与Charles处于<strong>同一网段</strong>中，比如都连上了noway的无线网。<ul>\n<li>mac支持多网卡同时工作，插网线和无线网都可以同时连接。</li>\n</ul>\n</li>\n<li>设置Charles的代理端口号，默认是8888(fiddler也一样)<br>  <img src=\"/img/charles/proxy_setting.png\" alt=\"\"><br>  <img src=\"/img/charles/port.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"pc端如何使用\"><a href=\"#pc端如何使用\" class=\"headerlink\" title=\"pc端如何使用\"></a>pc端如何使用</h2><ul>\n<li><p>在<strong>charles</strong>开启mac proxy<br><img src=\"/img/charles/macos_proxy.png\" alt=\"\"></p>\n</li>\n<li><p><strong>需要抓包的软件</strong>关闭其他代理<br>比如浏览器，看看是不是用了其他代理，需要选择系统代理。否则会抓不到用浏览器浏览时的包。</p>\n</li>\n<li><p><strong>浏览器清缓存</strong><br>假设上面几个步骤都成功了，但是依然看不到加载的资源，需要看看是不是浏览器还是从<strong>浏览器缓存</strong>中读取的这些资源。</p>\n<ul>\n<li>如果是，那么就在charles获取到的请求资源中看不到文件信息。</li>\n<li>那么需要强制刷新，或是清除浏览器缓存后再刷新页面。这时就可以看到加载的资源了。</li>\n<li>mac下<code>command+r</code>,是刷新网页。<code>command+shift+r</code>是强制刷新（但往往起不了效果）。可以使用chrome的插件<strong>click&amp;clean</strong>来清除缓存。<br><img src=\"/img/charles/network_304.png\" alt=\"\"><br><img src=\"/img/charles/network_200.png\" alt=\"\"><br><img src=\"/img/charles/charles_package.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"移动端如何调试\"><a href=\"#移动端如何调试\" class=\"headerlink\" title=\"移动端如何调试\"></a>移动端如何调试</h2><ul>\n<li>手机设置代理<ul>\n<li>设置电脑上的网络，保证第一个是以太网的</li>\n<li>连上与mac同一个无线网后，设置mac中wifi的ip(和以太网的ip不一样)，和端口号8888<br><img src=\"/img/charles/network.png\" alt=\"\"></li>\n</ul>\n</li>\n<li>这时如果前面的步骤都没问题，就会在charles界面上出现一个弹出框，选择<strong>allow</strong>即可。<br><img src=\"/img/charles/allow.png\" alt=\"\"></li>\n<li>这样我们就可以像调试pc页面一样，对移动端页面进行脚本调试了。</li>\n<li>另外呢，连上这样的代理之后，手机相当于是电脑的另一个屏幕了。就是说，只要电脑能访问的页面，在手机上也都可以访问了。可以通过chrome的二维码插件，直接扫码访问，或者通过任意方式，能让手机获取到需要访问的地址即可。</li>\n</ul>\n<h2 id=\"虚拟机中如何使用\"><a href=\"#虚拟机中如何使用\" class=\"headerlink\" title=\"虚拟机中如何使用\"></a>虚拟机中如何使用</h2><p>在虚拟机开启代理工具后，比如fiddler，在本机上的浏览器的代理地址设置成虚拟机中的代理地址即可。这样在虚拟机里就可以抓本机上的包了。其实就是相当于两台电脑之间的代理设置。</p>\n<h2 id=\"替换文件\"><a href=\"#替换文件\" class=\"headerlink\" title=\"替换文件\"></a>替换文件</h2><p><strong>适用与pc和移动</strong></p>\n<p>有时我们需要对页面中的脚本进行调试，如果页面是线上的，或者由于环境的限制，不能直接修改已有的脚本看到效果，该怎么办？</p>\n<p>那么使用<strong>map</strong>大法好，map分为<strong>map remote</strong>和<strong>map local</strong>两种。都是替换已抓到的文件，不同的是前者是用线上地址的文件替换，后者使用本地文件替换。本地文件替换也是我们debug时最常用的。<br><img src=\"/img/charles/charles_map.png\" alt=\"\" height=\"400\"></p>\n<ul>\n<li><p>右键需要替换的文件后出现如下对话框<br><img src=\"/img/charles/map_local.png\" alt=\"\"></p>\n</li>\n<li><p>如果调试完了，不需要本地文件替换了，那么可以通过下面的设置remove掉设置(map remote也类似)。把前面的钩钩去掉，再点ok就ok了。<br><img src=\"/img/charles/map_remove.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"安装破解charles\"><a href=\"#安装破解charles\" class=\"headerlink\" title=\"安装破解charles\"></a>安装破解charles</h2><p>(并不鼓励[doge脸])</p>\n<ul>\n<li><a href=\"https://yunpan.cn/cqwqiHXcf2uKD\" target=\"_blank\" rel=\"external\">安装包</a> （提取码：ecf8）</li>\n<li>破解：用破解包里面的”Mac/charles.jar” 替换 Charles 安装文件里面的 “Contents/Java/charles.jar” 文件</li>\n</ul>\n<h2 id=\"移动端页面的UI怎么调\"><a href=\"#移动端页面的UI怎么调\" class=\"headerlink\" title=\"移动端页面的UI怎么调\"></a>移动端页面的UI怎么调</h2><p>用<strong>Chrome devTools</strong>调试Android手机<strong>各种app中的web页面</strong></p>\n<ul>\n<li>手机要满足Android系统为4.4或更高版本，低版本不支持这种方式。(也不是所有的手机都支持，比如有的华为就不支持)</li>\n<li>确保App已经开启了webview的debug调试模式。</li>\n<li>用usb数据线连接好手机与电脑。</li>\n<li>将手机中的 设置 - 开发人员工具 - USB调试功能打开。</li>\n<li>打开chrome://inspect/#devices，即单击chrome右上角控制按钮 - 更多工具 - 检查设备 - 勾选上Discover USB devices</li>\n<li>在app中访问一个web页面,对应的webview就可以出现在devices中，单击inspect即可调试。</li>\n</ul>\n<p>用<strong>safari</strong>调试iPhone中<strong>safari里的web页面</strong></p>\n<p>由于iPhone安全性的限制，我们只能通过safari调试iPhone在safari中的页面，调试不了别的地方的webview。</p>\n<ul>\n<li>手机中，<strong>设置 &gt; Safari &gt; 高级</strong>开启<strong>web检查器</strong></li>\n<li>用usb数据线连接好手机与电脑</li>\n<li>在手机的safari中打开一个网页</li>\n<li>在电脑的safari，点击 开发 - 自己iphone的名称 - 手机上打开页面的url</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://drops.wooyun.org/tips/2423\" target=\"_blank\" rel=\"external\">charles使用教程指南</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles/\" target=\"_blank\" rel=\"external\">iOS开发工具——网络封包分析工具Charles</a></li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1461038329000,
				"created_by": 2,
				"updated_at": 1461226303000,
				"updated_by": 2,
				"published_at": 1461038329000,
				"published_by": 2
			},
			{
				"id": "cj914pnzy003qe0hymzy6ypx4",
				"title": "我遇到过的那些自动化脚本",
				"slug": "linux-js",
				"markdown": "\n在实际项目中，我们不可避免的需要用到自动化脚本来帮助我们完成一些事情，比如自动发送邮件，当系统宕机之后自动重启等等。<!-- more -->下面我将结合一个实际项目分析介绍，总共在哪些场景中使用了自动化脚本并且是如何做的。\n\n## 前言\n在这个项目中，我们除了完成构建系统的基本代码之外，还需要完成下面一些任务：\n1. 定时进行数据处理并入库\n2. 定时使用casperjs截图，并发送邮件\n3. 监控是否有新代码提交，更新代码，并重启系统\n4. 为了保证顺利截图，还需要创建守护进程\n\n## crontab命令\n* 分析上面的一些任务，我们发现基本都有**定时**两个字，那么在linux中这个具体是怎么实现的呢。就是使用crontab命令来完成定时任务。(这里暂且先不做关于crontab具体介绍和使用的过多介绍,仅介绍在实际中是如何操作的)\n* `crontab -e`编辑crontab列表；`crontab -l`查看crontab列表。\n* 它执行任务的最小间隔是1min，利用这个特性，我们可以用来创建守护进程。即，如果发现某个进程不存在，即立即重新运行。\n* 需要注意的是，crontab命令在执行时，往往并不知道这个命令是在什么样的环境下执行的。所以，对于执行命令，我们往往都写成命令的绝对路径，比如`/usr/local/bin/node`\n* 我们还可以在指定路径下，执行命令。比如:\n```\n* * * * * (cd /sotraffic-web/webpack; sh ./../crontabscript/daemon.sh >> ./../log/daemon.log)\n```\n* 任意一个在命令行执行的命令都可以被创建成crontab定时任务。\n\n## 选取脚本语言\n* node\n\t这里隆重介绍下node中的`child_process = require('child_process')`模块，利用child_process中的**exec**方法，我们可以执行命令行中可执行的任意命令，比如：`cd path && ls` 或者`git pull`，`pm2 restart`等等\n\n* shell, python\n关于shell语法的介绍，可以参考[这个系列](http://hackerxu.com/2014/09/05/shell.html)。\n\n* 针对前言提到的4个任务，我们都分别采用了什么脚本语言呢？\n1. 定时进行数据处理并入库 （node）\n3. 监控是否有新代码提交，更新代码，并重启系统 （node）\n\n2. 定时使用casperjs截图，并发送邮件 (casperjs, python, shell)\n实际上这一步骤，是两个任务的结合，先用casperjs完成截图，并且截图完成后，再执行使用python编写的发送邮件脚本(实际上node也可以)。而结合的这一任务是用shell来写的。\n在这一步骤中还遇到一个问题，就是由于未知原因，截图不能一次性成功。检测截图是否成功，如果不成功则继续执行命令，直到成功为止。\n```\n#!/bin/bash\necho \"====Starting capturing and sending Email====\"\necho `date +%Y-%m-%d%t%H:%M:%S`\n\nsource /etc/bashrc\n\nTIME=`date +%Y-%m-%d`\nmyFilePc=\"/www/static/img/$TIME/report_pc.png\"\nmyFileMobile=\"/www/static/img/$TIME/report_mobile.png\"\n\nif [ -f $myFilePc ]\nthen\n\trm -f \"$myFilePc\"\n\techo \"rm $myFilePc is done!\"\nelse\n\techo \"cannot find $myFilePc\"\nfi\n\nif [ -f $myFileMobile ]\nthen\n\trm -f \"$myFileMobile\"\n\techo \"rm $myFileMobile is done!\"\nelse\n\techo \"cannot find $myFileMobile\"\nfi\n\n#需要检测哪个图没有截取成功，再次执行命令，所以把capture_pc和capture_mobile分成两个文件写，这样成本最低\nwhile [ ! -f $myFilePc ]\ndo\n\t/usr/local/bin/casperjs /crontabscript/capture_pc.js\ndone\n\nwhile [ ! -f $myFileMobile ]\ndo\n\t/usr/local/bin/casperjs /crontabscript/capture_mobile.js\ndone\n\n/usr/local/Python-2.7.11/python /crontabscript/Email.py\n\necho \"\"\n```\n\n4. 为了保证顺利截图，还需要创建守护进程 (shell)\n创建守护进行的思路是，每隔1分钟检查一次查找所需进程是否在进程列表中，如果没有，则启动进程\n```\n#!/bin/bash\nCONDITION='能识别进程的关键字'\nCMD='需要执行的命令'\n\nPROCESS_INFO=`ps aux|grep $CONDITION|grep -v 'grep'`\n#echo $PROCESS_INFO\nPID=`echo \"$PROCESS_INFO\"|awk '{print $2}'`\n#echo $PID\n\nif [ \"$PID\" == \"\" ]\nthen\n\tTIME=`date`\n\techo \"=============$TIME===============\"\n    echo 'No runnning process found! Try starting new process...'\n    `$CMD`\n    echo 'Restart done!'\nfi\n```\n\n## 记录日志\n因为这些脚本会定时自动执行，在执行过程中可能会失败，我们需要一些信息来帮助我们定位问题。所以一定要在脚本中输出一些有价值的信息，并记录日志。\n\n## 遇到过的问题\n* python在发送邮件时，使用域名致使邮件不能成功发送，暂时使用IP。**（原因待查）**\n* crontab执行截图时，报出phantomjs未安装，以及python未找到的错误。\n\t原因：crontab未找到正确的环境变量\n\t解决: 在脚本中执行截图操作前，先`source /etc/bashrc`\n* 重启webpack的命令需要在指定的路径下才能执行\n\t<img src=\"/img/webpack-error.png\" alt=\"\" >\n\t解决：（1）先cd到指定路径，再执行命令。（2）或者命令中指定webpack.config.js\n\t```\n\t/usr/local/bin/node /webpack/node_modules/.bin/webpack-dev-server /webpack/webpack.config.js --inline --hot --quiet --host 0.0.0.0 --port 8366 \n\t```\n## 感想\n自我感想，无论是使用shell、python、node，或者php都是可以完成任务的，没有规定什么样的语言只能完成什么样的任务。个人更建议选择一种自己熟悉的语言，来完成所有操作，这样可以降低学习成本。\n\n\n",
				"html": "<p>在实际项目中，我们不可避免的需要用到自动化脚本来帮助我们完成一些事情，比如自动发送邮件，当系统宕机之后自动重启等等。<a id=\"more\"></a>下面我将结合一个实际项目分析介绍，总共在哪些场景中使用了自动化脚本并且是如何做的。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在这个项目中，我们除了完成构建系统的基本代码之外，还需要完成下面一些任务：</p>\n<ol>\n<li>定时进行数据处理并入库</li>\n<li>定时使用casperjs截图，并发送邮件</li>\n<li>监控是否有新代码提交，更新代码，并重启系统</li>\n<li>为了保证顺利截图，还需要创建守护进程</li>\n</ol>\n<h2 id=\"crontab命令\"><a href=\"#crontab命令\" class=\"headerlink\" title=\"crontab命令\"></a>crontab命令</h2><ul>\n<li>分析上面的一些任务，我们发现基本都有<strong>定时</strong>两个字，那么在linux中这个具体是怎么实现的呢。就是使用crontab命令来完成定时任务。(这里暂且先不做关于crontab具体介绍和使用的过多介绍,仅介绍在实际中是如何操作的)</li>\n<li><code>crontab -e</code>编辑crontab列表；<code>crontab -l</code>查看crontab列表。</li>\n<li>它执行任务的最小间隔是1min，利用这个特性，我们可以用来创建守护进程。即，如果发现某个进程不存在，即立即重新运行。</li>\n<li>需要注意的是，crontab命令在执行时，往往并不知道这个命令是在什么样的环境下执行的。所以，对于执行命令，我们往往都写成命令的绝对路径，比如<code>/usr/local/bin/node</code></li>\n<li><p>我们还可以在指定路径下，执行命令。比如:</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* * * * * (cd <span class=\"regexp\">/sotraffic-web/</span>webpack; sh .<span class=\"regexp\">/../</span>crontabscript<span class=\"regexp\">/daemon.sh &gt;&gt; ./</span>..<span class=\"regexp\">/log/</span>daemon.log)</div></pre></td></tr></table></figure>\n</li>\n<li><p>任意一个在命令行执行的命令都可以被创建成crontab定时任务。</p>\n</li>\n</ul>\n<h2 id=\"选取脚本语言\"><a href=\"#选取脚本语言\" class=\"headerlink\" title=\"选取脚本语言\"></a>选取脚本语言</h2><ul>\n<li><p>node<br>  这里隆重介绍下node中的<code>child_process = require(&#39;child_process&#39;)</code>模块，利用child_process中的<strong>exec</strong>方法，我们可以执行命令行中可执行的任意命令，比如：<code>cd path &amp;&amp; ls</code> 或者<code>git pull</code>，<code>pm2 restart</code>等等</p>\n</li>\n<li><p>shell, python<br>关于shell语法的介绍，可以参考<a href=\"http://hackerxu.com/2014/09/05/shell.html\" target=\"_blank\" rel=\"external\">这个系列</a>。</p>\n</li>\n<li><p>针对前言提到的4个任务，我们都分别采用了什么脚本语言呢？</p>\n</li>\n</ul>\n<ol>\n<li>定时进行数据处理并入库 （node）</li>\n<li><p>监控是否有新代码提交，更新代码，并重启系统 （node）</p>\n</li>\n<li><p>定时使用casperjs截图，并发送邮件 (casperjs, python, shell)<br>实际上这一步骤，是两个任务的结合，先用casperjs完成截图，并且截图完成后，再执行使用python编写的发送邮件脚本(实际上node也可以)。而结合的这一任务是用shell来写的。<br>在这一步骤中还遇到一个问题，就是由于未知原因，截图不能一次性成功。检测截图是否成功，如果不成功则继续执行命令，直到成功为止。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"====Starting capturing and sending Email====\"</span></div><div class=\"line\"><span class=\"built_in\">echo</span> `date +%Y-%m-%d%t%H:%M:%S`</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">source</span> /etc/bashrc</div><div class=\"line\"></div><div class=\"line\">TIME=`date +%Y-%m-%d`</div><div class=\"line\">myFilePc=<span class=\"string\">\"/www/static/img/<span class=\"variable\">$TIME</span>/report_pc.png\"</span></div><div class=\"line\">myFileMobile=<span class=\"string\">\"/www/static/img/<span class=\"variable\">$TIME</span>/report_mobile.png\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"_\">-f</span> <span class=\"variable\">$myFilePc</span> ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">\trm <span class=\"_\">-f</span> <span class=\"string\">\"<span class=\"variable\">$myFilePc</span>\"</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"rm <span class=\"variable\">$myFilePc</span> is done!\"</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"cannot find <span class=\"variable\">$myFilePc</span>\"</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"_\">-f</span> <span class=\"variable\">$myFileMobile</span> ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">\trm <span class=\"_\">-f</span> <span class=\"string\">\"<span class=\"variable\">$myFileMobile</span>\"</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"rm <span class=\"variable\">$myFileMobile</span> is done!\"</span></div><div class=\"line\"><span class=\"keyword\">else</span></div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"cannot find <span class=\"variable\">$myFileMobile</span>\"</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#需要检测哪个图没有截取成功，再次执行命令，所以把capture_pc和capture_mobile分成两个文件写，这样成本最低</span></div><div class=\"line\"><span class=\"keyword\">while</span> [ ! <span class=\"_\">-f</span> <span class=\"variable\">$myFilePc</span> ]</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">\t/usr/<span class=\"built_in\">local</span>/bin/casperjs /crontabscript/capture_pc.js</div><div class=\"line\"><span class=\"keyword\">done</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">while</span> [ ! <span class=\"_\">-f</span> <span class=\"variable\">$myFileMobile</span> ]</div><div class=\"line\"><span class=\"keyword\">do</span></div><div class=\"line\">\t/usr/<span class=\"built_in\">local</span>/bin/casperjs /crontabscript/capture_mobile.js</div><div class=\"line\"><span class=\"keyword\">done</span></div><div class=\"line\"></div><div class=\"line\">/usr/<span class=\"built_in\">local</span>/Python-2.7.11/python /crontabscript/Email.py</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>为了保证顺利截图，还需要创建守护进程 (shell)<br>创建守护进行的思路是，每隔1分钟检查一次查找所需进程是否在进程列表中，如果没有，则启动进程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#!/bin/bash</span></div><div class=\"line\">CONDITION=<span class=\"string\">'能识别进程的关键字'</span></div><div class=\"line\">CMD=<span class=\"string\">'需要执行的命令'</span></div><div class=\"line\"></div><div class=\"line\">PROCESS_INFO=`ps aux|grep <span class=\"variable\">$CONDITION</span>|grep -v <span class=\"string\">'grep'</span>`</div><div class=\"line\"><span class=\"comment\">#echo $PROCESS_INFO</span></div><div class=\"line\">PID=`<span class=\"built_in\">echo</span> <span class=\"string\">\"<span class=\"variable\">$PROCESS_INFO</span>\"</span>|awk <span class=\"string\">'&#123;print $2&#125;'</span>`</div><div class=\"line\"><span class=\"comment\">#echo $PID</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$PID</span>\"</span> == <span class=\"string\">\"\"</span> ]</div><div class=\"line\"><span class=\"keyword\">then</span></div><div class=\"line\">\tTIME=`date`</div><div class=\"line\">\t<span class=\"built_in\">echo</span> <span class=\"string\">\"=============<span class=\"variable\">$TIME</span>===============\"</span></div><div class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">'No runnning process found! Try starting new process...'</span></div><div class=\"line\">    `<span class=\"variable\">$CMD</span>`</div><div class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">'Restart done!'</span></div><div class=\"line\"><span class=\"keyword\">fi</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"记录日志\"><a href=\"#记录日志\" class=\"headerlink\" title=\"记录日志\"></a>记录日志</h2><p>因为这些脚本会定时自动执行，在执行过程中可能会失败，我们需要一些信息来帮助我们定位问题。所以一定要在脚本中输出一些有价值的信息，并记录日志。</p>\n<h2 id=\"遇到过的问题\"><a href=\"#遇到过的问题\" class=\"headerlink\" title=\"遇到过的问题\"></a>遇到过的问题</h2><ul>\n<li>python在发送邮件时，使用域名致使邮件不能成功发送，暂时使用IP。<strong>（原因待查）</strong></li>\n<li>crontab执行截图时，报出phantomjs未安装，以及python未找到的错误。<br>  原因：crontab未找到正确的环境变量<br>  解决: 在脚本中执行截图操作前，先<code>source /etc/bashrc</code></li>\n<li>重启webpack的命令需要在指定的路径下才能执行<br>  <img src=\"/img/webpack-error.png\" alt=\"\"><br>  解决：（1）先cd到指定路径，再执行命令。（2）或者命令中指定webpack.config.js  <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"regexp\">/usr/</span>local<span class=\"regexp\">/bin/</span>node <span class=\"regexp\">/webpack/</span>node_modules<span class=\"regexp\">/.bin/</span>webpack-dev-server <span class=\"regexp\">/webpack/</span>webpack.config.js --inline --hot --quiet --host <span class=\"number\">0.0</span>.<span class=\"number\">0.0</span> --port <span class=\"number\">8366</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"感想\"><a href=\"#感想\" class=\"headerlink\" title=\"感想\"></a>感想</h2><p>自我感想，无论是使用shell、python、node，或者php都是可以完成任务的，没有规定什么样的语言只能完成什么样的任务。个人更建议选择一种自己熟悉的语言，来完成所有操作，这样可以降低学习成本。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1460882720000,
				"created_by": 2,
				"updated_at": 1460889050000,
				"updated_by": 2,
				"published_at": 1460882720000,
				"published_by": 2
			},
			{
				"id": "cj914pnz3002de0hy6wbo9e6j",
				"title": "Casperjs实战",
				"slug": "casperjs-example",
				"markdown": "\nCasperjs系列之实践操作。接上一篇Casperjs的理论介绍之后，我们来介绍一下Casperjs如何在实际场景中使用，以及可能会遇到的一些问题。\n<!-- more -->\n\n## 怎么用？\n因为Casperjs使用比较简单，基本可以分为三步，'创建并打开一个浏览器'，'进行网页浏览点击等等一系列操作', '关闭浏览器'。这里仅举两个例子作为介绍，其他更多的用法请参考Casperjs官方API。\n\n* **网页截图**\n\t截图可分为2种，一种是简单的**直接截图**，一种是**先登录再截图**。对于前者很简单，直接调api即可。难点再与后者，如何登录。\n\t而登录又分为2种，**正常填写form表单并提交**，网页跳转登录，但是这一种，往往会遇到需要填写验证码的情况，尤其是图片验证码，可能需要先进行图片识别，这样操作会比较复杂；另一种是，**带着cookie**直接打开需要截取的页面，但这种也存在弊端，就是如何解决cookie过期的问题。\n\t\n\t对于表单提交可以使用`fill, fillSelectors`的方法，关键代码片段如下：\n\t```\n\tvar casper = require('casper').create({\n\t\tpageSettings: {\n\t\t\tuserAgent: \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2593.0 Safari/537.36\"\n\t\t},\n\t\t// 不可以写online路径，只能写相对或绝对路径\n\t\t//clientScripts: [\"includes/jquery.min.js\"],\n\t\tverbose: true,\n\t\tlogLevel: 'debug'\n\t});\n\n\t// 1. start，初始化一个浏览器\n\tcasper.start().then(function(){\n\t\tthis.echo('....begin.....');\n\t});\n\n\t// 2. 设置viewportsize后打开页面\n\tcasper.viewport(1024, 768)\n\t\t\t.thenOpen('https://www.so.com')\n\t\t\t.then(function() {\n\t\t\t\tthis.echo(this.getTitle());\n\t\t\t});\n\n\t// 点击名为‘登录’的链接\n\tcasper.then(function(){\n\t\tif( this.exists('#user-login') ){\n\t\t\tthis.echo('还未登录');\n\t\t\t// 也可用'click'，'click'要求对选择器跟精确些\n\t\t\tthis.clickLabel('登录', 'a');\n\t\t}else{\n\t\t\tthis.echo('已登录');\n\t\t\tthis.exit();\n\t\t}\n\t});\n\n\t// 等待表单出现\n\tcasper.waitForSelector('form.quc-form', function(){\n\t\t// 截图： 登录之前的首页\n\t\tthis.captureSelector('a.png', 'body');\n\t\tthis.echo('登录表单已出现, 即将开始填写表单');\n\n\t\t// 填写表单，要是遇着输入图片形式的验证码就没辙了。。\n\t\t/**\n\t\t * 方法1\n\t\t */\n\t\tthis.fillSelectors('form.quc-form', {\n\t\t\t'.quc-input-account': '你的账号',\n\t\t\t'.quc-input-password': '你的密码'\n\t\t}, true);\n\n\t\t/**\n\t\t * 方法2\n\t\t * fill(),根据他们的'name'值来选择字段\n\t\t */\n\t\t/*this.fill('form.quc-form', {\n\t\t\t'account': '你的账号',\n\t\t\t'password': '你的密码'\n\t\t}, true);*/\n\n\t\t/**\n\t\t * 手动点击提交\n\t\t */\n\t\t/*this.evaluate(function(){\n\t\t\tdocument.querySelector('.quc-form').submit();\n\t\t});*/\n\t});\n\n\tcasper.wait(2000, function(){\n\t\tthis.echo('表单填写完成，正在验证.....');\n\t\t// 验证是否得到登录后的用户名\n\t\tvar name = this.exists('.login .uname') ? this.getElementInfo('.login .uname').text : '';\n\t\tthis.echo('the name is: ' + name);\n\t\t// 截图： 登录之后的首页\n\t\tthis.captureSelector('b1.png', 'body');\n\t});\n\n\t// 3. 将上面定义的操作进行实际操作\n\tcasper.run(function() {\n\t\t// 4. 关闭浏览器\n\t\tthis.echo('===================the progress is over!===================').exit();\n\t});\n\t```\n\n\t带着cookie打开网页的方法，但是Casperjs没有提供cookie相关的方法，好在我们还可以使用phantom中的方法，代码片段如下：\n\t```\n\tphantom.cookiesEnabled = true;\n\tcasper.then(function(){\n\t\tphantom.addCookie({\n\t\t  'name': 'Q',\n\t\t  'value': '具体的值',\n\t\t  'domain': '.so.com'\n\t\t});\n\n\t\tphantom.addCookie({\n\t\t  'name': 'T',\n\t\t  'value': '具体的值',\n\t\t  'domain': '.so.com'\n\t\t});\n\n\t\tshowAllCookie();\n\n\t\t// 需要带着cookie重新打开一下页面\n\t\tcasper.thenOpen('https://www.so.com', function(){\n\t\t\t// 点击登录\n\t\t\tif( this.exists('#user-login') ){\n\t\t\t\tthis.echo('还未登录');\n\t\t\t\t// 也可用'click'，'click'要求对选择器跟精确些\n\t\t\t\tthis.clickLabel('登录', 'a');\n\t\t\t}\n\n\t\t\t// 验证是否得到登录后的用户名\n\t\t\tvar name = this.exists('.login .uname') ? this.getElementInfo('.login .uname').text : '';\n\t\t\tthis.echo('the name is: ' + name);\n\n\t\t\t// 截图： 登录之后的首页\n\t\t\tthis.captureSelector('CB1.png', 'body');\n\t\t});\n\t\t\n\t});\n\t```\n\n* **爬虫**\n\t爬虫的基本思路就是，在网页中根据有序的dom结构获得到自己想要的信息。Casperjs自身提供了很多简单的可以操作dom的api，比如getTitle，getCurrentUrl，getHTML等等。除此之外，还可以在创建Casperjs对象时引入其他脚本，比如jquery。\n\t有时我们在做无具体目标的，需要保存页面中所有链接及其子链接依次往下链接内容时，就可能会连续用到then和thenOpen方法打开url。这里贴出一段官方的例子,就是遇到a链接就打开，并在新的页面中继续查找链接并打开，直接页面中没有链接为止：\n\t```\n\t/*eslint strict:0*/\n\t/*global CasperError, console, phantom, require*/\n\n\tvar casper = require(\"casper\").create({\n\t    verbose: true\n\t});\n\n\t// The base links array\n\tvar links = [\n\t    \"http://www.so.com/\"\n\t];\n\n\t// If we don't set a limit, it could go on forever\n\tvar upTo = ~~casper.cli.get(0) || 10;\n\n\tvar currentLink = 0;\n\n\t// Get the links, and add them to the links array\n\t// (It could be done all in one step, but it is intentionally splitted)\n\tfunction addLinks(link) {\n\t    this.then(function() {\n\t        var found = this.evaluate(searchLinks);\n\t        this.echo(found.length + \" links found on \" + link);\n\t        links = links.concat(found);\n\t    });\n\t}\n\n\t// Fetch all <a> elements from the page and return\n\t// the ones which contains a href starting with 'http://'\n\tfunction searchLinks() {\n\t    var filter, map;\n\t    filter = Array.prototype.filter;\n\t    map = Array.prototype.map;\n\t    return map.call(filter.call(document.querySelectorAll(\"a\"), function(a) {\n\t        return (/^http:\\/\\/.*/i).test(a.getAttribute(\"href\"));\n\t    }), function(a) {\n\t        return a.getAttribute(\"href\");\n\t    });\n\t}\n\n\t// Just opens the page and prints the title\n\tfunction start(link) {\n\t    this.start(link, function() {\n\t        this.echo('Page title: ' + this.getTitle());\n\t    });\n\t}\n\n\t// As long as it has a next link, and is under the maximum limit, will keep running\n\tfunction check() {\n\t    if (links[currentLink] && currentLink < upTo) {\n\t        this.echo('--- Link ' + currentLink + ' ---');\n\t        start.call(this, links[currentLink]);\n\t        addLinks.call(this, links[currentLink]);\n\t        currentLink++;\n\t        this.run(check);\n\t    } else {\n\t        this.echo(\"All done.\");\n\t        this.exit();\n\t    }\n\t}\n\n\tcasper.start().then(function() {\n\t    this.echo(\"Starting\");\n\t});\n\n\tcasper.run(check);\n\t```\n\n## 我遇到过的问题\n* viewport的设置:\n\tphantom默认设置是`300*400`。实践证明在不重写的情况下，不同页面截取下来的大小不一，有时是`300*y`，有时是`x*400`。\n\t如果需要根据页面的内容来截取特定大小的，需要先设置viewport中width，height中的任意一个，再通过极端内容的宽高，再次动态改变viewport的大小。\n\n* 不同系统对字体和highdpi支持不好\n\t比如在某些linux系统上无法显示汉字和某些特定的字体，需要重新安装。\n\t截出来的图在highdpi的屏幕上显示会发虚**（暂时还没找到解决办法）**\n\n* 不支持多进程，耗时长\n\t虽然可以通过配置`loadImages:  false,loadPlugins: false`来提高页面加载速度，但是在进行数据量较大的爬虫时，与pyhton还是有较大差距。\n\n* 找不到环境变量，如Phantomjs，python\n\t我自己是在使用crontab命令时遇到的，主要原因是环境变量没生效。\n\t解决办法：在命令运行之前，先source一下环境变量\n\n* 截图在开发机上莫名崩溃\n\t没有原因，不能稳定复现；不是占用内存或cpu过高，事实上才占用百分之几到0点几。\n\t暂且解决办法是，多执行几次截图命令直到截取成功为止。\n\t**目前没有找到真正的原因和解决办法**\n\n* 截取vue组件渲染的页面，空白\n\t具体场景：使用webpack来运行一套view，使用thinkjs来运行webpack打包后的view，截取后者view页面时，总是空白\n\t解决办法：去截取webpack运行的view\n",
				"html": "<p>Casperjs系列之实践操作。接上一篇Casperjs的理论介绍之后，我们来介绍一下Casperjs如何在实际场景中使用，以及可能会遇到的一些问题。<br><a id=\"more\"></a></p>\n<h2 id=\"怎么用？\"><a href=\"#怎么用？\" class=\"headerlink\" title=\"怎么用？\"></a>怎么用？</h2><p>因为Casperjs使用比较简单，基本可以分为三步，’创建并打开一个浏览器’，’进行网页浏览点击等等一系列操作’, ‘关闭浏览器’。这里仅举两个例子作为介绍，其他更多的用法请参考Casperjs官方API。</p>\n<ul>\n<li><p><strong>网页截图</strong><br>  截图可分为2种，一种是简单的<strong>直接截图</strong>，一种是<strong>先登录再截图</strong>。对于前者很简单，直接调api即可。难点再与后者，如何登录。<br>  而登录又分为2种，<strong>正常填写form表单并提交</strong>，网页跳转登录，但是这一种，往往会遇到需要填写验证码的情况，尤其是图片验证码，可能需要先进行图片识别，这样操作会比较复杂；另一种是，<strong>带着cookie</strong>直接打开需要截取的页面，但这种也存在弊端，就是如何解决cookie过期的问题。</p>\n<p>  对于表单提交可以使用<code>fill, fillSelectors</code>的方法，关键代码片段如下：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> casper = <span class=\"built_in\">require</span>(<span class=\"string\">'casper'</span>).create(&#123;</div><div class=\"line\">\t<span class=\"attr\">pageSettings</span>: &#123;</div><div class=\"line\">\t\t<span class=\"attr\">userAgent</span>: <span class=\"string\">\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2593.0 Safari/537.36\"</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\t<span class=\"comment\">// 不可以写online路径，只能写相对或绝对路径</span></div><div class=\"line\">\t<span class=\"comment\">//clientScripts: [\"includes/jquery.min.js\"],</span></div><div class=\"line\">\tverbose: <span class=\"literal\">true</span>,</div><div class=\"line\">\t<span class=\"attr\">logLevel</span>: <span class=\"string\">'debug'</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 1. start，初始化一个浏览器</span></div><div class=\"line\">casper.start().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'....begin.....'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 2. 设置viewportsize后打开页面</span></div><div class=\"line\">casper.viewport(<span class=\"number\">1024</span>, <span class=\"number\">768</span>)</div><div class=\"line\">\t\t.thenOpen(<span class=\"string\">'https://www.so.com'</span>)</div><div class=\"line\">\t\t.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.echo(<span class=\"keyword\">this</span>.getTitle());</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 点击名为‘登录’的链接</span></div><div class=\"line\">casper.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>( <span class=\"keyword\">this</span>.exists(<span class=\"string\">'#user-login'</span>) )&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'还未登录'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">// 也可用'click'，'click'要求对选择器跟精确些</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.clickLabel(<span class=\"string\">'登录'</span>, <span class=\"string\">'a'</span>);</div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'已登录'</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.exit();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等待表单出现</span></div><div class=\"line\">casper.waitForSelector(<span class=\"string\">'form.quc-form'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 截图： 登录之前的首页</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.captureSelector(<span class=\"string\">'a.png'</span>, <span class=\"string\">'body'</span>);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'登录表单已出现, 即将开始填写表单'</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 填写表单，要是遇着输入图片形式的验证码就没辙了。。</span></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 方法1</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"keyword\">this</span>.fillSelectors(<span class=\"string\">'form.quc-form'</span>, &#123;</div><div class=\"line\">\t\t<span class=\"string\">'.quc-input-account'</span>: <span class=\"string\">'你的账号'</span>,</div><div class=\"line\">\t\t<span class=\"string\">'.quc-input-password'</span>: <span class=\"string\">'你的密码'</span></div><div class=\"line\">\t&#125;, <span class=\"literal\">true</span>);</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 方法2</div><div class=\"line\">\t * fill(),根据他们的'name'值来选择字段</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"comment\">/*this.fill('form.quc-form', &#123;</span></div><div class=\"line\">\t\t'account': '你的账号',</div><div class=\"line\">\t\t'password': '你的密码'</div><div class=\"line\">\t&#125;, true);*/</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 手动点击提交</div><div class=\"line\">\t */</div><div class=\"line\">\t<span class=\"comment\">/*this.evaluate(function()&#123;</span></div><div class=\"line\">\t\tdocument.querySelector('.quc-form').submit();</div><div class=\"line\">\t&#125;);*/</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">casper.wait(<span class=\"number\">2000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'表单填写完成，正在验证.....'</span>);</div><div class=\"line\">\t<span class=\"comment\">// 验证是否得到登录后的用户名</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> name = <span class=\"keyword\">this</span>.exists(<span class=\"string\">'.login .uname'</span>) ? <span class=\"keyword\">this</span>.getElementInfo(<span class=\"string\">'.login .uname'</span>).text : <span class=\"string\">''</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'the name is: '</span> + name);</div><div class=\"line\">\t<span class=\"comment\">// 截图： 登录之后的首页</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.captureSelector(<span class=\"string\">'b1.png'</span>, <span class=\"string\">'body'</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 3. 将上面定义的操作进行实际操作</span></div><div class=\"line\">casper.run(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 4. 关闭浏览器</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'===================the progress is over!==================='</span>).exit();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>  带着cookie打开网页的方法，但是Casperjs没有提供cookie相关的方法，好在我们还可以使用phantom中的方法，代码片段如下：</p>\n  <figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">phantom.cookiesEnabled = <span class=\"literal\">true</span>;</div><div class=\"line\">casper.then(function()&#123;</div><div class=\"line\">\tphantom.addCookie(&#123;</div><div class=\"line\">\t  <span class=\"string\">'name'</span>: <span class=\"string\">'Q'</span>,</div><div class=\"line\">\t  <span class=\"string\">'value'</span>: <span class=\"string\">'具体的值'</span>,</div><div class=\"line\">\t  <span class=\"string\">'domain'</span>: <span class=\"string\">'.so.com'</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tphantom.addCookie(&#123;</div><div class=\"line\">\t  <span class=\"string\">'name'</span>: <span class=\"string\">'T'</span>,</div><div class=\"line\">\t  <span class=\"string\">'value'</span>: <span class=\"string\">'具体的值'</span>,</div><div class=\"line\">\t  <span class=\"string\">'domain'</span>: <span class=\"string\">'.so.com'</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tshowAllCookie();</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\">// 需要带着cookie重新打开一下页面</span></div><div class=\"line\">\tcasper.thenOpen(<span class=\"string\">'https://www.so.com'</span>, function()&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 点击登录</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>( <span class=\"keyword\">this</span>.exists(<span class=\"string\">'#user-login'</span>) )&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'还未登录'</span>);</div><div class=\"line\">\t\t\t<span class=\"comment\">// 也可用'click'，'click'要求对选择器跟精确些</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.clickLabel(<span class=\"string\">'登录'</span>, <span class=\"string\">'a'</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 验证是否得到登录后的用户名</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> name = <span class=\"keyword\">this</span>.exists(<span class=\"string\">'.login .uname'</span>) ? <span class=\"keyword\">this</span>.getElementInfo(<span class=\"string\">'.login .uname'</span>).text : <span class=\"string\">''</span>;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.echo(<span class=\"string\">'the name is: '</span> + name);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// 截图： 登录之后的首页</span></div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.captureSelector(<span class=\"string\">'CB1.png'</span>, <span class=\"string\">'body'</span>);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><strong>爬虫</strong><br>  爬虫的基本思路就是，在网页中根据有序的dom结构获得到自己想要的信息。Casperjs自身提供了很多简单的可以操作dom的api，比如getTitle，getCurrentUrl，getHTML等等。除此之外，还可以在创建Casperjs对象时引入其他脚本，比如jquery。<br>  有时我们在做无具体目标的，需要保存页面中所有链接及其子链接依次往下链接内容时，就可能会连续用到then和thenOpen方法打开url。这里贴出一段官方的例子,就是遇到a链接就打开，并在新的页面中继续查找链接并打开，直接页面中没有链接为止：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*eslint strict:0*/</span></div><div class=\"line\"><span class=\"comment\">/*global CasperError, console, phantom, require*/</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> casper = <span class=\"built_in\">require</span>(<span class=\"string\">\"casper\"</span>).create(&#123;</div><div class=\"line\">    <span class=\"attr\">verbose</span>: <span class=\"literal\">true</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// The base links array</span></div><div class=\"line\"><span class=\"keyword\">var</span> links = [</div><div class=\"line\">    <span class=\"string\">\"http://www.so.com/\"</span></div><div class=\"line\">];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// If we don't set a limit, it could go on forever</span></div><div class=\"line\"><span class=\"keyword\">var</span> upTo = ~~casper.cli.get(<span class=\"number\">0</span>) || <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> currentLink = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Get the links, and add them to the links array</span></div><div class=\"line\"><span class=\"comment\">// (It could be done all in one step, but it is intentionally splitted)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addLinks</span>(<span class=\"params\">link</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> found = <span class=\"keyword\">this</span>.evaluate(searchLinks);</div><div class=\"line\">        <span class=\"keyword\">this</span>.echo(found.length + <span class=\"string\">\" links found on \"</span> + link);</div><div class=\"line\">        links = links.concat(found);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Fetch all &lt;a&gt; elements from the page and return</span></div><div class=\"line\"><span class=\"comment\">// the ones which contains a href starting with 'http://'</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">searchLinks</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> filter, map;</div><div class=\"line\">    filter = <span class=\"built_in\">Array</span>.prototype.filter;</div><div class=\"line\">    map = <span class=\"built_in\">Array</span>.prototype.map;</div><div class=\"line\">    <span class=\"keyword\">return</span> map.call(filter.call(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"a\"</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"regexp\">/^http:\\/\\/.*/i</span>).test(a.getAttribute(<span class=\"string\">\"href\"</span>));</div><div class=\"line\">    &#125;), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> a.getAttribute(<span class=\"string\">\"href\"</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Just opens the page and prints the title</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">start</span>(<span class=\"params\">link</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.start(link, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.echo(<span class=\"string\">'Page title: '</span> + <span class=\"keyword\">this</span>.getTitle());</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// As long as it has a next link, and is under the maximum limit, will keep running</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (links[currentLink] &amp;&amp; currentLink &lt; upTo) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.echo(<span class=\"string\">'--- Link '</span> + currentLink + <span class=\"string\">' ---'</span>);</div><div class=\"line\">        start.call(<span class=\"keyword\">this</span>, links[currentLink]);</div><div class=\"line\">        addLinks.call(<span class=\"keyword\">this</span>, links[currentLink]);</div><div class=\"line\">        currentLink++;</div><div class=\"line\">        <span class=\"keyword\">this</span>.run(check);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.echo(<span class=\"string\">\"All done.\"</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.exit();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">casper.start().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.echo(<span class=\"string\">\"Starting\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">casper.run(check);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"我遇到过的问题\"><a href=\"#我遇到过的问题\" class=\"headerlink\" title=\"我遇到过的问题\"></a>我遇到过的问题</h2><ul>\n<li><p>viewport的设置:<br>  phantom默认设置是<code>300*400</code>。实践证明在不重写的情况下，不同页面截取下来的大小不一，有时是<code>300*y</code>，有时是<code>x*400</code>。<br>  如果需要根据页面的内容来截取特定大小的，需要先设置viewport中width，height中的任意一个，再通过极端内容的宽高，再次动态改变viewport的大小。</p>\n</li>\n<li><p>不同系统对字体和highdpi支持不好<br>  比如在某些linux系统上无法显示汉字和某些特定的字体，需要重新安装。<br>  截出来的图在highdpi的屏幕上显示会发虚<strong>（暂时还没找到解决办法）</strong></p>\n</li>\n<li><p>不支持多进程，耗时长<br>  虽然可以通过配置<code>loadImages:  false,loadPlugins: false</code>来提高页面加载速度，但是在进行数据量较大的爬虫时，与pyhton还是有较大差距。</p>\n</li>\n<li><p>找不到环境变量，如Phantomjs，python<br>  我自己是在使用crontab命令时遇到的，主要原因是环境变量没生效。<br>  解决办法：在命令运行之前，先source一下环境变量</p>\n</li>\n<li><p>截图在开发机上莫名崩溃<br>  没有原因，不能稳定复现；不是占用内存或cpu过高，事实上才占用百分之几到0点几。<br>  暂且解决办法是，多执行几次截图命令直到截取成功为止。<br>  <strong>目前没有找到真正的原因和解决办法</strong></p>\n</li>\n<li><p>截取vue组件渲染的页面，空白<br>  具体场景：使用webpack来运行一套view，使用thinkjs来运行webpack打包后的view，截取后者view页面时，总是空白<br>  解决办法：去截取webpack运行的view</p>\n</li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1460880260000,
				"created_by": 2,
				"updated_at": 1460888897000,
				"updated_by": 2,
				"published_at": 1460880260000,
				"published_by": 2
			},
			{
				"id": "cj914pnz5002ge0hyo5wypjeh",
				"title": "Casperjs简介",
				"slug": "casperjs",
				"markdown": "\nCasperjs系列之理论介绍。这一篇我们先来认识一下Casperjs是什么，以及它的一些基本理论知识。<!-- more -->\n\n## 是什么？\n> [Casperjs](http://Casperjs.org/)是一个开源的导航脚本处理和测试工具，基于Phantomjs和SlimerJS。它简化了页面间导航的定义过程，提供了处理常见任务的实用的高级函数、方法和语法糖。\n\n上面这段是从官网上摘取翻译的，可以看出Casperjs是在Phantomjs和Selemjs基础上的再一次更好的封装，有更简单的api，使用起来会更简单，同时它还有自己的测试框架(Phantomjs则没有）。\n\n我们知道Phantomjs就是一个基于webkit内核的无头浏览器（没有界面的浏览器）,它可以完全模拟webkit内核浏览器的行为。因此借助于Casperjs我们可以模拟真实用户正常打开浏览器浏览网页的行为。同时，因为它还是一个测试工具，我们可以借助它完成前端自动化测试（端到端）的测试。\n\n## 能干什么？\n* 定义、排列页面间导航的步骤(先打开页面A，再打开页面B，open, thenOpen)\n* 表单的填充、提交(fill)\n* 点击、跟踪超链接(click a)\n`以上三点其实就是模拟用户的浏览网页时的行为`\n* 区域、页面截图\n\t`最重要也是最常用的功能之一`\n* 测试远程DOM(有自己的断言语法)\n\t`最重要也是最常用的功能之一`\n* 记录日志(不同级别的，包括debug，info，warning，error;Casperjs默认在标准输出不输出log信息)\n* 资源下载，包括二进制资源\n* 编写功能测试套件，可以将结果以JUnit XML形式导出\n* 抓取网页内容\n\n今天在这里我们对Casperjs的测试工具的功能先不做讨论，主要介绍和讨论Casperjs的**页面导航截图**的功能。\n\n## 如何安装？\n* 首先需要装Phantomjs, >= 1.9.1；python, >= 2.6；mac中默认安装了python，`python --version`可以查看python的版本\n* 再装Casperjs, 多种安装方式，比如mac, 可以从homebrew, git, npm等等。这里以npm安装举例：`npm install -g Casperjs`\n* 虽然Casperjs可以通过npm来安装，但是Casperjs和Phantomjs都是独立于node系统的。它不是nodejs的一个库或是包，可以通过node的exec方法来执行Casperjs命令。或者使用[SpookyJS](https://github.com/SpookyJS/SpookyJS)来是的node可以驱动Casperjs。\n* spookyJS是将Casperjs作为nodejs的一个子进程来执行。\n* 当然了，在其他语言中也可以直接调用它们，比如java，php，shell等等。\n\n## 是如何工作的？\n* 首先它是基于消息驱动的。有then,wait字样的操作都是异步的行为。需要注意的是exit()也是异步的。也就是说，step1中调用exit,step2也有可能执行。\n* 同时，它是基于step栈的。只有当执行run()命令时这些步骤才会被真正开始执行。一个step是这样的一个js方法：等待前一个step正在执行时处于等待状态；在请求一个链接和页面加载未完成时处于等待状态。典型的一个方法是`then()`方法。\n* 当完成一个step时，casperjs会去检查三个状态标识`pendingWait, loadInProgress, and navigationRequested`，当这三个标识只有任意一个为true时，就会挂起等待，直到全部为false时才会进行下一个step。\n\ncasperjs也提供了查看具体step的方法：\n```\nrequire('utils').dump(casper.steps.map(function(step) {\n    return step.toString();\n}));\n\n```\n\n在控制台看到的打印的栈信息如下，其中有一个_step()，这个是CasperJs自动帮我们加的。\n<img src=\"/img/casperjs-test.png\" alt=\"\" >\n\n## 更多疑问，参考[这里](http://docs.casperjs.org/en/latest/faq.html)\n\n## 参考\n* [Casperjs官网](http://casperjs.org/)\n* [CasperJS 基础](http://html-js.com/article/CasperJS-based-frontend-automation-testing-road)\n* [使用phantomJS 、casperjs 一个月小感受](http://group.jobbole.com/12782/)\n* [别的人遇到的相关问题](http://sudodev.cn/tag/casperjs-phantomjs/)\n* [End To End Testing with PhantomJS and CasperJS](http://thejsguy.com/2015/02/28/end-to-end-testing-with-phantomsjs-and-casperjs.html)\n* [Web 自动化测试与智能爬虫利器：PhantomJS 简介与实战](http://my.oschina.net/leejun2005/blog/407043?fromerr=2nf4tBuT)\n\n\n\n",
				"html": "<p>Casperjs系列之理论介绍。这一篇我们先来认识一下Casperjs是什么，以及它的一些基本理论知识。<a id=\"more\"></a></p>\n<h2 id=\"是什么？\"><a href=\"#是什么？\" class=\"headerlink\" title=\"是什么？\"></a>是什么？</h2><blockquote>\n<p><a href=\"http://Casperjs.org/\" target=\"_blank\" rel=\"external\">Casperjs</a>是一个开源的导航脚本处理和测试工具，基于Phantomjs和SlimerJS。它简化了页面间导航的定义过程，提供了处理常见任务的实用的高级函数、方法和语法糖。</p>\n</blockquote>\n<p>上面这段是从官网上摘取翻译的，可以看出Casperjs是在Phantomjs和Selemjs基础上的再一次更好的封装，有更简单的api，使用起来会更简单，同时它还有自己的测试框架(Phantomjs则没有）。</p>\n<p>我们知道Phantomjs就是一个基于webkit内核的无头浏览器（没有界面的浏览器）,它可以完全模拟webkit内核浏览器的行为。因此借助于Casperjs我们可以模拟真实用户正常打开浏览器浏览网页的行为。同时，因为它还是一个测试工具，我们可以借助它完成前端自动化测试（端到端）的测试。</p>\n<h2 id=\"能干什么？\"><a href=\"#能干什么？\" class=\"headerlink\" title=\"能干什么？\"></a>能干什么？</h2><ul>\n<li>定义、排列页面间导航的步骤(先打开页面A，再打开页面B，open, thenOpen)</li>\n<li>表单的填充、提交(fill)</li>\n<li>点击、跟踪超链接(click a)<br><code>以上三点其实就是模拟用户的浏览网页时的行为</code></li>\n<li>区域、页面截图<br>  <code>最重要也是最常用的功能之一</code></li>\n<li>测试远程DOM(有自己的断言语法)<br>  <code>最重要也是最常用的功能之一</code></li>\n<li>记录日志(不同级别的，包括debug，info，warning，error;Casperjs默认在标准输出不输出log信息)</li>\n<li>资源下载，包括二进制资源</li>\n<li>编写功能测试套件，可以将结果以JUnit XML形式导出</li>\n<li>抓取网页内容</li>\n</ul>\n<p>今天在这里我们对Casperjs的测试工具的功能先不做讨论，主要介绍和讨论Casperjs的<strong>页面导航截图</strong>的功能。</p>\n<h2 id=\"如何安装？\"><a href=\"#如何安装？\" class=\"headerlink\" title=\"如何安装？\"></a>如何安装？</h2><ul>\n<li>首先需要装Phantomjs, &gt;= 1.9.1；python, &gt;= 2.6；mac中默认安装了python，<code>python --version</code>可以查看python的版本</li>\n<li>再装Casperjs, 多种安装方式，比如mac, 可以从homebrew, git, npm等等。这里以npm安装举例：<code>npm install -g Casperjs</code></li>\n<li>虽然Casperjs可以通过npm来安装，但是Casperjs和Phantomjs都是独立于node系统的。它不是nodejs的一个库或是包，可以通过node的exec方法来执行Casperjs命令。或者使用<a href=\"https://github.com/SpookyJS/SpookyJS\" target=\"_blank\" rel=\"external\">SpookyJS</a>来是的node可以驱动Casperjs。</li>\n<li>spookyJS是将Casperjs作为nodejs的一个子进程来执行。</li>\n<li>当然了，在其他语言中也可以直接调用它们，比如java，php，shell等等。</li>\n</ul>\n<h2 id=\"是如何工作的？\"><a href=\"#是如何工作的？\" class=\"headerlink\" title=\"是如何工作的？\"></a>是如何工作的？</h2><ul>\n<li>首先它是基于消息驱动的。有then,wait字样的操作都是异步的行为。需要注意的是exit()也是异步的。也就是说，step1中调用exit,step2也有可能执行。</li>\n<li>同时，它是基于step栈的。只有当执行run()命令时这些步骤才会被真正开始执行。一个step是这样的一个js方法：等待前一个step正在执行时处于等待状态；在请求一个链接和页面加载未完成时处于等待状态。典型的一个方法是<code>then()</code>方法。</li>\n<li>当完成一个step时，casperjs会去检查三个状态标识<code>pendingWait, loadInProgress, and navigationRequested</code>，当这三个标识只有任意一个为true时，就会挂起等待，直到全部为false时才会进行下一个step。</li>\n</ul>\n<p>casperjs也提供了查看具体step的方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'utils'</span>).dump(casper.steps.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">step</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> step.toString();</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure></p>\n<p>在控制台看到的打印的栈信息如下，其中有一个_step()，这个是CasperJs自动帮我们加的。<br><img src=\"/img/casperjs-test.png\" alt=\"\"></p>\n<h2 id=\"更多疑问，参考这里\"><a href=\"#更多疑问，参考这里\" class=\"headerlink\" title=\"更多疑问，参考这里\"></a>更多疑问，参考<a href=\"http://docs.casperjs.org/en/latest/faq.html\" target=\"_blank\" rel=\"external\">这里</a></h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://casperjs.org/\" target=\"_blank\" rel=\"external\">Casperjs官网</a></li>\n<li><a href=\"http://html-js.com/article/CasperJS-based-frontend-automation-testing-road\" target=\"_blank\" rel=\"external\">CasperJS 基础</a></li>\n<li><a href=\"http://group.jobbole.com/12782/\" target=\"_blank\" rel=\"external\">使用phantomJS 、casperjs 一个月小感受</a></li>\n<li><a href=\"http://sudodev.cn/tag/casperjs-phantomjs/\" target=\"_blank\" rel=\"external\">别的人遇到的相关问题</a></li>\n<li><a href=\"http://thejsguy.com/2015/02/28/end-to-end-testing-with-phantomsjs-and-casperjs.html\" target=\"_blank\" rel=\"external\">End To End Testing with PhantomJS and CasperJS</a></li>\n<li><a href=\"http://my.oschina.net/leejun2005/blog/407043?fromerr=2nf4tBuT\" target=\"_blank\" rel=\"external\">Web 自动化测试与智能爬虫利器：PhantomJS 简介与实战</a></li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1460528675000,
				"created_by": 2,
				"updated_at": 1461298009000,
				"updated_by": 2,
				"published_at": 1460528675000,
				"published_by": 2
			},
			{
				"id": "cj914pnyu0022e0hyhvdqlx85",
				"title": "使用ES7的async函数简化异步编程[译]",
				"slug": "async-fy",
				"markdown": "\n翻译[Simplifying Asynchronous Coding with ES7 Async Functions](http://www.sitepoint.com/simplifying-asynchronous-coding-es7-async-functions/)\n<!-- more -->\n\njs中Promises的出现照亮了互联网，它帮助开发者逃出callback地狱，并且解决了大部分js编程者无处不在都会遇到的异步代码的困扰。然而Promises并不是完美的，它依旧会有callback，在复杂的情况下仍然很混乱和难以置信的冗余。\n\n随着ES6的出现，不仅可以无需引入任意一个库就可以直接使用语言自带的promise，而且我们还可以使用过generators。generators可以通过一个函数来暂停进程，这意味着把generators包裹在一个通用函数中，我们可以等待一个异步操作结束之后再执行下一行代码。突然，你的异步代码开始看上去像同步一样。\n\n但是这只是第一步。在ES7中，async functions即将被发布了。async functions的思想是这样的，使用异步编程的generators，并且赋予它们独有的简单和富有语义的语法。因此，你不必使用一个库来获取之前提到的那个通用函数，因为这一些都在背后默默做好了。\n\n如果要是跑一下这篇文章里的ES7代码，你需要使用Traceur编译器。\n\n## Async Functions vs Generators\n",
				"html": "<p>翻译<a href=\"http://www.sitepoint.com/simplifying-asynchronous-coding-es7-async-functions/\" target=\"_blank\" rel=\"external\">Simplifying Asynchronous Coding with ES7 Async Functions</a><br><a id=\"more\"></a></p>\n<p>js中Promises的出现照亮了互联网，它帮助开发者逃出callback地狱，并且解决了大部分js编程者无处不在都会遇到的异步代码的困扰。然而Promises并不是完美的，它依旧会有callback，在复杂的情况下仍然很混乱和难以置信的冗余。</p>\n<p>随着ES6的出现，不仅可以无需引入任意一个库就可以直接使用语言自带的promise，而且我们还可以使用过generators。generators可以通过一个函数来暂停进程，这意味着把generators包裹在一个通用函数中，我们可以等待一个异步操作结束之后再执行下一行代码。突然，你的异步代码开始看上去像同步一样。</p>\n<p>但是这只是第一步。在ES7中，async functions即将被发布了。async functions的思想是这样的，使用异步编程的generators，并且赋予它们独有的简单和富有语义的语法。因此，你不必使用一个库来获取之前提到的那个通用函数，因为这一些都在背后默默做好了。</p>\n<p>如果要是跑一下这篇文章里的ES7代码，你需要使用Traceur编译器。</p>\n<h2 id=\"Async-Functions-vs-Generators\"><a href=\"#Async-Functions-vs-Generators\" class=\"headerlink\" title=\"Async Functions vs Generators\"></a>Async Functions vs Generators</h2>",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1449555788000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1449555788000,
				"published_by": 2
			},
			{
				"id": "cj914po0o004xe0hyk2pjiyvx",
				"title": "用thinkjs2升级moheUI平台",
				"slug": "thinkjs2",
				"markdown": "\n花了4天时间把之前mohe平台用thinkjs2升级了下，3天改代码，1天部署。在thinkjs2.X版本中还是遇到了些大大小小的问题，这里记录下。\n\n<!-- more -->\n\n## controller\n0. 凡是需要init的地方，都得用super.init()\n```\ninit (...arg) {\n\tsuper.init(...arg);\n}\n一般情况下，只需传参http：\ninit (http) {\n\tsuper.init(http);\n\tthis.__model = this;\n}\n```\n1. 2.0 里推荐的文件名都小写,有大写的话会看到一个warning的。\n 比如componentController中有个action名以前是componentSubmitAction，在view中我们会这样写请求，`/component/componentSubmit`,在1.x版本是没有问题的；\n 但是在2.x版本中thinkjs会强制将请求的url都转成小写的，所以最终发送的请求就变成了`/component/componentsubmit`,这样就会出现找不到action的情况。\n 虽然在2.0.6版本后，thinkjs支持**URL 解析后的 Action 支持含有 - 字符**,但是`component-submitAction`这样命名还是感觉怪怪的。\n\n2. 用await代替了promise后，之前用`then.then.catch`的流程可以改为\n```\ntry{\n\t//这里就是各种操作\n}catch(err){\n\tconsole.log(err);\n\treturn this.fail('保存组件失败');\n}\n```\n\n2. controller中还是可以用promise，也不是全都非得改成await的形式，还是得看具体流程。\n比如有个操作需要，先检查文件后缀名->文件重命名->上传文件->检测代码->返回成功结果。这样一个流程，就很适合用then连接起来。\n但是，需要注意的是如果需要流程进行下去，需要返回一个普通的json或变量，而不是this.success(),否则流程会被中断，直接将success返回给view了\n```\nthis.checkFile( file, fileType )\n\t\t.then(reg =>{\n\t\tconsole.log('--------renameFile-----');\n\t\t// 重命名文件\n\t\treturn this.renameFile( reg, file );\n\t}).then(passedFile=>{\n\t\tconsole.log('--------uploadFile-----');\n\t\t// uploadFile函数里已返回this.success\n\t\treturn this.uploadFile( this.UPLOAD_FILE_PATH, passedFile );\n\t}).then(res=>{\n\t\tconsole.log('----chheckCode outter---');\n\t\t// 检查代码内容\n\t\tif( fileType == 'code' ){\n\t\t\tconsole.log('----chheckCode inner---');\n\t\t\treturn this.checkCode( this.UPLOAD_FILE_PATH, res );\n\t\t}\n\t\treturn res;\n\t}).then(res=>{\n\t\tconsole.log('--------return data-----');\n\t\tthis.success(res,'success');\n\t}).catch(err=>{\n\t\tconsole.log( `fileupload is err =======:${err}` );\n\t\tthis.fail( 100, err, {fileName: file.originalFilename} );\n});\n```\n3. 在promise中要像以前一样用到this，需要写在箭头函数中。\n[this 作用域的问题](https://thinkjs.org/zh-CN/doc/2.0/controller.html#toc-4e2)\n\n## model\n2. 最好跟数据表名一致,不然就要在模型里配置\n(成银：如果表名中带下划线，那么实例化的地方也要改成下划线,因为实例化的时候会试图去寻找模型文件，如果找不到的话会实例化默认的模型，就不能用模型中自定义的方法了。)\n比如：有一张表component_version，那么相应的模型命名为，component_version.js，在要用到这个模型时，这样实例化`this.model('component_version')`,这样就可以用里面的方法了，以及select，where等等这样自带的原子方法。\n\n\t自己之前因为弄不清楚实例化模型的原理，各种尝试，还用过import模型，再new的方法，其实thinkjs中提供的this.model()方法就已经是实例化的方法，不用再new了\n\n3. 如果在模型中的init()方法出错了，会出现access deny，就是连不上数据库的错误。\n\n5. 有表别名时，countSelect()会报错。(以反馈，还未修好)\n之前在用2.0.6版本时，还遇到了当page取默认值时，limit是从1开始而不是从0开始，后来的版本修好了。(使用最新版本的代码是多么的重要啊)\n\n## 其他配置\n4. 需要用到自己添加的配置文件\n比如有个文件`/src/common/src/github_opts.js`，需要用到其中的数据，就可以这样引入`think.config('github_opts')`\n\n5. 定义全局变量\n<img src=\"/img/thinkjs2/developmentjs.png\" width=\"400px\">\n相应的productionjs也需要修改\n\n## 代码运行模式切换\n1. 使用npm start 默认是development环境,因为start读的是package.json文件\n<img src=\"/img/thinkjs2/packagejson.png\" width=\"400px\">\n\n2. 如果需要运行在production环境，`npm start production`\n\n## 调试\n1. 大部分时候自己是通过console.log()来进行调试，心累手累。\n如果是--es6的形式来创建的项目，最终控制台报错的行号，是在编译后的app目录文件里的。\n\n2. [ThinkJS 项目用 WebStorm 来设置断点与调试](http://www.cnblogs.com/jkisjk/p/debug_thinkjs_with_webstorm.html)\n\n## 部署\n1. 在windows下运行的好好的代码，放到linux下，模型方法会报错，怀疑是自己代码写法有问题，babel在两种环境下的编译也会略有差异。\n\n2. 使用pm2 启动时，配置了`www/production.js`为入口文件，但是每次启动还是在寻找`www/index.js`。\n最后是建了个软链`ln -s production.js index.js`\n\n3. 出现文件路径过长，不能成功clone的问题，主要是bable依赖\n在线上机器和本地开发机，分别先npm install；\n因为这个项目中，用到一些不能直接install的依赖，就先将本地的node_moudles/xx依赖提前push到仓库中。\n\n4. 删除git仓库中的文件\n\n```\ngit rm -rf 文件夹名/\ngit commit -m \"remove 文件夹名\"\ngit push\n\n// 有时，还需要物理删除文件夹\nrm -rf 文件夹名/\n```\n\n## 写在最后\n0. 升级是个体力活，但是如果不追求用es6/7，只是替换一些函数用法，其实也就controller需要改的多一些。\n1. es7的await，async很好用，逻辑看起来清晰很多了。\n2. 字符串模板很好用，再也可以不用+连接了，尤其是里面有引号的时候，根本写不清楚。\n3. object.assign()也好用。\n4. 箭头函数也好用，函数简洁。\n5. let在循环中帮助很大，再也不用担心闭包中写for循环的变量引用问题了。\n",
				"html": "<p>花了4天时间把之前mohe平台用thinkjs2升级了下，3天改代码，1天部署。在thinkjs2.X版本中还是遇到了些大大小小的问题，这里记录下。</p>\n<a id=\"more\"></a>\n<h2 id=\"controller\"><a href=\"#controller\" class=\"headerlink\" title=\"controller\"></a>controller</h2><ol>\n<li><p>凡是需要init的地方，都得用super.init()</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">init (...arg) &#123;</div><div class=\"line\">\t<span class=\"keyword\">super</span>.init(...arg);</div><div class=\"line\">&#125;</div><div class=\"line\">一般情况下，只需传参http：</div><div class=\"line\">init (http) &#123;</div><div class=\"line\">\t<span class=\"keyword\">super</span>.init(http);</div><div class=\"line\">\t<span class=\"keyword\">this</span>.__model = <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>2.0 里推荐的文件名都小写,有大写的话会看到一个warning的。<br>比如componentController中有个action名以前是componentSubmitAction，在view中我们会这样写请求，<code>/component/componentSubmit</code>,在1.x版本是没有问题的；<br>但是在2.x版本中thinkjs会强制将请求的url都转成小写的，所以最终发送的请求就变成了<code>/component/componentsubmit</code>,这样就会出现找不到action的情况。<br>虽然在2.0.6版本后，thinkjs支持<strong>URL 解析后的 Action 支持含有 - 字符</strong>,但是<code>component-submitAction</code>这样命名还是感觉怪怪的。</p>\n</li>\n<li><p>用await代替了promise后，之前用<code>then.then.catch</code>的流程可以改为</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//这里就是各种操作</span></div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(err)&#123;</div><div class=\"line\">\tconsole.log(err);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.fail(<span class=\"string\">'保存组件失败'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>controller中还是可以用promise，也不是全都非得改成await的形式，还是得看具体流程。<br>比如有个操作需要，先检查文件后缀名-&gt;文件重命名-&gt;上传文件-&gt;检测代码-&gt;返回成功结果。这样一个流程，就很适合用then连接起来。<br>但是，需要注意的是如果需要流程进行下去，需要返回一个普通的json或变量，而不是this.success(),否则流程会被中断，直接将success返回给view了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.checkFile( file, fileType )</div><div class=\"line\">\t\t.then(<span class=\"function\"><span class=\"params\">reg</span> =&gt;</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'--------renameFile-----'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">// 重命名文件</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.renameFile( reg, file );</div><div class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"params\">passedFile</span>=&gt;</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'--------uploadFile-----'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">// uploadFile函数里已返回this.success</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.uploadFile( <span class=\"keyword\">this</span>.UPLOAD_FILE_PATH, passedFile );</div><div class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'----chheckCode outter---'</span>);</div><div class=\"line\">\t\t<span class=\"comment\">// 检查代码内容</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span>( fileType == <span class=\"string\">'code'</span> )&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'----chheckCode inner---'</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.checkCode( <span class=\"keyword\">this</span>.UPLOAD_FILE_PATH, res );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> res;</div><div class=\"line\">\t&#125;).then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'--------return data-----'</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.success(res,<span class=\"string\">'success'</span>);</div><div class=\"line\">\t&#125;).catch(<span class=\"function\"><span class=\"params\">err</span>=&gt;</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log( <span class=\"string\">`fileupload is err =======:<span class=\"subst\">$&#123;err&#125;</span>`</span> );</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.fail( <span class=\"number\">100</span>, err, &#123;<span class=\"attr\">fileName</span>: file.originalFilename&#125; );</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p>在promise中要像以前一样用到this，需要写在箭头函数中。<br><a href=\"https://thinkjs.org/zh-CN/doc/2.0/controller.html#toc-4e2\" target=\"_blank\" rel=\"external\">this 作用域的问题</a></p>\n</li>\n</ol>\n<h2 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h2><ol>\n<li><p>最好跟数据表名一致,不然就要在模型里配置<br>(成银：如果表名中带下划线，那么实例化的地方也要改成下划线,因为实例化的时候会试图去寻找模型文件，如果找不到的话会实例化默认的模型，就不能用模型中自定义的方法了。)<br>比如：有一张表component_version，那么相应的模型命名为，component_version.js，在要用到这个模型时，这样实例化<code>this.model(&#39;component_version&#39;)</code>,这样就可以用里面的方法了，以及select，where等等这样自带的原子方法。</p>\n<p> 自己之前因为弄不清楚实例化模型的原理，各种尝试，还用过import模型，再new的方法，其实thinkjs中提供的this.model()方法就已经是实例化的方法，不用再new了</p>\n</li>\n<li><p>如果在模型中的init()方法出错了，会出现access deny，就是连不上数据库的错误。</p>\n</li>\n<li><p>有表别名时，countSelect()会报错。(以反馈，还未修好)<br>之前在用2.0.6版本时，还遇到了当page取默认值时，limit是从1开始而不是从0开始，后来的版本修好了。(使用最新版本的代码是多么的重要啊)</p>\n</li>\n</ol>\n<h2 id=\"其他配置\"><a href=\"#其他配置\" class=\"headerlink\" title=\"其他配置\"></a>其他配置</h2><ol>\n<li><p>需要用到自己添加的配置文件<br>比如有个文件<code>/src/common/src/github_opts.js</code>，需要用到其中的数据，就可以这样引入<code>think.config(&#39;github_opts&#39;)</code></p>\n</li>\n<li><p>定义全局变量<br><img src=\"/img/thinkjs2/developmentjs.png\" width=\"400px\"><br>相应的productionjs也需要修改</p>\n</li>\n</ol>\n<h2 id=\"代码运行模式切换\"><a href=\"#代码运行模式切换\" class=\"headerlink\" title=\"代码运行模式切换\"></a>代码运行模式切换</h2><ol>\n<li><p>使用npm start 默认是development环境,因为start读的是package.json文件<br><img src=\"/img/thinkjs2/packagejson.png\" width=\"400px\"></p>\n</li>\n<li><p>如果需要运行在production环境，<code>npm start production</code></p>\n</li>\n</ol>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><ol>\n<li><p>大部分时候自己是通过console.log()来进行调试，心累手累。<br>如果是–es6的形式来创建的项目，最终控制台报错的行号，是在编译后的app目录文件里的。</p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/jkisjk/p/debug_thinkjs_with_webstorm.html\" target=\"_blank\" rel=\"external\">ThinkJS 项目用 WebStorm 来设置断点与调试</a></p>\n</li>\n</ol>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><ol>\n<li><p>在windows下运行的好好的代码，放到linux下，模型方法会报错，怀疑是自己代码写法有问题，babel在两种环境下的编译也会略有差异。</p>\n</li>\n<li><p>使用pm2 启动时，配置了<code>www/production.js</code>为入口文件，但是每次启动还是在寻找<code>www/index.js</code>。<br>最后是建了个软链<code>ln -s production.js index.js</code></p>\n</li>\n<li><p>出现文件路径过长，不能成功clone的问题，主要是bable依赖<br>在线上机器和本地开发机，分别先npm install；<br>因为这个项目中，用到一些不能直接install的依赖，就先将本地的node_moudles/xx依赖提前push到仓库中。</p>\n</li>\n<li><p>删除git仓库中的文件</p>\n</li>\n</ol>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"keyword\">rm</span> -rf 文件夹名/</div><div class=\"line\">git commit -<span class=\"keyword\">m</span> <span class=\"string\">\"remove 文件夹名\"</span></div><div class=\"line\">git push</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 有时，还需要物理删除文件夹</span></div><div class=\"line\"><span class=\"keyword\">rm</span> -rf 文件夹名/</div></pre></td></tr></table></figure>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><ol>\n<li>升级是个体力活，但是如果不追求用es6/7，只是替换一些函数用法，其实也就controller需要改的多一些。</li>\n<li>es7的await，async很好用，逻辑看起来清晰很多了。</li>\n<li>字符串模板很好用，再也可以不用+连接了，尤其是里面有引号的时候，根本写不清楚。</li>\n<li>object.assign()也好用。</li>\n<li>箭头函数也好用，函数简洁。</li>\n<li>let在循环中帮助很大，再也不用担心闭包中写for循环的变量引用问题了。</li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1449451142000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1449451142000,
				"published_by": 2
			},
			{
				"id": "cj914pnyz002ae0hyja9myrce",
				"title": "关于canvas的几个XX像素",
				"slug": "canvas-devicePixelRatio",
				"markdown": "这几个概念实在是太绕了，光想理顺它，就拖了好久才下笔整理下来<!-- more -->\n\n## 设备像素 \n* 真实像素\n* 物理像素\n* 设备会有几个物理像素来表示一个css像素\n* canvas.width/height\n\n## 设备独立像素(dip)\n* 与屏幕密度相关，与设备无关\n* 是计算机坐标系中的一点，是程序可用的虚拟像素\n* 逻辑像素\n* 比如CSS像素\n* `canvas.style.width`以及`screen.width`\n\n## 设备像素比(devicePixelRatio)\n* `设备像素比 ＝ 物理像素 / 设备独立像素`\n* `设备像素比 ＝ 设备像素 / CSS像素`\n* 在非retina屏幕上，屏幕物理像素是320，独立像素也是320;在retina上，屏幕物理像素640，独立像素还是320，因此设备像素比为2\n* 可通过`window.devicePixelRatio`查看\n* 当它不等于1时，说明会用大于1个的物理像素以填充的方式来渲染1个逻辑像素，这样就出现了图片模糊的情况。\n* `<meta name=\"viewport\" content=\"width=device-width\">`的时候，其视区宽度并不是640像素，而是320像素，是独立像素值。\n* 并不是所有看上去清晰的手机屏幕都是2被devicePixelRatio的。有些不清晰的屏幕，还有可能是3倍的，比如酷派8675.\n0中的webkitBackingStorePixelRatio是2.\n<img src=\"/img/canvas/devicePixelRatio.png\">\n<img src=\"/img/canvas/img-retina.png\">\n\n* webkitBackingStorePixelRatio\n它只有在safari和chrome中才有的属性。它决定了浏览器在渲染一个图片的时候用几个像素来存储画布信息。比如，safari 6.0中，它的值为2，当要渲染`100px*100px`的图片时，它首先在内存中生成一个`200*200`的图片，当在retina屏下，devicePixelRatio=2时，屏幕本身会按照`200*200`来渲染图片，这时**所需**的大小正好与内存中**一致**，直接拿出来用就好，此时显示出来的图片就不会失真。否则若devicePixelRatio=1，那么图片就会被放大1倍来显示，就会变模糊了。\n\n**(小图变大会模糊，大图变小会更清晰)**\n\n## 参考\n* [canvas分辨率问题](http://jeffdeng.me/js/2015/07/06/canvas-resolution/)\n* [使用Flexible实现手淘H5页面的终端适配](https://github.com/amfe/article/issues/17)\n* [设备像素比devicePixelRatio简单介绍](设备像素比devicePixelRatio简单介绍)",
				"html": "<p>这几个概念实在是太绕了，光想理顺它，就拖了好久才下笔整理下来<a id=\"more\"></a></p>\n<h2 id=\"设备像素\"><a href=\"#设备像素\" class=\"headerlink\" title=\"设备像素\"></a>设备像素</h2><ul>\n<li>真实像素</li>\n<li>物理像素</li>\n<li>设备会有几个物理像素来表示一个css像素</li>\n<li>canvas.width/height</li>\n</ul>\n<h2 id=\"设备独立像素-dip\"><a href=\"#设备独立像素-dip\" class=\"headerlink\" title=\"设备独立像素(dip)\"></a>设备独立像素(dip)</h2><ul>\n<li>与屏幕密度相关，与设备无关</li>\n<li>是计算机坐标系中的一点，是程序可用的虚拟像素</li>\n<li>逻辑像素</li>\n<li>比如CSS像素</li>\n<li><code>canvas.style.width</code>以及<code>screen.width</code></li>\n</ul>\n<h2 id=\"设备像素比-devicePixelRatio\"><a href=\"#设备像素比-devicePixelRatio\" class=\"headerlink\" title=\"设备像素比(devicePixelRatio)\"></a>设备像素比(devicePixelRatio)</h2><ul>\n<li><code>设备像素比 ＝ 物理像素 / 设备独立像素</code></li>\n<li><code>设备像素比 ＝ 设备像素 / CSS像素</code></li>\n<li>在非retina屏幕上，屏幕物理像素是320，独立像素也是320;在retina上，屏幕物理像素640，独立像素还是320，因此设备像素比为2</li>\n<li>可通过<code>window.devicePixelRatio</code>查看</li>\n<li>当它不等于1时，说明会用大于1个的物理像素以填充的方式来渲染1个逻辑像素，这样就出现了图片模糊的情况。</li>\n<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code>的时候，其视区宽度并不是640像素，而是320像素，是独立像素值。</li>\n<li><p>并不是所有看上去清晰的手机屏幕都是2被devicePixelRatio的。有些不清晰的屏幕，还有可能是3倍的，比如酷派8675.<br>0中的webkitBackingStorePixelRatio是2.<br><img src=\"/img/canvas/devicePixelRatio.png\"><br><img src=\"/img/canvas/img-retina.png\"></p>\n</li>\n<li><p>webkitBackingStorePixelRatio<br>它只有在safari和chrome中才有的属性。它决定了浏览器在渲染一个图片的时候用几个像素来存储画布信息。比如，safari 6.0中，它的值为2，当要渲染<code>100px*100px</code>的图片时，它首先在内存中生成一个<code>200*200</code>的图片，当在retina屏下，devicePixelRatio=2时，屏幕本身会按照<code>200*200</code>来渲染图片，这时<strong>所需</strong>的大小正好与内存中<strong>一致</strong>，直接拿出来用就好，此时显示出来的图片就不会失真。否则若devicePixelRatio=1，那么图片就会被放大1倍来显示，就会变模糊了。</p>\n</li>\n</ul>\n<p><strong>(小图变大会模糊，大图变小会更清晰)</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://jeffdeng.me/js/2015/07/06/canvas-resolution/\" target=\"_blank\" rel=\"external\">canvas分辨率问题</a></li>\n<li><a href=\"https://github.com/amfe/article/issues/17\" target=\"_blank\" rel=\"external\">使用Flexible实现手淘H5页面的终端适配</a></li>\n<li><a href=\"设备像素比devicePixelRatio简单介绍\">设备像素比devicePixelRatio简单介绍</a></li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1447928845000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1447928845000,
				"published_by": 2
			},
			{
				"id": "cj914pnyw0025e0hyte1dvxbj",
				"title": "一次关于canvas hidpi的2个bug解决过程",
				"slug": "bug-canvas",
				"markdown": "\n本文记录了2个为了解决hidpi下canvas呈现而引发的不同bug定位和最终解决过程。<!-- more -->越来越多的设备屏幕趋于高分辨率，我们称之为hidpi设备，与此同时人们对用户体验的要求也越来越高，然而canvas是一个画布，屏幕上的每个像素块是其绘制的最小单位。这也就决定了凡是能影响其绘制的因素，都会影响最终canvas呈现的效果。\n\n\n## 背景\n* canvas的width和style.width的关系\n* hidpi-canvas-polyfill的简单介绍\n\n#### canvas的width和style.width的关系\n简单来说是这样的\n* canvas的width是这个画布的宽，就是要在多大的布上画图。我们后来在canvas上画线，矩形啥的那个单位也是相对于这个画布来看的。它可以理解为把canvas的宽高均分成了多少份。\n* canvas的style.width是canvas的物理宽度，也就是相当于画框的宽。\n\n`<canvas width=\"200\" height=\"200\"></canvas>`，这里的width和height不能带有单位。如果省略不写，那么canvas默认`width=300, height=150`\n如果canvas的`width/height`和其`style.width/style.height`不相等，那么会出现图形比例失真的情况。比如：我们想在`400*400`的画框里得到一个`100*100`的正方形块\n<img src=\"/img/canvas/canvas-1.png\" width=\"250px\">\n\n如果仅仅按照如下代码书写，那么得到的矩形块根本不是正方形，而是个长方形啊\n```html\n<style>\n\t#myCanvas{\n\t\twidth: 400px;\n\t\theight: 400px;\n\t\tborder: 1px solid #000;\n\t}\n</style>\n\n<canvas id=\"myCanvas\"></canvas>\n\n<script type=\"text/javascript\">\n\tvar canvas = document.getElementById('myCanvas');\n\tvar ctx = canvas.getContext('2d');\n\tctx.fillStyle = 'red';\n\tctx.fillRect(0,0,100,100);\n</script>\n```\n<img src=\"/img/canvas/canvas-2.png\" width=\"250px\">\n\n**为什么会这样呢？**\n在canvas画布计算时，它是这样的一个过程：\n* W看到的宽度 = W需要绘制的宽度 / W画布宽 * W画框宽\n* 这里我们没有设置画布的宽高，也就是取默认的300*150, 即W画布宽 = 300，W需要绘制的宽度 = 100，W画框宽取CSS或style中设定的宽， W画框宽 = 400px\n* W看到的宽度 = 100 / 300 * 400 = 166px\n* W看到的高度计算同理\n\n#### hidpi对canvas的影响\n之前提到canvas的最小单位是像素，通常我们是一个像素绘制一个点，但是当`devicePixel=2`时，设备会用2个像素来绘制一个canvas上的点，如果按照原始的画布大小，就会看上去线比较粗。\n\n所以通常当devicePixel不为1时，我们会将画布先放大devicePixel倍，并将canvas放大devicePixel倍。\n\n最后，受到canvas画框的限制，画的canvas就清楚了。\n\n**注： context.sacle(2, 2)需要在画图之前就设定**\n\n#### hidpi-canvas-polyfill的简单介绍\n这两个bug都是因引入插件[hidpi-canvas-polyfill](https://github.com/jondavidjohn/hidpi-canvas-polyfill)而引起的。如这个polyfill的介绍，它是为了帮助我们在不改变自身任何canvas代码的前提下，自动地在任意浏览器和设备上保持canvas的清晰度。\n\n它由两部分JS组成，**CanvasRenderingContext2D.js**和**HTMLCanvasElement**\n* `ratio = devicePixelRatio \\ backingStore`\n* 前者是根据ratio, 将canvas的context的主要绘图接口重写\n* 后者是改变canvas的width和style.width\n* 然后两者综合起来，来达到维持canvas清晰度的目的\n\n## safari下的webkitBackingStorePixelRatio\nBUG复现：仅在safari下报错，但不影响程序的功能，即曲线和正常出，清晰度也符合预期。\n报错信息：不赞成在非CanvasRenderingContext2D的对象上使用webkitBackingStorePixelRatio属性\n<img src=\"/img/canvas/bug.png\">\n\n#### 定位问题\n因为时间比较紧，没有仔细研究插件代码的具体含义，只是简单定位问题，修复错误。\n\n1. 猜测，首先想到的是捕获错误，定位确定是不是因为webkitBackingStorePixelRatio而引起的错误。\n方法：尝试在出现webkitBackingStorePixelRatio的地方用try-catch捕获错误\n结果：然并卵，居然没捕获到错误，依然会报相同的错误\n\n2. 进一步怀疑\n方法：去除webkitBackingStorePixelRatio使用的地方\n结果：报错消失\n\n3. 确认到底是不是webkitBackingStorePixelRatio而引起的错误\n方法：使用webkitBackingStorePixelRatio的对象是CanvasRenderingContext2D.prototype，分别直接在safari和chorme控制台查找CanvasRenderingContext2D.prototype的属性，都没有找到这个属性；\n接着直接输入`CanvasRenderingContext2D.prototype.webkitBackingStorePixelRatio`\n结果： safari中报相同的错误，chrome中没有报错。\n\n4. 再次验证\n方法：在safari控制台输入`CanvasRenderingContext2D.webkitBackingStorePixelRatio`。\n结果：虽然没有获得到值，但是也没有报错。可以肯定确实是CanvasRenderingContext2D.prototype.webkitBackingStorePixelRatio而引起的错误。\n\n3. 为什么没有捕获到错误，怀疑代码没有执行到try-catch的地方就报错了\n方法：在try-catch的上下加console.log，并打印用webkitBackingStorePixelRatio的变量t最终结果\n结果：输出不符合预期，t居然还有了最终值，报错依然存在。很是奇怪，按预期，报错了应该终止程序，t没有结果。\n<img src=\"/img/canvas/debug-after.png\" alt=\"\">\n\n#### 结果分析\n确实是webkitBackingStorePixelRatio这个属性而引起的报错。但是既然不影响程序的正常运行，却又有这个错误，可以理解为是safari自身的问题，它的提示信息不够友好。\n\n#### 修复方法\n1. 通过查阅资料发现webkitBackingStorePixelRatio这个属性也是为了解决canvas清晰度而存在的。\n它决定了浏览器在渲染canvas之前会用几个像素来存储画布信息。不同浏览器的BackingStorePixelRatio可能不同，它和devicePixelRatio共同决定了canvas的清晰度。比如在devicePixelRatio=2的设备上，safari6的webkitBackingStorePixelRatio是2，也就是说一个canvas在safari6上不用做任何处理就是清晰的。而chrome的webkitBackingStorePixelRatio是1，需要对canvas进行缩放才能保证其清晰度。[High DPI Canvas](http://www.html5rocks.com/en/tutorials/canvas/hidpi/?redirect_from_locale=zh)\n\n2. 但是在2013.8之后的[chromium升级](https://code.google.com/p/chromium/issues/detail?id=277205)中，去除了这一属性\n因为此后webkitBackingStorePixelRatio的值始终保持为1，也就是说目前只有safari6.0中的webkitBackingStorePixelRatio是2.\n<img src=\"/img/canvas/chromium.png\">\n\n3. 因此在插件中就直接写定为1就可以了。\n\n4. 之前提到过hidpi-canvas这个插件由两部分组成，一部分是改变画布和画框大小，一部分是重新画一遍图以适应改变大小后的画布\n参考[High DPI Canvas](http://www.html5rocks.com/en/tutorials/canvas/hidpi/?redirect_from_locale=zh)文章后，去除了**CanvasRenderingContext2D.js**这部分，改用`context.scale(ratio, ratio);`，其中`ratio = devicePixelRatio / backingStoreRatio`。\n因为**[CanvasRenderingContext2D](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D)**是为绘制canvas提供各种接口。其本身也可以通过`context = canvas.getContext('2d')`得到。因此保留这个js意义不大。\n\n## Coolpad8675中的好搜app下，canvas渲染不出来\nBUG复现：canvas处空白\n报错信息：没有脚本报错\n\n#### 定位问题\n猜测有可能引起问题的原因\n* 浏览器对canvas的渲染，可是别人家的canvas渲染一点问题都没有呀\n* 可能是canvas的大小没在可显示的范围里，因为之前有遇到canvas的width特别大，style.width正常的,导致canvas显示不正常\n* 可能canvas的父元素没显示出来\n* 可能是层级问题\n* 页面里的其他dom或插件影响了它\n\n综合以上可能的原因，做了如下的验证：\n1. 在最外层js最开始的地方加try-catch，试图捕获错误信息，打印不出来任何错误\n\n1. 因为canvas为绝对定位，而其父元素又没有设置高度，可能受到影响；为其父元素加高度，加背景色，背景色显示，曲线还是没出来\n\n2. 给canvas加背景色，然并卵，毫无改变\n\n2. 打印canvas的宽高，offset().width等信息，可以正常打印，说明canvas这个元素是存在的\n\n3. 为canvas加较高层级，然并卵\n\n4. 在body中新追加简单的canvas，同样没显示出来\n\n由此可以确认，不是由于绘制canvas出错，和画曲线无关系。接下来进一步验证\n\n1. 在纯净的页面中简单画最最简单的canvas，不做任何变换等等，结果出来了。\n由此说明，是其他dom或插件影响了之前canvas的正常绘制。\n\n2. 去除hidpi-canvas插件，曲线出现了\n因为在页面中，影响最大的，最有可能的就是hidpi-canvas这个插件。只有它有对后来的canvas做处理。做的主要处理就是改变canvas的width和style.width\n\n进一步验证改变canvas的width和style.width是如何影响canvas绘制的\n* 在纯净的页面中，将canvas的width和style.width设置成不同的值，发现在某些值时，canvas是会正常出现的，在另一些值是不出现的。\n* 怀疑在当二者比例在某个范围中，是可正常显示，反之不可。通过**二分法**验证，不断测试最终确定当`width / style.width < 0.78`时，可正常显示。\n* 至此，已可以确定出现bug的原因了。\n\n#### 修复方法\n\n1. 初步怀疑是chrome的某个版本内核通用的bug\n通过打印两个2APP的**window.navigator.userAgent**(一个正常显示，一个非正常显示)，居然发现chrome内核版本居然一样，而且除了最后app的信息外，其他的一模一样。\n\n2. 所以只能是针对特定手机中的特定app做单独的case的处理\n\n3. 用正则匹配userAgent,`/(Coolpad\\s8675).*(mso_app\\s\\(4.1.0.1001\\))/i`\n如果符合这两个条件，那么就不调用hidpi-canvas插件\n\n## 总结\n* try-catch是个好方法\n可以捕获错误，避免报错，打印错误信息\n```\ntry{\n\t可能会报错的代码\n}catch(error){\n\t对错误的处理，比如打印错误信息\n}\n```\n\n* window.navigator.userAgent是个好东西\n常常用来做hack...\n\n* 另外还发现在safari下，没有external对象\n\n* 最后附上解决hidpi下canvas清晰度的[代码](http://jiaolonghuang.github.io/code/hidpi-HTMLCanvasElement.js)\n\n\n\n",
				"html": "<p>本文记录了2个为了解决hidpi下canvas呈现而引发的不同bug定位和最终解决过程。<a id=\"more\"></a>越来越多的设备屏幕趋于高分辨率，我们称之为hidpi设备，与此同时人们对用户体验的要求也越来越高，然而canvas是一个画布，屏幕上的每个像素块是其绘制的最小单位。这也就决定了凡是能影响其绘制的因素，都会影响最终canvas呈现的效果。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>canvas的width和style.width的关系</li>\n<li>hidpi-canvas-polyfill的简单介绍</li>\n</ul>\n<h4 id=\"canvas的width和style-width的关系\"><a href=\"#canvas的width和style-width的关系\" class=\"headerlink\" title=\"canvas的width和style.width的关系\"></a>canvas的width和style.width的关系</h4><p>简单来说是这样的</p>\n<ul>\n<li>canvas的width是这个画布的宽，就是要在多大的布上画图。我们后来在canvas上画线，矩形啥的那个单位也是相对于这个画布来看的。它可以理解为把canvas的宽高均分成了多少份。</li>\n<li>canvas的style.width是canvas的物理宽度，也就是相当于画框的宽。</li>\n</ul>\n<p><code>&lt;canvas width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</code>，这里的width和height不能带有单位。如果省略不写，那么canvas默认<code>width=300, height=150</code><br>如果canvas的<code>width/height</code>和其<code>style.width/style.height</code>不相等，那么会出现图形比例失真的情况。比如：我们想在<code>400*400</code>的画框里得到一个<code>100*100</code>的正方形块<br><img src=\"/img/canvas/canvas-1.png\" width=\"250px\"></p>\n<p>如果仅仅按照如下代码书写，那么得到的矩形块根本不是正方形，而是个长方形啊<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"></span></div><div class=\"line\">\t<span class=\"selector-id\">#myCanvas</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">height</span>: <span class=\"number\">400px</span>;</div><div class=\"line\">\t\t<span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"myCanvas\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">\t<span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myCanvas'</span>);</div><div class=\"line\">\t<span class=\"keyword\">var</span> ctx = canvas.getContext(<span class=\"string\">'2d'</span>);</div><div class=\"line\">\tctx.fillStyle = <span class=\"string\">'red'</span>;</div><div class=\"line\">\tctx.fillRect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">100</span>,<span class=\"number\">100</span>);</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p><img src=\"/img/canvas/canvas-2.png\" width=\"250px\"></p>\n<p><strong>为什么会这样呢？</strong><br>在canvas画布计算时，它是这样的一个过程：</p>\n<ul>\n<li>W看到的宽度 = W需要绘制的宽度 / W画布宽 * W画框宽</li>\n<li>这里我们没有设置画布的宽高，也就是取默认的300*150, 即W画布宽 = 300，W需要绘制的宽度 = 100，W画框宽取CSS或style中设定的宽， W画框宽 = 400px</li>\n<li>W看到的宽度 = 100 / 300 * 400 = 166px</li>\n<li>W看到的高度计算同理</li>\n</ul>\n<h4 id=\"hidpi对canvas的影响\"><a href=\"#hidpi对canvas的影响\" class=\"headerlink\" title=\"hidpi对canvas的影响\"></a>hidpi对canvas的影响</h4><p>之前提到canvas的最小单位是像素，通常我们是一个像素绘制一个点，但是当<code>devicePixel=2</code>时，设备会用2个像素来绘制一个canvas上的点，如果按照原始的画布大小，就会看上去线比较粗。</p>\n<p>所以通常当devicePixel不为1时，我们会将画布先放大devicePixel倍，并将canvas放大devicePixel倍。</p>\n<p>最后，受到canvas画框的限制，画的canvas就清楚了。</p>\n<p><strong>注： context.sacle(2, 2)需要在画图之前就设定</strong></p>\n<h4 id=\"hidpi-canvas-polyfill的简单介绍\"><a href=\"#hidpi-canvas-polyfill的简单介绍\" class=\"headerlink\" title=\"hidpi-canvas-polyfill的简单介绍\"></a>hidpi-canvas-polyfill的简单介绍</h4><p>这两个bug都是因引入插件<a href=\"https://github.com/jondavidjohn/hidpi-canvas-polyfill\" target=\"_blank\" rel=\"external\">hidpi-canvas-polyfill</a>而引起的。如这个polyfill的介绍，它是为了帮助我们在不改变自身任何canvas代码的前提下，自动地在任意浏览器和设备上保持canvas的清晰度。</p>\n<p>它由两部分JS组成，<strong>CanvasRenderingContext2D.js</strong>和<strong>HTMLCanvasElement</strong></p>\n<ul>\n<li><code>ratio = devicePixelRatio \\ backingStore</code></li>\n<li>前者是根据ratio, 将canvas的context的主要绘图接口重写</li>\n<li>后者是改变canvas的width和style.width</li>\n<li>然后两者综合起来，来达到维持canvas清晰度的目的</li>\n</ul>\n<h2 id=\"safari下的webkitBackingStorePixelRatio\"><a href=\"#safari下的webkitBackingStorePixelRatio\" class=\"headerlink\" title=\"safari下的webkitBackingStorePixelRatio\"></a>safari下的webkitBackingStorePixelRatio</h2><p>BUG复现：仅在safari下报错，但不影响程序的功能，即曲线和正常出，清晰度也符合预期。<br>报错信息：不赞成在非CanvasRenderingContext2D的对象上使用webkitBackingStorePixelRatio属性<br><img src=\"/img/canvas/bug.png\"></p>\n<h4 id=\"定位问题\"><a href=\"#定位问题\" class=\"headerlink\" title=\"定位问题\"></a>定位问题</h4><p>因为时间比较紧，没有仔细研究插件代码的具体含义，只是简单定位问题，修复错误。</p>\n<ol>\n<li><p>猜测，首先想到的是捕获错误，定位确定是不是因为webkitBackingStorePixelRatio而引起的错误。<br>方法：尝试在出现webkitBackingStorePixelRatio的地方用try-catch捕获错误<br>结果：然并卵，居然没捕获到错误，依然会报相同的错误</p>\n</li>\n<li><p>进一步怀疑<br>方法：去除webkitBackingStorePixelRatio使用的地方<br>结果：报错消失</p>\n</li>\n<li><p>确认到底是不是webkitBackingStorePixelRatio而引起的错误<br>方法：使用webkitBackingStorePixelRatio的对象是CanvasRenderingContext2D.prototype，分别直接在safari和chorme控制台查找CanvasRenderingContext2D.prototype的属性，都没有找到这个属性；<br>接着直接输入<code>CanvasRenderingContext2D.prototype.webkitBackingStorePixelRatio</code><br>结果： safari中报相同的错误，chrome中没有报错。</p>\n</li>\n<li><p>再次验证<br>方法：在safari控制台输入<code>CanvasRenderingContext2D.webkitBackingStorePixelRatio</code>。<br>结果：虽然没有获得到值，但是也没有报错。可以肯定确实是CanvasRenderingContext2D.prototype.webkitBackingStorePixelRatio而引起的错误。</p>\n</li>\n<li><p>为什么没有捕获到错误，怀疑代码没有执行到try-catch的地方就报错了<br>方法：在try-catch的上下加console.log，并打印用webkitBackingStorePixelRatio的变量t最终结果<br>结果：输出不符合预期，t居然还有了最终值，报错依然存在。很是奇怪，按预期，报错了应该终止程序，t没有结果。<br><img src=\"/img/canvas/debug-after.png\" alt=\"\"></p>\n</li>\n</ol>\n<h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><p>确实是webkitBackingStorePixelRatio这个属性而引起的报错。但是既然不影响程序的正常运行，却又有这个错误，可以理解为是safari自身的问题，它的提示信息不够友好。</p>\n<h4 id=\"修复方法\"><a href=\"#修复方法\" class=\"headerlink\" title=\"修复方法\"></a>修复方法</h4><ol>\n<li><p>通过查阅资料发现webkitBackingStorePixelRatio这个属性也是为了解决canvas清晰度而存在的。<br>它决定了浏览器在渲染canvas之前会用几个像素来存储画布信息。不同浏览器的BackingStorePixelRatio可能不同，它和devicePixelRatio共同决定了canvas的清晰度。比如在devicePixelRatio=2的设备上，safari6的webkitBackingStorePixelRatio是2，也就是说一个canvas在safari6上不用做任何处理就是清晰的。而chrome的webkitBackingStorePixelRatio是1，需要对canvas进行缩放才能保证其清晰度。<a href=\"http://www.html5rocks.com/en/tutorials/canvas/hidpi/?redirect_from_locale=zh\" target=\"_blank\" rel=\"external\">High DPI Canvas</a></p>\n</li>\n<li><p>但是在2013.8之后的<a href=\"https://code.google.com/p/chromium/issues/detail?id=277205\" target=\"_blank\" rel=\"external\">chromium升级</a>中，去除了这一属性<br>因为此后webkitBackingStorePixelRatio的值始终保持为1，也就是说目前只有safari6.0中的webkitBackingStorePixelRatio是2.<br><img src=\"/img/canvas/chromium.png\"></p>\n</li>\n<li><p>因此在插件中就直接写定为1就可以了。</p>\n</li>\n<li><p>之前提到过hidpi-canvas这个插件由两部分组成，一部分是改变画布和画框大小，一部分是重新画一遍图以适应改变大小后的画布<br>参考<a href=\"http://www.html5rocks.com/en/tutorials/canvas/hidpi/?redirect_from_locale=zh\" target=\"_blank\" rel=\"external\">High DPI Canvas</a>文章后，去除了<strong>CanvasRenderingContext2D.js</strong>这部分，改用<code>context.scale(ratio, ratio);</code>，其中<code>ratio = devicePixelRatio / backingStoreRatio</code>。<br>因为<strong><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D\" target=\"_blank\" rel=\"external\">CanvasRenderingContext2D</a></strong>是为绘制canvas提供各种接口。其本身也可以通过<code>context = canvas.getContext(&#39;2d&#39;)</code>得到。因此保留这个js意义不大。</p>\n</li>\n</ol>\n<h2 id=\"Coolpad8675中的好搜app下，canvas渲染不出来\"><a href=\"#Coolpad8675中的好搜app下，canvas渲染不出来\" class=\"headerlink\" title=\"Coolpad8675中的好搜app下，canvas渲染不出来\"></a>Coolpad8675中的好搜app下，canvas渲染不出来</h2><p>BUG复现：canvas处空白<br>报错信息：没有脚本报错</p>\n<h4 id=\"定位问题-1\"><a href=\"#定位问题-1\" class=\"headerlink\" title=\"定位问题\"></a>定位问题</h4><p>猜测有可能引起问题的原因</p>\n<ul>\n<li>浏览器对canvas的渲染，可是别人家的canvas渲染一点问题都没有呀</li>\n<li>可能是canvas的大小没在可显示的范围里，因为之前有遇到canvas的width特别大，style.width正常的,导致canvas显示不正常</li>\n<li>可能canvas的父元素没显示出来</li>\n<li>可能是层级问题</li>\n<li>页面里的其他dom或插件影响了它</li>\n</ul>\n<p>综合以上可能的原因，做了如下的验证：</p>\n<ol>\n<li><p>在最外层js最开始的地方加try-catch，试图捕获错误信息，打印不出来任何错误</p>\n</li>\n<li><p>因为canvas为绝对定位，而其父元素又没有设置高度，可能受到影响；为其父元素加高度，加背景色，背景色显示，曲线还是没出来</p>\n</li>\n<li><p>给canvas加背景色，然并卵，毫无改变</p>\n</li>\n<li><p>打印canvas的宽高，offset().width等信息，可以正常打印，说明canvas这个元素是存在的</p>\n</li>\n<li><p>为canvas加较高层级，然并卵</p>\n</li>\n<li><p>在body中新追加简单的canvas，同样没显示出来</p>\n</li>\n</ol>\n<p>由此可以确认，不是由于绘制canvas出错，和画曲线无关系。接下来进一步验证</p>\n<ol>\n<li><p>在纯净的页面中简单画最最简单的canvas，不做任何变换等等，结果出来了。<br>由此说明，是其他dom或插件影响了之前canvas的正常绘制。</p>\n</li>\n<li><p>去除hidpi-canvas插件，曲线出现了<br>因为在页面中，影响最大的，最有可能的就是hidpi-canvas这个插件。只有它有对后来的canvas做处理。做的主要处理就是改变canvas的width和style.width</p>\n</li>\n</ol>\n<p>进一步验证改变canvas的width和style.width是如何影响canvas绘制的</p>\n<ul>\n<li>在纯净的页面中，将canvas的width和style.width设置成不同的值，发现在某些值时，canvas是会正常出现的，在另一些值是不出现的。</li>\n<li>怀疑在当二者比例在某个范围中，是可正常显示，反之不可。通过<strong>二分法</strong>验证，不断测试最终确定当<code>width / style.width &lt; 0.78</code>时，可正常显示。</li>\n<li>至此，已可以确定出现bug的原因了。</li>\n</ul>\n<h4 id=\"修复方法-1\"><a href=\"#修复方法-1\" class=\"headerlink\" title=\"修复方法\"></a>修复方法</h4><ol>\n<li><p>初步怀疑是chrome的某个版本内核通用的bug<br>通过打印两个2APP的<strong>window.navigator.userAgent</strong>(一个正常显示，一个非正常显示)，居然发现chrome内核版本居然一样，而且除了最后app的信息外，其他的一模一样。</p>\n</li>\n<li><p>所以只能是针对特定手机中的特定app做单独的case的处理</p>\n</li>\n<li><p>用正则匹配userAgent,<code>/(Coolpad\\s8675).*(mso_app\\s\\(4.1.0.1001\\))/i</code><br>如果符合这两个条件，那么就不调用hidpi-canvas插件</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>try-catch是个好方法<br>可以捕获错误，避免报错，打印错误信息</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">try</span>&#123;</div><div class=\"line\">\t可能会报错的代码</div><div class=\"line\">&#125;<span class=\"keyword\">catch</span>(error)&#123;</div><div class=\"line\">\t对错误的处理，比如打印错误信息</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>window.navigator.userAgent是个好东西<br>常常用来做hack…</p>\n</li>\n<li><p>另外还发现在safari下，没有external对象</p>\n</li>\n<li><p>最后附上解决hidpi下canvas清晰度的<a href=\"http://jiaolonghuang.github.io/code/hidpi-HTMLCanvasElement.js\">代码</a></p>\n</li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1447670173000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1447670173000,
				"published_by": 2
			},
			{
				"id": "cj914pnzi0030e0hy4rmcf1bn",
				"title": "迁移CSDN博客",
				"slug": "htmltomd",
				"markdown": "\ncsdn总是在公司打不开，上面的博客不更新了又舍不得扔，便想着迁过来。\n<!-- more -->\n\n大致思路：\n1. csdn里的博客都不能直接导出成md格式的\n2. hexo的博客是解析markdowwn的\n3. 抓取网页html结构 -> md格式\n\n工具：\n\n1. 说到网页抓取工具，首先想到的是[phantomJs](http://phantomjs.org/), 还有一个[casperjs](http://casperjs.org/), 后者是在前者的基础上包装了一层，使用起来更方便。\n这两个工具使用起来都是与node相似，但是它们又是有自己的环境，独立于node的，基于node的包不可以直接在它们中使用\n另外，casperjs又是依赖于phantomJs的，也就是说安装casperjs要先安装phantomJs\n不得不吐槽的是，在环windows上装casperjs太费劲了，各种配环境变量，装python2.7 啥的都不好使，装了2天都没成功，mac上一下就成功了\n\n2. 因为在markdown中，有效的标签只有那么几种，而直接抓取下来的网页中标签很杂，因此需要过滤保留几种标签。\n可以用正则来匹配，但是考虑到嵌套标签，以及里面标签的不可预知性（说白了就是想偷懒），找了一个防xss的node包，[js-xss](https://github.com/leizongmin/js-xss), 这个插件里可以指定只保留哪些标签\n\n3. 最后就是用[to-markdwon](https://github.com/domchristie/to-markdown), 这个包来生成最后md格式的文件\n\n4. 由于casperjs的环境和node的环境是独立的，显然这是一个两步走的流程，但是可以使用node中exec方法`var exec = require('child_process').exec;`，来执行命令行命令，这样就把两者结合起来了\n\n问题：\n毕竟这是工具生成的，再最终的文件中，还是有些地方不那么完美，需要手动再次调整下，但是比起来一个个的粘贴复制，工作量还是小不少。主要问题体现在：\n1. 代码的格式，乱七八糟。。csdn自身展示代码的插件会在有代码的地方生成一些乱七八糟的dom结果\n2. 对md中的关键字符，没有转义，比如星号等\n3. 图片无法抓取保存\n\n结果\n[CSDN旧博客](http://jiaolonghuang.github.io/categories/csdn/)\n\n附件\n[抓取网页的js](http://jiaolonghuang.github.io/code/run.js)\n[toMarkdown](http://jiaolonghuang.github.io/code/toMD.js)\n",
				"html": "<p>csdn总是在公司打不开，上面的博客不更新了又舍不得扔，便想着迁过来。<br><a id=\"more\"></a></p>\n<p>大致思路：</p>\n<ol>\n<li>csdn里的博客都不能直接导出成md格式的</li>\n<li>hexo的博客是解析markdowwn的</li>\n<li>抓取网页html结构 -&gt; md格式</li>\n</ol>\n<p>工具：</p>\n<ol>\n<li><p>说到网页抓取工具，首先想到的是<a href=\"http://phantomjs.org/\" target=\"_blank\" rel=\"external\">phantomJs</a>, 还有一个<a href=\"http://casperjs.org/\" target=\"_blank\" rel=\"external\">casperjs</a>, 后者是在前者的基础上包装了一层，使用起来更方便。<br>这两个工具使用起来都是与node相似，但是它们又是有自己的环境，独立于node的，基于node的包不可以直接在它们中使用<br>另外，casperjs又是依赖于phantomJs的，也就是说安装casperjs要先安装phantomJs<br>不得不吐槽的是，在环windows上装casperjs太费劲了，各种配环境变量，装python2.7 啥的都不好使，装了2天都没成功，mac上一下就成功了</p>\n</li>\n<li><p>因为在markdown中，有效的标签只有那么几种，而直接抓取下来的网页中标签很杂，因此需要过滤保留几种标签。<br>可以用正则来匹配，但是考虑到嵌套标签，以及里面标签的不可预知性（说白了就是想偷懒），找了一个防xss的node包，<a href=\"https://github.com/leizongmin/js-xss\" target=\"_blank\" rel=\"external\">js-xss</a>, 这个插件里可以指定只保留哪些标签</p>\n</li>\n<li><p>最后就是用<a href=\"https://github.com/domchristie/to-markdown\" target=\"_blank\" rel=\"external\">to-markdwon</a>, 这个包来生成最后md格式的文件</p>\n</li>\n<li><p>由于casperjs的环境和node的环境是独立的，显然这是一个两步走的流程，但是可以使用node中exec方法<code>var exec = require(&#39;child_process&#39;).exec;</code>，来执行命令行命令，这样就把两者结合起来了</p>\n</li>\n</ol>\n<p>问题：<br>毕竟这是工具生成的，再最终的文件中，还是有些地方不那么完美，需要手动再次调整下，但是比起来一个个的粘贴复制，工作量还是小不少。主要问题体现在：</p>\n<ol>\n<li>代码的格式，乱七八糟。。csdn自身展示代码的插件会在有代码的地方生成一些乱七八糟的dom结果</li>\n<li>对md中的关键字符，没有转义，比如星号等</li>\n<li>图片无法抓取保存</li>\n</ol>\n<p>结果<br><a href=\"http://jiaolonghuang.github.io/categories/csdn/\">CSDN旧博客</a></p>\n<p>附件<br><a href=\"http://jiaolonghuang.github.io/code/run.js\">抓取网页的js</a><br><a href=\"http://jiaolonghuang.github.io/code/toMD.js\">toMarkdown</a></p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1446000736000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1446000736000,
				"published_by": 2
			},
			{
				"id": "cj914pnzn003ae0hy8t9fvz87",
				"title": "HTTP2学习(七)—关于HTTP2的Q&A",
				"slug": "http2-qa",
				"markdown": "\n关于**HTTP2的Q&A**，其中在各专门的篇幅中也有插入解释，这里再次集中下。\n<!-- more -->\n\n1. “HTTP1.x的设计的初衷是实现要简单。但是这也是以牺牲性能为代价的”\n比如没有处理并行连接和请求的快捷方法，没有为了减少不必要的请求开销而做优化（首部压缩）等等，这些以至于在页面资源极其丰富的今天，即便我们针对HTTP1.1做了很多HACK优化，然而性能还是没有得到很大的提升。而这些点在HTTP2中都得到了改进。\n\n3. HTTP管道\n这个完全是我翻译水平的问题。哈哈\n\t* **套接字**：是支持TCP/IP网络通信的基本操作单元，可以看成是不同主机之间的进程进行双向通信的端点。是应用进程与tcp连接之间的门，通过套接字口来发送或获得报文。（HTTP2学习4的注释1也有写）。\n\n\t* 其实HTTP管道化就是将客户端的FIFO队列移到了服务端。在客户端可以依次发送所有要发送的请求（当然这些请求是在同一个域下的），一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出。在服务器端维持的FIFO队列，这个队列是按照资源的重要程度排列的。比如HTML比CSS要先返回，JS,CSS比图片先返回。\n\n\t* 在服务器端会有一个缓冲区，来存放那些已经被处理好了但是还没轮到被发送的响应。比如服务器先后收到了A,B两个请求，A资源比B资源优先级要高，处理A需要10ms，处理B需要1ms，假设服务器可以并行处理请求，那么B的响应肯定是最先处理好了的，但是B响应不能先发出去，必须待在缓冲区里，等待A响应处理好了之后，先把A的响应发出去，B的响应才能够被发出去。因为服务端必须要遵循FIFO这个原则。\n\n\t* HTTP管道化不是HTTP2的内容，是对HTTP1.1协议下，服务器不能很好处理并行请求的一个改进。\n\n\t* 管道化的有序和TCP的有序是本质上的不同，管道化的有序，是消息与消息之间的有序。TCP中的有序，组成一个消息的多个报文段之间的有序。打个不太恰当的比方，就好比是A同学吃午餐和B同学吃午餐哪个先吃完饭可以去玩电脑一样，假设是A同学先进食堂，B同学再进食堂，他俩的吃饭速度相同，那么按照FIFO原则，不论是A同学是吃了苹果，梨，米饭，菜，还是B同学只吃了苹果和米饭。虽然B同学是先吃完，他吃的少，但是在管道化中，也还一定是A同学先去玩电脑，B同学跟着。而在TCP中，就好像是在形容，这顿饭，A同学是先吃了苹果，梨，米饭，菜还是先吃了菜，米饭，梨，这样的内部顺序。\n\n\t* 幂等性的请求，实际上就是多次操作都不会改变结果的请求，比如GET，我可以多次从同一个地方获取资源，但是对于资源本身来说并不会发生什么变化，我GET10次和GET100次，资源都没有发生任何变化。而post则不同了，我提交表单10次，和100次，造成的结果是不同的，至少数据库里新增的数据有不同。\n\n\t* 管道做了哪些事，我的理解是创造了一个可以不用等待前一个请求的响应即可发送下一个请求的场所。至于注意些什么，除了知道有些设备不支持，其他的我也没实际经验（毕竟没用过，囧）\n\n4. 多路复用 - 并行（减少因为3次握手而产生的延迟）【和那个keep-】\nkeep-alive，也是可以不进行3次握手就可以发送多个在同一个域下的请求。但是必须发送下一个请求B，等待前一个请求A的响应收到后才可以发送。多路复用和管道优化差不多，只是管道优化由于兼容性的问题，而没有被普遍使用\n\n5. 压缩HTTP首部（降低协议开销）...【哪些被压了？】\n使用了HPACK算法，一方面如果下一次请求头部和上一次请求头部中有相同的字段，那么相同的字段不会被发送，只会被发送差异性的字段。另一方面，会有一张首部表，里面会有常用的首部字段极其对应的序号，会有序号来代替这个具体的字段字符串。同时，整个首部帧还会用哈夫曼编码来进行压缩。\n\n6. ？请求优先级....感觉需要服务器也要支持的节奏（那确实变复杂了）\n是的。也就是说服务器和客户端对这个优先级的理解是一样的，或是达成一致的。\n\n7. ？服务器推送（是双方的么）\n这个双方的是指？？？？\n服务器主动推送一个资源，客户端有权来选择是接收还是不接收，不能‘来者不拒’嘛，是吧。\n\n5. ？相同域名，是值源和目的的域名都必须一样【这样是有原因的：网站本身的特性决定。嗯，能理解】\n可以这么理解。源域名，同一个网站下发出的请求，肯定都是同一个域下的。而这里的相同域名，更多强调的是针对于请求资源所在的地址是在同一个域下的。\n\n8. 但是什么时候断？如果太多的保持连接，会不会反而不好呢\n和一般TCP连接释放一样，如果客户端没有数据要请求，或服务端数据发送完毕后，会主动发送关闭连接的报文。或者是服务端连续发送10个探测报文，客户端无响应，服务端就关闭了这个连接。\n\n9. 相当于在两头：拆分和组装.....疑问是这里的原因是？？为什么要这么折腾呢，原因是？\n“将消息拆成多个数据帧之后，会大大缓解HTTP队首阻塞[注2]的情况。同时，改以帧为传输单位后，使得对报文无论是解析和差错检测方面都变得更加容易，因为对纯文本的解析还需要考虑到空格，空行，换行等问题。另外，也还消除了并行处理和发送请求及响应时对多个连接的依赖。”\n我个人认为第一个原因是最主要的。也有更小更灵活的感觉。\n\n10. 流是双向的.....【那服务器和浏览器间通信的接口们又是什么？】\n这个双向是指，服务器可以给浏览器发消息（server push），浏览器也可以给服务器发东西（这就不用说啦）\n\n6. 多路复用：用一个tcp连接，并行发好多。【...keep_alive 很像啊】\n---分组数？？表示是底层的，都没有概念...按道理说是分帧了后，分组数会变多啊？？？\n和keep_alive 不像，是和管道化很像哈。\n实际上是这样的，首先肯定的是多使用同一个tcp连接，比起以前的多个tcp连接，会至少每次少了3个建立连接的tcp报文段，还不包括重传的。同时因为分帧之后出错的概率变小，间接的需要重传的包变少。从这两方面来说整个网络中的包中的总数是变少的。\n另外呢，tcp报文段的长度其实还是保持不变的，不同流中的帧其实是混在一个tcp报文段中一起被发送，而在接收方那边接受到这个报文段后再进行拆分重新组装成新的http报文。\n\n7. 其他\n就是讲每层的报文的那段，可以：以实例为实例，发送个包：最原始的数据+用户最关心的数据+每层为了额外加的（为了传送、校验等等，以及数据从哪来的-怎么补充进去的）\n讲报文其实主要是为了讲一个大概过程哈，给自己的一个备忘。里面每一层的封装和拆解以及里面的校验都内容都比较多，全讲了，可以讲一个本书了哈哈。这个可以另开专题。\n\n(**最后最后，灰常感谢++滴反馈，让我也思考了下之前没太明白或遗漏的问题。么么哒。**)\n\n",
				"html": "<p>关于<strong>HTTP2的Q&amp;A</strong>，其中在各专门的篇幅中也有插入解释，这里再次集中下。<br><a id=\"more\"></a></p>\n<ol>\n<li><p>“HTTP1.x的设计的初衷是实现要简单。但是这也是以牺牲性能为代价的”<br>比如没有处理并行连接和请求的快捷方法，没有为了减少不必要的请求开销而做优化（首部压缩）等等，这些以至于在页面资源极其丰富的今天，即便我们针对HTTP1.1做了很多HACK优化，然而性能还是没有得到很大的提升。而这些点在HTTP2中都得到了改进。</p>\n</li>\n<li><p>HTTP管道<br>这个完全是我翻译水平的问题。哈哈</p>\n<ul>\n<li><p><strong>套接字</strong>：是支持TCP/IP网络通信的基本操作单元，可以看成是不同主机之间的进程进行双向通信的端点。是应用进程与tcp连接之间的门，通过套接字口来发送或获得报文。（HTTP2学习4的注释1也有写）。</p>\n</li>\n<li><p>其实HTTP管道化就是将客户端的FIFO队列移到了服务端。在客户端可以依次发送所有要发送的请求（当然这些请求是在同一个域下的），一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出。在服务器端维持的FIFO队列，这个队列是按照资源的重要程度排列的。比如HTML比CSS要先返回，JS,CSS比图片先返回。</p>\n</li>\n<li><p>在服务器端会有一个缓冲区，来存放那些已经被处理好了但是还没轮到被发送的响应。比如服务器先后收到了A,B两个请求，A资源比B资源优先级要高，处理A需要10ms，处理B需要1ms，假设服务器可以并行处理请求，那么B的响应肯定是最先处理好了的，但是B响应不能先发出去，必须待在缓冲区里，等待A响应处理好了之后，先把A的响应发出去，B的响应才能够被发出去。因为服务端必须要遵循FIFO这个原则。</p>\n</li>\n<li><p>HTTP管道化不是HTTP2的内容，是对HTTP1.1协议下，服务器不能很好处理并行请求的一个改进。</p>\n</li>\n<li><p>管道化的有序和TCP的有序是本质上的不同，管道化的有序，是消息与消息之间的有序。TCP中的有序，组成一个消息的多个报文段之间的有序。打个不太恰当的比方，就好比是A同学吃午餐和B同学吃午餐哪个先吃完饭可以去玩电脑一样，假设是A同学先进食堂，B同学再进食堂，他俩的吃饭速度相同，那么按照FIFO原则，不论是A同学是吃了苹果，梨，米饭，菜，还是B同学只吃了苹果和米饭。虽然B同学是先吃完，他吃的少，但是在管道化中，也还一定是A同学先去玩电脑，B同学跟着。而在TCP中，就好像是在形容，这顿饭，A同学是先吃了苹果，梨，米饭，菜还是先吃了菜，米饭，梨，这样的内部顺序。</p>\n</li>\n<li><p>幂等性的请求，实际上就是多次操作都不会改变结果的请求，比如GET，我可以多次从同一个地方获取资源，但是对于资源本身来说并不会发生什么变化，我GET10次和GET100次，资源都没有发生任何变化。而post则不同了，我提交表单10次，和100次，造成的结果是不同的，至少数据库里新增的数据有不同。</p>\n</li>\n<li><p>管道做了哪些事，我的理解是创造了一个可以不用等待前一个请求的响应即可发送下一个请求的场所。至于注意些什么，除了知道有些设备不支持，其他的我也没实际经验（毕竟没用过，囧）</p>\n</li>\n</ul>\n</li>\n<li><p>多路复用 - 并行（减少因为3次握手而产生的延迟）【和那个keep-】<br>keep-alive，也是可以不进行3次握手就可以发送多个在同一个域下的请求。但是必须发送下一个请求B，等待前一个请求A的响应收到后才可以发送。多路复用和管道优化差不多，只是管道优化由于兼容性的问题，而没有被普遍使用</p>\n</li>\n<li><p>压缩HTTP首部（降低协议开销）…【哪些被压了？】<br>使用了HPACK算法，一方面如果下一次请求头部和上一次请求头部中有相同的字段，那么相同的字段不会被发送，只会被发送差异性的字段。另一方面，会有一张首部表，里面会有常用的首部字段极其对应的序号，会有序号来代替这个具体的字段字符串。同时，整个首部帧还会用哈夫曼编码来进行压缩。</p>\n</li>\n<li><p>？请求优先级….感觉需要服务器也要支持的节奏（那确实变复杂了）<br>是的。也就是说服务器和客户端对这个优先级的理解是一样的，或是达成一致的。</p>\n</li>\n<li><p>？服务器推送（是双方的么）<br>这个双方的是指？？？？<br>服务器主动推送一个资源，客户端有权来选择是接收还是不接收，不能‘来者不拒’嘛，是吧。</p>\n</li>\n<li><p>？相同域名，是值源和目的的域名都必须一样【这样是有原因的：网站本身的特性决定。嗯，能理解】<br>可以这么理解。源域名，同一个网站下发出的请求，肯定都是同一个域下的。而这里的相同域名，更多强调的是针对于请求资源所在的地址是在同一个域下的。</p>\n</li>\n<li><p>但是什么时候断？如果太多的保持连接，会不会反而不好呢<br>和一般TCP连接释放一样，如果客户端没有数据要请求，或服务端数据发送完毕后，会主动发送关闭连接的报文。或者是服务端连续发送10个探测报文，客户端无响应，服务端就关闭了这个连接。</p>\n</li>\n<li><p>相当于在两头：拆分和组装…..疑问是这里的原因是？？为什么要这么折腾呢，原因是？<br>“将消息拆成多个数据帧之后，会大大缓解HTTP队首阻塞[注2]的情况。同时，改以帧为传输单位后，使得对报文无论是解析和差错检测方面都变得更加容易，因为对纯文本的解析还需要考虑到空格，空行，换行等问题。另外，也还消除了并行处理和发送请求及响应时对多个连接的依赖。”<br>我个人认为第一个原因是最主要的。也有更小更灵活的感觉。</p>\n</li>\n<li><p>流是双向的…..【那服务器和浏览器间通信的接口们又是什么？】<br>这个双向是指，服务器可以给浏览器发消息（server push），浏览器也可以给服务器发东西（这就不用说啦）</p>\n</li>\n<li><p>多路复用：用一个tcp连接，并行发好多。【…keep_alive 很像啊】<br>—分组数？？表示是底层的，都没有概念…按道理说是分帧了后，分组数会变多啊？？？<br>和keep_alive 不像，是和管道化很像哈。<br>实际上是这样的，首先肯定的是多使用同一个tcp连接，比起以前的多个tcp连接，会至少每次少了3个建立连接的tcp报文段，还不包括重传的。同时因为分帧之后出错的概率变小，间接的需要重传的包变少。从这两方面来说整个网络中的包中的总数是变少的。<br>另外呢，tcp报文段的长度其实还是保持不变的，不同流中的帧其实是混在一个tcp报文段中一起被发送，而在接收方那边接受到这个报文段后再进行拆分重新组装成新的http报文。</p>\n</li>\n<li><p>其他<br>就是讲每层的报文的那段，可以：以实例为实例，发送个包：最原始的数据+用户最关心的数据+每层为了额外加的（为了传送、校验等等，以及数据从哪来的-怎么补充进去的）<br>讲报文其实主要是为了讲一个大概过程哈，给自己的一个备忘。里面每一层的封装和拆解以及里面的校验都内容都比较多，全讲了，可以讲一个本书了哈哈。这个可以另开专题。</p>\n</li>\n</ol>\n<p>(<strong>最后最后，灰常感谢++滴反馈，让我也思考了下之前没太明白或遗漏的问题。么么哒。</strong>)</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1440140390000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1440140390000,
				"published_by": 2
			},
			{
				"id": "cj914pnzp003ee0hyqzg81nz9",
				"title": "HTTP2学习(六)—HTTP2性能优化实践",
				"slug": "http2vshttp1.1",
				"markdown": "\n为了让我们的网站访问速度快变，我们不断增加带宽，做针对HTTP协议的特点对应用做各种优化。希望能通常高带宽，低延迟来提高网站到访问速度。带宽与延迟两者间，延迟才是性能的真正瓶颈。\n<!-- more -->\n\n## 客观原因\n当我们针对HTTP协议进行性能优化时，我们不得不注意到这样的一些客观原因。通常当我们改变不了底层协议特性时，我们只能在更高层处做文章。\n\n1. 带宽受物理层介质的影响，最快快不过光速，但是即便在今天越来越高的带宽，我们依然没有感觉到网站访问速度有多快。\n<img src=\"\" />\n\n2. 延迟包括传输延迟，传播延迟，处理延迟和排队延迟。\n\n1. 每次连接都需要经过3次握手才能建立，增加整整一个RTT。\n\n2. TCP拥塞控制策略：慢启动，拥塞避免[注1]。其中慢启动会被应用到每一个连接中。TCP流量和拥塞控制会影响整个网络到吞吐量。\n\n3. 解析DNS必然会产生一些延迟。\n\n4. 最快获得资源的方式，莫过于还没传，就已拿到。充分利用缓存。\n\n5. 最少的延迟就是什么都不传。而没有延迟。\n\n\n## 针对HTTP1.X做过的优化\n由于TCP层的特性，在提高web性能时，我们不得不做一些优化，\n[Best Practices for Speeding Up Your Web Site](https://developer.yahoo.com/performance/rules.html)，这些优化中针对HTTP协议特点的，我们做了哪些呢，从总体来说有以下几大点。\n\n* 连接和拼接\n\n\t连接或拼接JS和CSS文件，雪碧图，以减少HTTP请求，同时浏览器可缓存这些静态资源，为下次访问节约时间。但是这样带来的副作用是，维护成本高，其中某一个小改动都会使得整个拼接后的文件发生改变，重新缓存。\n\n* 域名分区\n\n\t由于浏览器的限制，同一个域下最多只能建立6个连接。我们通常使用子域名来减少所有资源在只有一个连接时的产生的排队延迟。这个显然不适用在HTTP2中，因为不同的域需要建立不同的连接。\n\n* 资源内嵌\n\n\t对于不常用的，较小大资源内嵌在文档中，比如base64的图片，以减少HTTP请求，但是这样的资源不能在浏览器中缓存，也不可能被其他页面共享，同时还有可能编码之后的资源变等更大了。在HTTP2中，这样的资源就可以使用SERVER PUSH来推送。\n\t\n* HTTP管道（额外的）\n\t\n\t在HTTP1.x中已经实现了持久连接，但是却依然需要排队来发送和接收请求，这样不能充分利用网络资源。因此提出了HTTP管道的概念。客户端可以将所有请求都一起发给服务器端，服务器端或者按顺序处理，或者并行处理这些请求。但是返回响应的顺序是按照其自己内部的优先级来的。\n\t\n\t但是，其缺点也很多，以至于现在的浏览器对它还是默认关闭的：\n\t1. 队首阻塞\n\t2. 并行处理时，需要占用缓存资源，服务器容易受到攻击\n\t3. 响应失败后，会断开tcp连接，并要求重发之后的所有请求，造成资源浪费\n\t4. 中间代理对其兼容性不是很好，有可能还会串行所有请求\n\t\n## 针对HTTP2需要做的优化\n* 坚决去掉在HTTP1.X中的域名分区，连接和拼接和资源内嵌的优化方式。\n* 尽量让所有资源在同一域名下\n* 利用服务器推送\n* 继续保留CDN\n\n一切都已返璞归真\n\n## 注\n* TCP慢开始与拥塞避免示意图\n<img src=\"/img/http2/slow-start.png\" alt=\"\">\n\n## 参考\n1. [HTTP2.0的奇妙日常](http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/)\n2. [HTTP请求的TCP瓶颈分析](https://bhsc881114.github.io/2015/06/23/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84TCP%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/)\n3. [Http 2.0协议简介](http://www.jdon.com/dl/http2.html)\n\t",
				"html": "<p>为了让我们的网站访问速度快变，我们不断增加带宽，做针对HTTP协议的特点对应用做各种优化。希望能通常高带宽，低延迟来提高网站到访问速度。带宽与延迟两者间，延迟才是性能的真正瓶颈。<br><a id=\"more\"></a></p>\n<h2 id=\"客观原因\"><a href=\"#客观原因\" class=\"headerlink\" title=\"客观原因\"></a>客观原因</h2><p>当我们针对HTTP协议进行性能优化时，我们不得不注意到这样的一些客观原因。通常当我们改变不了底层协议特性时，我们只能在更高层处做文章。</p>\n<ol>\n<li><p>带宽受物理层介质的影响，最快快不过光速，但是即便在今天越来越高的带宽，我们依然没有感觉到网站访问速度有多快。<br><img src=\"\"></p>\n</li>\n<li><p>延迟包括传输延迟，传播延迟，处理延迟和排队延迟。</p>\n</li>\n<li><p>每次连接都需要经过3次握手才能建立，增加整整一个RTT。</p>\n</li>\n<li><p>TCP拥塞控制策略：慢启动，拥塞避免[注1]。其中慢启动会被应用到每一个连接中。TCP流量和拥塞控制会影响整个网络到吞吐量。</p>\n</li>\n<li><p>解析DNS必然会产生一些延迟。</p>\n</li>\n<li><p>最快获得资源的方式，莫过于还没传，就已拿到。充分利用缓存。</p>\n</li>\n<li><p>最少的延迟就是什么都不传。而没有延迟。</p>\n</li>\n</ol>\n<h2 id=\"针对HTTP1-X做过的优化\"><a href=\"#针对HTTP1-X做过的优化\" class=\"headerlink\" title=\"针对HTTP1.X做过的优化\"></a>针对HTTP1.X做过的优化</h2><p>由于TCP层的特性，在提高web性能时，我们不得不做一些优化，<br><a href=\"https://developer.yahoo.com/performance/rules.html\" target=\"_blank\" rel=\"external\">Best Practices for Speeding Up Your Web Site</a>，这些优化中针对HTTP协议特点的，我们做了哪些呢，从总体来说有以下几大点。</p>\n<ul>\n<li><p>连接和拼接</p>\n<p>  连接或拼接JS和CSS文件，雪碧图，以减少HTTP请求，同时浏览器可缓存这些静态资源，为下次访问节约时间。但是这样带来的副作用是，维护成本高，其中某一个小改动都会使得整个拼接后的文件发生改变，重新缓存。</p>\n</li>\n<li><p>域名分区</p>\n<p>  由于浏览器的限制，同一个域下最多只能建立6个连接。我们通常使用子域名来减少所有资源在只有一个连接时的产生的排队延迟。这个显然不适用在HTTP2中，因为不同的域需要建立不同的连接。</p>\n</li>\n<li><p>资源内嵌</p>\n<p>  对于不常用的，较小大资源内嵌在文档中，比如base64的图片，以减少HTTP请求，但是这样的资源不能在浏览器中缓存，也不可能被其他页面共享，同时还有可能编码之后的资源变等更大了。在HTTP2中，这样的资源就可以使用SERVER PUSH来推送。</p>\n</li>\n<li><p>HTTP管道（额外的）</p>\n<p>  在HTTP1.x中已经实现了持久连接，但是却依然需要排队来发送和接收请求，这样不能充分利用网络资源。因此提出了HTTP管道的概念。客户端可以将所有请求都一起发给服务器端，服务器端或者按顺序处理，或者并行处理这些请求。但是返回响应的顺序是按照其自己内部的优先级来的。</p>\n<p>  但是，其缺点也很多，以至于现在的浏览器对它还是默认关闭的：</p>\n<ol>\n<li>队首阻塞</li>\n<li>并行处理时，需要占用缓存资源，服务器容易受到攻击</li>\n<li>响应失败后，会断开tcp连接，并要求重发之后的所有请求，造成资源浪费</li>\n<li>中间代理对其兼容性不是很好，有可能还会串行所有请求</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"针对HTTP2需要做的优化\"><a href=\"#针对HTTP2需要做的优化\" class=\"headerlink\" title=\"针对HTTP2需要做的优化\"></a>针对HTTP2需要做的优化</h2><ul>\n<li>坚决去掉在HTTP1.X中的域名分区，连接和拼接和资源内嵌的优化方式。</li>\n<li>尽量让所有资源在同一域名下</li>\n<li>利用服务器推送</li>\n<li>继续保留CDN</li>\n</ul>\n<p>一切都已返璞归真</p>\n<h2 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h2><ul>\n<li>TCP慢开始与拥塞避免示意图<br><img src=\"/img/http2/slow-start.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/\" target=\"_blank\" rel=\"external\">HTTP2.0的奇妙日常</a></li>\n<li><a href=\"https://bhsc881114.github.io/2015/06/23/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84TCP%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"external\">HTTP请求的TCP瓶颈分析</a></li>\n<li><a href=\"http://www.jdon.com/dl/http2.html\" target=\"_blank\" rel=\"external\">Http 2.0协议简介</a></li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1439825210000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1439825210000,
				"published_by": 2
			},
			{
				"id": "cj914pnzm0037e0hy4kz2dvw4",
				"title": "HTTP2学习(五)—HTTP2 VS SPDY",
				"slug": "http2&spdy",
				"markdown": "\nSPDY是HTTP2的催化剂，但SPDY不是HTTP2。\n<!-- more -->\n本文主要针对SPDY与HTTP2之间的区别，而不太多的涉及它俩之间与HTTP1.X的区别。\n\n## SPDY的出现\nSPDY是谷歌在09年年中时发布的，它的主要目标时通过解决HTTP1.1中一些显著的性能限制，来减少网页额的加载时间。目前为止，Chrome,Firefox和Opera都支持了这一协议。\n\nSPDY引入了新的二进制分帧层，以实现多路复用、优先次序、最小化的消除网络延迟，同时对HTTP首部进行压缩，减少HTTP报文的冗余数据。\n\n>目前为止，我们只在实验室条件下测试过 SPDY。最初的成果很激动人心：通过模拟的家庭上网线路下载了 25 个最流行的网站之后，我们发现性能的改进特别明显，页面加载速度最多快了 55%。\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t——A 2x Faster Web Chromium Blog\n\n一方面由于随着web应用的发展，HTTP1.1协议的局限性突显的越来越严重，另一方面由于SPDY的优秀表现，12年初，W3C向全社会征集HTTP2的建议，最终决定将SPDY规范作为制定标准的基础。\n\n随后的时间内，SPDY与HTTP2共同进化，HTTP2提出新规范或新功能，SPDY为它进行测试和验证。当HTTP2一切就绪之日，就是SPDY退出舞台之时。事实上，在今年2月谷歌公司已经宣布将在16年年初放弃对SPDY的支持。\n\n目前各浏览器对SPDY和HTTP2的支持情况分别如下:\n<img src=\"/img/http2/spdy-caniuse.png\" alt=\"\">\n<img src=\"/img/http2/http2-caniuse.png\" alt=\"\">\n\n## SPDY与HTTP2的区别\n* 头部压缩算法，SPDY，通用的deflate算法[注1]；HTTP2，专门为压缩头部设计的HPACK算法\n* SPDY必须在TLS上运行，HTTP2可在TCP上直接使用，因为增加了HTTP1.1的Upgrade机制\n* 更加完善的协议商讨和确认流程\n* 更加完善的Server Push流程\n* 增加控制帧的种类，并对帧的格式考虑的更细致\n\n## 注\n1. deflate算法\n这个算法是由2个算法组合而成，哈夫曼编码和LZ77编码。\n\n**哈夫曼编码**\n一种无前缀编码，简单来说就是长字符串用短编码表示，以最终达到减少总大小的目的。具体编码过程可参考[Huffman 编码压缩算法](http://coolshell.cn/articles/7459.html)\n\n例如，在一篇英语文章中，字母“E”出现的频率最高，“Z”最低，如果我们采用字符编码，那么每一个字母都是8bit表示；但是如果，我们使用不定长的bit编码，频率高的字母用比较短的编码表示，频率低的字母用长的编码表示，就会大大缩小文件的空间。\n```\n字符编码\nA00101001\nB00101010\nC00101011……\n哈夫曼编码\nA\t0\nB\t10\nC\t110\nD\t1110\nE\t11110\n```\n\n大致思路：每次总是选取频率最小两个节点，将其频率相加，最终构成一个最优二叉树。\n例如：有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1,那么我们第一步先取两个最小权值作为左右子树构造一个新树，即取1，2构成新树，其结点为1+2=3\n<img src=\"/img/http2/hfm-1.png\" alt=\"\">\n虚线为新生成的结点，第二步再把新生成的权值为3的结点放到剩下的集合中，所以集合变成{5,4,3,3}，再根据第二步，取最小的两个权值构成新树，如图：\n<img src=\"/img/http2/hfm-2.png\" alt=\"\">\n再依次建立哈夫曼树:\n<img src=\"/img/http2/hfm-3.png\" alt=\"\">\n其中各个权值替换对应的字符即为下图:\n<img src=\"/img/http2/hfm-4.png\" alt=\"\">\n所以各字符对应的编码为：A->11,B->10,C->00,D->011,E->010\n\n**LZ77编码** \n字典压缩算法,用到的场景比如gzip。具体算法可[参考,须翻墙](https://www.youtube.com/watch?v=dxlOFcnGE-w)\n\n这个算法的主要思想是：文件中有两块内容相同的话，那么只要知道前一块的位置和大小，我们就可以确定后一块的内容。所以我们可以用（两者之间的距离，相同内容的长度）这样一对信息，来替换后一块内容。由于（两者之间的距离，相同内容的长度）这一对信息的大小，小于被替换内容的大小，所以文件得到了压缩。\n\n大致流程如下：\n可构想出2个窗口，一个作为搜索缓存区（已完成搜索的字符），一个作为待搜索窗口。如下图\n<img src=\"/img/http2/lz77.jpg\" alt=\"\">\n\n编码过程：\n* 如果待搜索字符c没在搜索缓存区中找到，则输出(0,0,c),同时，整个窗口向前移动1位\n* 如果待搜索字符c在搜索缓存区中找到，起始位置在搜索缓存区中x，连续长度是offset，待搜索窗口中offset之后的一个字符是d，则输出(x, offset, d)。之后，整个窗口向前移动offset位。\n* 最终输出的三元组就是压缩码\n\n<img src=\"/img/http2/lz77-1.png\" alt=\"\">\n\n解码过程：\n<img src=\"/img/http2/lz77-2.png\" alt=\"\">\n\n## 参考\n1. [哈夫曼树与哈夫曼编码](http://www.cnblogs.com/Jezze/archive/2011/12/23/2299884.html)\n\n",
				"html": "<p>SPDY是HTTP2的催化剂，但SPDY不是HTTP2。<br><a id=\"more\"></a><br>本文主要针对SPDY与HTTP2之间的区别，而不太多的涉及它俩之间与HTTP1.X的区别。</p>\n<h2 id=\"SPDY的出现\"><a href=\"#SPDY的出现\" class=\"headerlink\" title=\"SPDY的出现\"></a>SPDY的出现</h2><p>SPDY是谷歌在09年年中时发布的，它的主要目标时通过解决HTTP1.1中一些显著的性能限制，来减少网页额的加载时间。目前为止，Chrome,Firefox和Opera都支持了这一协议。</p>\n<p>SPDY引入了新的二进制分帧层，以实现多路复用、优先次序、最小化的消除网络延迟，同时对HTTP首部进行压缩，减少HTTP报文的冗余数据。</p>\n<blockquote>\n<p>目前为止，我们只在实验室条件下测试过 SPDY。最初的成果很激动人心：通过模拟的家庭上网线路下载了 25 个最流行的网站之后，我们发现性能的改进特别明显，页面加载速度最多快了 55%。<br>                                                                ——A 2x Faster Web Chromium Blog</p>\n</blockquote>\n<p>一方面由于随着web应用的发展，HTTP1.1协议的局限性突显的越来越严重，另一方面由于SPDY的优秀表现，12年初，W3C向全社会征集HTTP2的建议，最终决定将SPDY规范作为制定标准的基础。</p>\n<p>随后的时间内，SPDY与HTTP2共同进化，HTTP2提出新规范或新功能，SPDY为它进行测试和验证。当HTTP2一切就绪之日，就是SPDY退出舞台之时。事实上，在今年2月谷歌公司已经宣布将在16年年初放弃对SPDY的支持。</p>\n<p>目前各浏览器对SPDY和HTTP2的支持情况分别如下:<br><img src=\"/img/http2/spdy-caniuse.png\" alt=\"\"><br><img src=\"/img/http2/http2-caniuse.png\" alt=\"\"></p>\n<h2 id=\"SPDY与HTTP2的区别\"><a href=\"#SPDY与HTTP2的区别\" class=\"headerlink\" title=\"SPDY与HTTP2的区别\"></a>SPDY与HTTP2的区别</h2><ul>\n<li>头部压缩算法，SPDY，通用的deflate算法[注1]；HTTP2，专门为压缩头部设计的HPACK算法</li>\n<li>SPDY必须在TLS上运行，HTTP2可在TCP上直接使用，因为增加了HTTP1.1的Upgrade机制</li>\n<li>更加完善的协议商讨和确认流程</li>\n<li>更加完善的Server Push流程</li>\n<li>增加控制帧的种类，并对帧的格式考虑的更细致</li>\n</ul>\n<h2 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h2><ol>\n<li>deflate算法<br>这个算法是由2个算法组合而成，哈夫曼编码和LZ77编码。</li>\n</ol>\n<p><strong>哈夫曼编码</strong><br>一种无前缀编码，简单来说就是长字符串用短编码表示，以最终达到减少总大小的目的。具体编码过程可参考<a href=\"http://coolshell.cn/articles/7459.html\" target=\"_blank\" rel=\"external\">Huffman 编码压缩算法</a></p>\n<p>例如，在一篇英语文章中，字母“E”出现的频率最高，“Z”最低，如果我们采用字符编码，那么每一个字母都是8bit表示；但是如果，我们使用不定长的bit编码，频率高的字母用比较短的编码表示，频率低的字母用长的编码表示，就会大大缩小文件的空间。<br><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">字符编码</div><div class=\"line\"><span class=\"keyword\">A</span><span class=\"number\">00101001</span></div><div class=\"line\">B<span class=\"number\">00101010</span></div><div class=\"line\">C<span class=\"number\">00101011</span>……</div><div class=\"line\">哈夫曼编码</div><div class=\"line\"><span class=\"keyword\">A</span>\t<span class=\"number\">0</span></div><div class=\"line\">B\t<span class=\"number\">10</span></div><div class=\"line\">C\t<span class=\"number\">110</span></div><div class=\"line\">D\t<span class=\"number\">1110</span></div><div class=\"line\">E\t<span class=\"number\">11110</span></div></pre></td></tr></table></figure></p>\n<p>大致思路：每次总是选取频率最小两个节点，将其频率相加，最终构成一个最优二叉树。<br>例如：有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1,那么我们第一步先取两个最小权值作为左右子树构造一个新树，即取1，2构成新树，其结点为1+2=3<br><img src=\"/img/http2/hfm-1.png\" alt=\"\"><br>虚线为新生成的结点，第二步再把新生成的权值为3的结点放到剩下的集合中，所以集合变成{5,4,3,3}，再根据第二步，取最小的两个权值构成新树，如图：<br><img src=\"/img/http2/hfm-2.png\" alt=\"\"><br>再依次建立哈夫曼树:<br><img src=\"/img/http2/hfm-3.png\" alt=\"\"><br>其中各个权值替换对应的字符即为下图:<br><img src=\"/img/http2/hfm-4.png\" alt=\"\"><br>所以各字符对应的编码为：A-&gt;11,B-&gt;10,C-&gt;00,D-&gt;011,E-&gt;010</p>\n<p><strong>LZ77编码</strong><br>字典压缩算法,用到的场景比如gzip。具体算法可<a href=\"https://www.youtube.com/watch?v=dxlOFcnGE-w\" target=\"_blank\" rel=\"external\">参考,须翻墙</a></p>\n<p>这个算法的主要思想是：文件中有两块内容相同的话，那么只要知道前一块的位置和大小，我们就可以确定后一块的内容。所以我们可以用（两者之间的距离，相同内容的长度）这样一对信息，来替换后一块内容。由于（两者之间的距离，相同内容的长度）这一对信息的大小，小于被替换内容的大小，所以文件得到了压缩。</p>\n<p>大致流程如下：<br>可构想出2个窗口，一个作为搜索缓存区（已完成搜索的字符），一个作为待搜索窗口。如下图<br><img src=\"/img/http2/lz77.jpg\" alt=\"\"></p>\n<p>编码过程：</p>\n<ul>\n<li>如果待搜索字符c没在搜索缓存区中找到，则输出(0,0,c),同时，整个窗口向前移动1位</li>\n<li>如果待搜索字符c在搜索缓存区中找到，起始位置在搜索缓存区中x，连续长度是offset，待搜索窗口中offset之后的一个字符是d，则输出(x, offset, d)。之后，整个窗口向前移动offset位。</li>\n<li>最终输出的三元组就是压缩码</li>\n</ul>\n<p><img src=\"/img/http2/lz77-1.png\" alt=\"\"></p>\n<p>解码过程：<br><img src=\"/img/http2/lz77-2.png\" alt=\"\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://www.cnblogs.com/Jezze/archive/2011/12/23/2299884.html\" target=\"_blank\" rel=\"external\">哈夫曼树与哈夫曼编码</a></li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1439804570000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1439804570000,
				"published_by": 2
			},
			{
				"id": "cj914pnzo003ce0hy64qfmldv",
				"title": "HTTP2学习(四)—HTTP2的新特性",
				"slug": "http2",
				"markdown": "\nHTTP2可以让我们的应用变得更快、更简单、更健壮，让我们在HTTP1.1时针对TCP协议特性而做的用来提高性能的HACK一笔勾销。\n<!-- more -->\n\n## 总览\n\n为了提高应用的性能，降低延迟，我们能做的无外乎2点，要么传输的东西越小越好，要么距离能获得资源的地方越近越好。\n\n这个就好比说是运动员赛跑，为了最先到达终点，在相同的速度下，当然是离终点越近，用时会越短；另一方面，在距离相等的情况下，当然是降低自上多余的重量，让速度越快越好，这也是为什么短跑运动员穿紧身运动服，鞋带都要藏起来的原因，为了最大限度的降低在空气中的阻力，提高速度。\n\n实际上无论是针对HTTP的哪个版本我们所做的性能优化，也都是针对这两点所作出的改进。\n\nHTTP2的目的：通过支持**多路复用**来提高并行能力，减少因为3次握手等而产生的延迟；通过**压缩HTTP首部**将协议开销降到最低，同时支持请求优先级和服务器推送。\n\nHTTP2最大的改变：引入**二进制分帧层**。HTTP2不会改动HTTP1.x的语义，提供的功能也不变，但是HTTP2对内修改了格式化数据的方式，以及传输这些数据的方式。对外，也就是面向应用，不用做任何改变，感知不到这一层的变化的。\n\n其实HTTP2是对HTTP1.x的一个扩展，而非替代，之所以称之为2是因为它引入的二进制分帧层之前的HTTP1.x的服务端和客户端并不兼容。\n\n## 新特性浅析\n\n### 二进制分帧层\n这是HTTP2中最大的改变。HTTP2之所以性能会比HTTP1.x有那么大的提高，很大程度上正是由于这一层的引入。\n\n> 这里所谓的“层” ，指的是位于套接字接口(注1)与应用可见的高层HTTP API之间的一个新机制:HTTP的语义，包括各种动词、方法、首部，都不受影响，不同的是**传输期间**对它们的编码方式变了。\n\nHTTP1.x用回车换行符作为纯文本的分隔符，在进行解析和差错检测时不方便。HTTP1.x中用ASCII码，是16进制的，来表示报文中的每一个字符，如下图中,47代表字母G，45代表字符E，54代表字符T。\n<img src=\"http://p8.qhimg.com/d/inn/2bc21b16/http-header.png\" alt=\"\">\n然而，HTTP2引入分帧层后，将报文分隔成一个个更小的帧，并采用二进制编码的方式。通常会将一个消息（首部和数据在一起的）分成一个HEADER帧和若干个DATA帧。如下图所示\n<img src=\"/img/http2/frame-layer.png\" alt=\"\">\n\n另外需要明确的几个定义：\n**流**：已建立的连接上的双向字节流。具有唯一的流ID，客户端发起的为奇数ID，服务端发起的为偶数ID。很多个流可以并行的在同一个tcp连接上交换消息。\n**消息**：与逻辑消息对应，比如一个请求或一个响应。由一个或多个帧组成。\n**帧**：HTTP2中最小的通信单位，每个帧都会有帧首部，每个帧或者用来承载HTTP首部或负荷数据，或其他特定类型的帧。帧是遵循二进制编码的。\n\n总得来说，就是这样的，在HTTP2中，相同域名下的所有通信都在一个连接上完成，这个连接中可以承载任意数量的双向流。这些流都是以消息的形式被发送的，同时消息又由一个或多个帧组成。多个帧之间可以乱序发送，最后根据帧首部的流标识重新组装。\n\n**解释**\n这个双向是指，服务器可以给浏览器发消息（server push），浏览器也可以给服务器发东西（这就不用说啦）\n\n对于一个帧来说，有固定固定帧格式，其中帧首部规定了帧最多只能带64KB的数据，还包括了帧类型和流标识符等。另外，帧中还可以填充一些额外的数据，最多255字节，保证数据安全性，拿HEADER帧举例。\n<img src=\"/img/http2/frame-structure.png\" alt=\"\">\n<img src=\"/img/http2/frame-header.png\" alt=\"\">\n\n从这点上看，HTTP2中的帧与tcp报文段有些相似的。\n\n在客户端或服务端发起建立新流时，帧携带HTTP的首部块，其中服务端发起流时，发送的HEADER帧没有优先级这一字段；当新流建立之后，就可发送HTTP消息的应用数据，也就是帧的负荷数据。\n\n将消息拆成多个数据帧之后，会大大缓解HTTP队首阻塞[注2]的情况。但是与tcp层的队首阻塞[注3]并无直接关系。同时，改以帧为传输单位后，使得对报文无论是解析和差错检测方面都变得更加容易，因为对纯文本的解析还需要考虑到空格，空行，换行等问题。另外，也还消除了并行处理和发送请求及响应时对多个连接的依赖。\n\n**解释**\n多路复用：用一个tcp连接，并行发好多。【...keep_alive 很像啊】\n---分组数？？表示是底层的，都没有概念...按道理说是分帧了后，分组数会变多啊？？？\n和keep_alive 不像，是和管道化很像哈。\n实际上是这样的，首先肯定的是多使用同一个tcp连接，比起以前的多个tcp连接，会至少每次少了3个建立连接的tcp报文段，还不包括重传的。同时因为分帧之后出错的概率变小，间接的需要重传的包变少。从这两方面来说整个网络中的包中的总数是变少的。\n另外呢，tcp报文段的长度其实还是保持不变的，不同流中的帧其实是混在一个tcp报文段中一起被发送，而在接收方那边接受到这个报文段后再进行拆分重新组装成新的http报文。\n\n### 首部压缩\n\n由于HTTP协议是一种无状态的协议，服务器自身不会保存太多的信息和先前请求过的元数据信息，这就需要客户端每次都使用多个首部字段来描述所传输的资源及其属性，又由于HTTP1.1是以文本形式传输的，每次都会给HTTP报文增加500-800字节的负荷，如果算上cookie，这个负荷甚至会增加到上千。如果可以有办法减少这些开销，那么对性能又有很大的提升。\n\nHTTP2采用HPACK压缩方法，一边用index mapping table压缩，一边编码。这个table由[静态表](https://http2.github.io/http2-spec/compression.html#static.table.definition)和动态表组成。\n1. 先用预定义的index mapping table将头部中常用的字符串用index来代替\n2. 对一定要使用文本表示的字符串，采用预定义的哈夫曼编码表进行编码\n(具体的压缩和解压缩的方法请看[参考4](http://www.cnblogs.com/ghj1976/p/4586529.html)的解释)\n\n\n* 客户端和服务器端使用首部表来跟踪和存储之前发送的每一个键值对。第一次请求时发送过的键值对，第二次在再请求时就不在发送了。（这一现象还一直没观察到）\n* 在tcp连接期间，客户端和服务端共同维护这个首部表，并且是共同渐进更新的\n* 每个新的键值对，要么直接添加到首部表尾部，要么替换原有表中的值\n\n另外，HTTP2的前身SPDY采用的头部压缩算法是delate算法，这个算法的压缩效率也不错，但是由于存在[CRIME攻击](http://www.freebuf.com/articles/web/5636.html)，而HTTP2不得不重新设计了HPACK算法。\n\n**解释**\n使用了HPACK算法，一方面如果下一次请求头部和上一次请求头部中有相同的字段，那么相同的字段不会被发送，只会被发送差异性的字段。另一方面，会有一张首部表，里面会有常用的首部字段极其对应的序号，会有序号来代替这个具体的字段字符串。同时，整个首部帧还会用哈夫曼编码来进行压缩。\n\n### 多路复用\n\n引入二进制分帧层之后，HTTP2可以很容易的去实现多流并行而不用依赖建立多个tcp连接。\n\n>实验表明，客户端使用更少的连接肯定可以降低延迟时间。HTTP 2.0 发送的总分组数量比 HTTP 差不多要少 40%。而服务器处理大量并发连接的情况也变成了可伸缩性问题，因为 HTTP 2.0 减轻了这个负担。               ----HTTP2.0\n\n每个来源使用一个连接，优势如下：\n* 从服务器和客户端来说，占用的资源和内存都少了。\n* 从tcp连接和网络来说，使得网络拥塞得到改善，慢启动时间减少，拥塞和丢包恢复速度变快。\n\n**解释**\n* keep-alive，也是可以不进行3次握手就可以发送多个在同一个域下的请求。但是必须发送下一个请求B，等待前一个请求A的响应收到后才可以发送。多路复用和管道优化差不多，只是管道优化由于兼容性的问题，而没有被普遍使用。\n\n* 但是什么时候断？如果太多的保持连接，会不会反而不好呢\n和一般TCP连接释放一样，如果客户端没有数据要请求，或服务端数据发送完毕后，会主动发送关闭连接的报文。或者是服务端连续发送10个探测报文，客户端无响应，服务端就关闭了这个连接。\n\n### 请求优先级\n\n当同一条连接上可以同时发送很多请求时，并不等于说这些请求对于服务器来说都应该一视同仁，因为客户端对资源的需求程度不同。比如说一个html文档，显然客户端对CSS和JS的需求，远大于对文档内图片的需求。\n\n因此在建立新流时，HEADER帧可以带有一个优先级(31位，0为优先级最高)的值。这样，服务端就可以因此而适当分配资源，优先发送这些优先级高的帧。\n\nHTTP2协议并没有规定这样的处理优先级的算法该如何实现，仅仅只是提供了这样一种机制。\n\n为了合理充分利用网络资源，服务器也应该交错处理不同优先级的帧。而不是严格按照优先级来处理，否则又会造成队首堵塞的情况。\n\n**解释**\n？请求优先级....感觉需要服务器也要支持的节奏（那确实变复杂了）\n是的。也就是说服务器和客户端对这个优先级的理解是一样的，或是达成一致的。\n\n### 服务器推送\n\n说到服务器推送，其实在HTTP1.1时，我们就用到过类似的，比如将图片使用base64编码嵌入在文档中。\n\n之所以要提供这个服务，是因为一个文档被请求回来时，往往还需要再次请求很多文档内的其他资源，如果这些资源的请求不用客户端发起，而是服务端提前预判发给客户端，那么就会减少一半的RTT。\n\nHTTP2这个协议也没有规定服务器端到底该怎样推送这个资源。服务端可以自己制定不同的策略，可以是根据客户端明确写出的推送请求；或者是服务端通过学习得来；再或者是通过额外的HTTP首部想服务端表明意向。\n\n这个服务的特点是：\n* 只有建立连接后，服务器才可以推送资源(发送PUSH_PROMISE帧，这个帧中只有要约的HTTP首部)，也就是说服务器不能无缘无故的主动向客户端推送资源\n* 客户端可以发送RST_STREAM拒绝服务器推送来的资源。但是这可能存在一个时间差，而导致客户端明明已经拒绝了，但服务端却还是把资源推送了过来。\n* 推送的资源可以有不同页面共享\n* 服务器可以按照优先级来推送资源\n\n**解释**\n服务器主动推送一个资源，客户端有权来选择是接收还是不接收，不能‘来者不拒’嘛，是吧。\n\n### 流量控制\n\n我们知道在HTTP2协议中，我们可以在同一个连接中，建立多个流，那么实际上这些流之间是相互竞争的，会相互争夺这个连接中资源的分配。此时与tcp流量控制相似，我们也需要对流中的帧进行流量控制。但只有DATA帧受流量控制，而其他类型的帧不受流量控制。同样，HTTP2也只提供了这样一种机制，而非具体实现。\n\n* 这个流量控制在没一跳之间进行，而非端到端\n* 流量控制基于窗口更新帧。连接建立之初，通过交换settings帧，来设定双向的流量控制窗口大小。\n* 发送端每发送一个DATA帧，就将window的值减去这次data帧的大小，直到window=0。\n* 接收方可通过发送window_update 帧。如果接收方不想接受数据了，就不发送window _update帧。\n* 在接受关键资源时，可将非关键资源的window设置的非常小，等网络空闲了，再改回大一些。\n\n## 工具使用\n* 可以使用chrome的工具`chrome://net-internals/#http2`来查看具体发送的帧的内容\n\n* 打开chrome-network中的protocol一栏，查看当前站点使用的HTTP版本\n<img src=\"/img/http2/chrome-tool.png\" alt=\"\">\n\n* 安装chrome扩展[HTTP/2 and SPDY indicator](https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?hl=zh-CN),在地址栏右侧会标示出是否使用了HTTP2或SPDY协议。\n<img src=\"/img/http2/chrome-tool1.png\" alt=\"\">\n\n* 在firefox浏览器的网络中，也可直接查看使用的HTTP协议的版本\n<img src=\"/img/http2/firefox-tool.png\" alt=\"\">\n\n* 帮助我们检测某个网站是否使用了HTTP2协议的网站[HTTP/2 Checker](https://www.h2check.org/);检测是否使用了SPDY协议的网站[SPDYCheck.org](https://spdycheck.org/)\n\n* 分析页面性能的网站[WebPagetest](http://www.webpagetest.org/)\n\n## 实验验证\n为了能够亲自证实HTTP2确实对web性能有了很大的改进，使用nodejs作为服务端，分别验证在使用HTTP2, HTTPS, HTTP和SPDY作为HTTP协议时，同时加载10张图片时web性能的表现，[代码下载](http://jiaolongHuang.github.io/code/http2-experiment.zip)。结果比较出乎意外：\n\n* 可以比较直观的观察到多路复用的表现\n<img src=\"/img/http2/http2-e.png\" alt=\"\" width=\"600px\">\n<img src=\"/img/http2/http1-e.png\" alt=\"\" width=\"600px\">\n\n* Server Push的验证\n[屈屈](https://www.imququ.com/)的[博客](https://www.imququ.com/post/use-http2-now.html)中有专门的介绍，这里我们也看一下。打开博客首页后可看到响应头中有`link:<...>`这样一个键值对，这是告诉服务器这个资源需要被推送。\n<img src=\"/img/http2/server-push.png\" alt=\"\" width=\"800px\">\n\n然后使用之前提到过的`chrome://net-internals/#http2`工具来查看具体的Push过程\n<img src=\"/img/http2/push_promise.png\" alt=\"\" width=\"800px\">\n\n* 至于头部压缩字节变少，页面加载速度变慢并无明显结果。与[HTTPS、SPDY和HTTP/2的性能比较](http://www.infoq.com/cn/news/2015/02/https-spdy-http2-comparison)的实验结果差的也比较多。\n\n猜测原因：由于是访问的本地资源，不能模拟网络拥塞的情况，故不能完全体现出http2的优势。\n\n\n## 注\n\n1. 套接字：是支持TCP/IP网络通信的基本操作单元，可以看成是不同主机之间的进程进行双向通信的端点。是应用进程与tcp连接之间的门，通过套接字口来发送或获得报文。\n\n1. HTTP队首阻塞：一个慢请求阻塞后面的所有请求。具体来说就是，假设客户端同时发送2个请求，一个高优先级，一个低优先级，即便低优先级的资源先准备好了，也不会先发送，而是先等着，等高优先级的响应发送完了再发送低优先级的。这样会导致网络资源浪费，服务器缓冲开销浪费，最终导致客户端等待时间无限期延迟。\n\n2. tcp队首阻塞：tcp要求分组严格按照顺序交付，一个分组未收到，就会阻塞后续的所有高序号分组。直到重传那个丢失的分组。\n\n## 参考\n* [HTTP/2](https://http2.github.io/)\n* [HTTP/2标准的发展 8 – HTTP 头部压缩](http://www.unclekevin.org/?p=402)\n* [HPACK: Header Compression for HTTP/2](https://http2.github.io/http2-spec/compression.html)\n* [HTTP/2 新特性浅析](http://io.upyun.com/2015/05/13/http2/)\n* [为 HTTP/2 头压缩专门设计的 HPACK](http://www.cnblogs.com/ghj1976/p/4586529.html)\n* [HTTP2 概述](http://www.cnblogs.com/ghj1976/p/4552583.html)\n* [HTTP/2 is here](https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/present?slide=id.p19)\n* [HTTP/2 all the things!](https://docs.google.com/presentation/d/1l9c9ROjLTD8clOL0yFufAOMbxNC0D-19zCiXMgqtY-M/edit?pli=1#slide=id.p19)\n\n\n\n\n\n\n\n\n\n",
				"html": "<p>HTTP2可以让我们的应用变得更快、更简单、更健壮，让我们在HTTP1.1时针对TCP协议特性而做的用来提高性能的HACK一笔勾销。<br><a id=\"more\"></a></p>\n<h2 id=\"总览\"><a href=\"#总览\" class=\"headerlink\" title=\"总览\"></a>总览</h2><p>为了提高应用的性能，降低延迟，我们能做的无外乎2点，要么传输的东西越小越好，要么距离能获得资源的地方越近越好。</p>\n<p>这个就好比说是运动员赛跑，为了最先到达终点，在相同的速度下，当然是离终点越近，用时会越短；另一方面，在距离相等的情况下，当然是降低自上多余的重量，让速度越快越好，这也是为什么短跑运动员穿紧身运动服，鞋带都要藏起来的原因，为了最大限度的降低在空气中的阻力，提高速度。</p>\n<p>实际上无论是针对HTTP的哪个版本我们所做的性能优化，也都是针对这两点所作出的改进。</p>\n<p>HTTP2的目的：通过支持<strong>多路复用</strong>来提高并行能力，减少因为3次握手等而产生的延迟；通过<strong>压缩HTTP首部</strong>将协议开销降到最低，同时支持请求优先级和服务器推送。</p>\n<p>HTTP2最大的改变：引入<strong>二进制分帧层</strong>。HTTP2不会改动HTTP1.x的语义，提供的功能也不变，但是HTTP2对内修改了格式化数据的方式，以及传输这些数据的方式。对外，也就是面向应用，不用做任何改变，感知不到这一层的变化的。</p>\n<p>其实HTTP2是对HTTP1.x的一个扩展，而非替代，之所以称之为2是因为它引入的二进制分帧层之前的HTTP1.x的服务端和客户端并不兼容。</p>\n<h2 id=\"新特性浅析\"><a href=\"#新特性浅析\" class=\"headerlink\" title=\"新特性浅析\"></a>新特性浅析</h2><h3 id=\"二进制分帧层\"><a href=\"#二进制分帧层\" class=\"headerlink\" title=\"二进制分帧层\"></a>二进制分帧层</h3><p>这是HTTP2中最大的改变。HTTP2之所以性能会比HTTP1.x有那么大的提高，很大程度上正是由于这一层的引入。</p>\n<blockquote>\n<p>这里所谓的“层” ，指的是位于套接字接口(注1)与应用可见的高层HTTP API之间的一个新机制:HTTP的语义，包括各种动词、方法、首部，都不受影响，不同的是<strong>传输期间</strong>对它们的编码方式变了。</p>\n</blockquote>\n<p>HTTP1.x用回车换行符作为纯文本的分隔符，在进行解析和差错检测时不方便。HTTP1.x中用ASCII码，是16进制的，来表示报文中的每一个字符，如下图中,47代表字母G，45代表字符E，54代表字符T。<br><img src=\"http://p8.qhimg.com/d/inn/2bc21b16/http-header.png\" alt=\"\"><br>然而，HTTP2引入分帧层后，将报文分隔成一个个更小的帧，并采用二进制编码的方式。通常会将一个消息（首部和数据在一起的）分成一个HEADER帧和若干个DATA帧。如下图所示<br><img src=\"/img/http2/frame-layer.png\" alt=\"\"></p>\n<p>另外需要明确的几个定义：<br><strong>流</strong>：已建立的连接上的双向字节流。具有唯一的流ID，客户端发起的为奇数ID，服务端发起的为偶数ID。很多个流可以并行的在同一个tcp连接上交换消息。<br><strong>消息</strong>：与逻辑消息对应，比如一个请求或一个响应。由一个或多个帧组成。<br><strong>帧</strong>：HTTP2中最小的通信单位，每个帧都会有帧首部，每个帧或者用来承载HTTP首部或负荷数据，或其他特定类型的帧。帧是遵循二进制编码的。</p>\n<p>总得来说，就是这样的，在HTTP2中，相同域名下的所有通信都在一个连接上完成，这个连接中可以承载任意数量的双向流。这些流都是以消息的形式被发送的，同时消息又由一个或多个帧组成。多个帧之间可以乱序发送，最后根据帧首部的流标识重新组装。</p>\n<p><strong>解释</strong><br>这个双向是指，服务器可以给浏览器发消息（server push），浏览器也可以给服务器发东西（这就不用说啦）</p>\n<p>对于一个帧来说，有固定固定帧格式，其中帧首部规定了帧最多只能带64KB的数据，还包括了帧类型和流标识符等。另外，帧中还可以填充一些额外的数据，最多255字节，保证数据安全性，拿HEADER帧举例。<br><img src=\"/img/http2/frame-structure.png\" alt=\"\"><br><img src=\"/img/http2/frame-header.png\" alt=\"\"></p>\n<p>从这点上看，HTTP2中的帧与tcp报文段有些相似的。</p>\n<p>在客户端或服务端发起建立新流时，帧携带HTTP的首部块，其中服务端发起流时，发送的HEADER帧没有优先级这一字段；当新流建立之后，就可发送HTTP消息的应用数据，也就是帧的负荷数据。</p>\n<p>将消息拆成多个数据帧之后，会大大缓解HTTP队首阻塞[注2]的情况。但是与tcp层的队首阻塞[注3]并无直接关系。同时，改以帧为传输单位后，使得对报文无论是解析和差错检测方面都变得更加容易，因为对纯文本的解析还需要考虑到空格，空行，换行等问题。另外，也还消除了并行处理和发送请求及响应时对多个连接的依赖。</p>\n<p><strong>解释</strong><br>多路复用：用一个tcp连接，并行发好多。【…keep_alive 很像啊】<br>—分组数？？表示是底层的，都没有概念…按道理说是分帧了后，分组数会变多啊？？？<br>和keep_alive 不像，是和管道化很像哈。<br>实际上是这样的，首先肯定的是多使用同一个tcp连接，比起以前的多个tcp连接，会至少每次少了3个建立连接的tcp报文段，还不包括重传的。同时因为分帧之后出错的概率变小，间接的需要重传的包变少。从这两方面来说整个网络中的包中的总数是变少的。<br>另外呢，tcp报文段的长度其实还是保持不变的，不同流中的帧其实是混在一个tcp报文段中一起被发送，而在接收方那边接受到这个报文段后再进行拆分重新组装成新的http报文。</p>\n<h3 id=\"首部压缩\"><a href=\"#首部压缩\" class=\"headerlink\" title=\"首部压缩\"></a>首部压缩</h3><p>由于HTTP协议是一种无状态的协议，服务器自身不会保存太多的信息和先前请求过的元数据信息，这就需要客户端每次都使用多个首部字段来描述所传输的资源及其属性，又由于HTTP1.1是以文本形式传输的，每次都会给HTTP报文增加500-800字节的负荷，如果算上cookie，这个负荷甚至会增加到上千。如果可以有办法减少这些开销，那么对性能又有很大的提升。</p>\n<p>HTTP2采用HPACK压缩方法，一边用index mapping table压缩，一边编码。这个table由<a href=\"https://http2.github.io/http2-spec/compression.html#static.table.definition\" target=\"_blank\" rel=\"external\">静态表</a>和动态表组成。</p>\n<ol>\n<li>先用预定义的index mapping table将头部中常用的字符串用index来代替</li>\n<li>对一定要使用文本表示的字符串，采用预定义的哈夫曼编码表进行编码<br>(具体的压缩和解压缩的方法请看<a href=\"http://www.cnblogs.com/ghj1976/p/4586529.html\" target=\"_blank\" rel=\"external\">参考4</a>的解释)</li>\n</ol>\n<ul>\n<li>客户端和服务器端使用首部表来跟踪和存储之前发送的每一个键值对。第一次请求时发送过的键值对，第二次在再请求时就不在发送了。（这一现象还一直没观察到）</li>\n<li>在tcp连接期间，客户端和服务端共同维护这个首部表，并且是共同渐进更新的</li>\n<li>每个新的键值对，要么直接添加到首部表尾部，要么替换原有表中的值</li>\n</ul>\n<p>另外，HTTP2的前身SPDY采用的头部压缩算法是delate算法，这个算法的压缩效率也不错，但是由于存在<a href=\"http://www.freebuf.com/articles/web/5636.html\" target=\"_blank\" rel=\"external\">CRIME攻击</a>，而HTTP2不得不重新设计了HPACK算法。</p>\n<p><strong>解释</strong><br>使用了HPACK算法，一方面如果下一次请求头部和上一次请求头部中有相同的字段，那么相同的字段不会被发送，只会被发送差异性的字段。另一方面，会有一张首部表，里面会有常用的首部字段极其对应的序号，会有序号来代替这个具体的字段字符串。同时，整个首部帧还会用哈夫曼编码来进行压缩。</p>\n<h3 id=\"多路复用\"><a href=\"#多路复用\" class=\"headerlink\" title=\"多路复用\"></a>多路复用</h3><p>引入二进制分帧层之后，HTTP2可以很容易的去实现多流并行而不用依赖建立多个tcp连接。</p>\n<blockquote>\n<p>实验表明，客户端使用更少的连接肯定可以降低延迟时间。HTTP 2.0 发送的总分组数量比 HTTP 差不多要少 40%。而服务器处理大量并发连接的情况也变成了可伸缩性问题，因为 HTTP 2.0 减轻了这个负担。               —-HTTP2.0</p>\n</blockquote>\n<p>每个来源使用一个连接，优势如下：</p>\n<ul>\n<li>从服务器和客户端来说，占用的资源和内存都少了。</li>\n<li>从tcp连接和网络来说，使得网络拥塞得到改善，慢启动时间减少，拥塞和丢包恢复速度变快。</li>\n</ul>\n<p><strong>解释</strong></p>\n<ul>\n<li><p>keep-alive，也是可以不进行3次握手就可以发送多个在同一个域下的请求。但是必须发送下一个请求B，等待前一个请求A的响应收到后才可以发送。多路复用和管道优化差不多，只是管道优化由于兼容性的问题，而没有被普遍使用。</p>\n</li>\n<li><p>但是什么时候断？如果太多的保持连接，会不会反而不好呢<br>和一般TCP连接释放一样，如果客户端没有数据要请求，或服务端数据发送完毕后，会主动发送关闭连接的报文。或者是服务端连续发送10个探测报文，客户端无响应，服务端就关闭了这个连接。</p>\n</li>\n</ul>\n<h3 id=\"请求优先级\"><a href=\"#请求优先级\" class=\"headerlink\" title=\"请求优先级\"></a>请求优先级</h3><p>当同一条连接上可以同时发送很多请求时，并不等于说这些请求对于服务器来说都应该一视同仁，因为客户端对资源的需求程度不同。比如说一个html文档，显然客户端对CSS和JS的需求，远大于对文档内图片的需求。</p>\n<p>因此在建立新流时，HEADER帧可以带有一个优先级(31位，0为优先级最高)的值。这样，服务端就可以因此而适当分配资源，优先发送这些优先级高的帧。</p>\n<p>HTTP2协议并没有规定这样的处理优先级的算法该如何实现，仅仅只是提供了这样一种机制。</p>\n<p>为了合理充分利用网络资源，服务器也应该交错处理不同优先级的帧。而不是严格按照优先级来处理，否则又会造成队首堵塞的情况。</p>\n<p><strong>解释</strong><br>？请求优先级….感觉需要服务器也要支持的节奏（那确实变复杂了）<br>是的。也就是说服务器和客户端对这个优先级的理解是一样的，或是达成一致的。</p>\n<h3 id=\"服务器推送\"><a href=\"#服务器推送\" class=\"headerlink\" title=\"服务器推送\"></a>服务器推送</h3><p>说到服务器推送，其实在HTTP1.1时，我们就用到过类似的，比如将图片使用base64编码嵌入在文档中。</p>\n<p>之所以要提供这个服务，是因为一个文档被请求回来时，往往还需要再次请求很多文档内的其他资源，如果这些资源的请求不用客户端发起，而是服务端提前预判发给客户端，那么就会减少一半的RTT。</p>\n<p>HTTP2这个协议也没有规定服务器端到底该怎样推送这个资源。服务端可以自己制定不同的策略，可以是根据客户端明确写出的推送请求；或者是服务端通过学习得来；再或者是通过额外的HTTP首部想服务端表明意向。</p>\n<p>这个服务的特点是：</p>\n<ul>\n<li>只有建立连接后，服务器才可以推送资源(发送PUSH_PROMISE帧，这个帧中只有要约的HTTP首部)，也就是说服务器不能无缘无故的主动向客户端推送资源</li>\n<li>客户端可以发送RST_STREAM拒绝服务器推送来的资源。但是这可能存在一个时间差，而导致客户端明明已经拒绝了，但服务端却还是把资源推送了过来。</li>\n<li>推送的资源可以有不同页面共享</li>\n<li>服务器可以按照优先级来推送资源</li>\n</ul>\n<p><strong>解释</strong><br>服务器主动推送一个资源，客户端有权来选择是接收还是不接收，不能‘来者不拒’嘛，是吧。</p>\n<h3 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h3><p>我们知道在HTTP2协议中，我们可以在同一个连接中，建立多个流，那么实际上这些流之间是相互竞争的，会相互争夺这个连接中资源的分配。此时与tcp流量控制相似，我们也需要对流中的帧进行流量控制。但只有DATA帧受流量控制，而其他类型的帧不受流量控制。同样，HTTP2也只提供了这样一种机制，而非具体实现。</p>\n<ul>\n<li>这个流量控制在没一跳之间进行，而非端到端</li>\n<li>流量控制基于窗口更新帧。连接建立之初，通过交换settings帧，来设定双向的流量控制窗口大小。</li>\n<li>发送端每发送一个DATA帧，就将window的值减去这次data帧的大小，直到window=0。</li>\n<li>接收方可通过发送window_update 帧。如果接收方不想接受数据了，就不发送window _update帧。</li>\n<li>在接受关键资源时，可将非关键资源的window设置的非常小，等网络空闲了，再改回大一些。</li>\n</ul>\n<h2 id=\"工具使用\"><a href=\"#工具使用\" class=\"headerlink\" title=\"工具使用\"></a>工具使用</h2><ul>\n<li><p>可以使用chrome的工具<code>chrome://net-internals/#http2</code>来查看具体发送的帧的内容</p>\n</li>\n<li><p>打开chrome-network中的protocol一栏，查看当前站点使用的HTTP版本<br><img src=\"/img/http2/chrome-tool.png\" alt=\"\"></p>\n</li>\n<li><p>安装chrome扩展<a href=\"https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?hl=zh-CN\" target=\"_blank\" rel=\"external\">HTTP/2 and SPDY indicator</a>,在地址栏右侧会标示出是否使用了HTTP2或SPDY协议。<br><img src=\"/img/http2/chrome-tool1.png\" alt=\"\"></p>\n</li>\n<li><p>在firefox浏览器的网络中，也可直接查看使用的HTTP协议的版本<br><img src=\"/img/http2/firefox-tool.png\" alt=\"\"></p>\n</li>\n<li><p>帮助我们检测某个网站是否使用了HTTP2协议的网站<a href=\"https://www.h2check.org/\" target=\"_blank\" rel=\"external\">HTTP/2 Checker</a>;检测是否使用了SPDY协议的网站<a href=\"https://spdycheck.org/\" target=\"_blank\" rel=\"external\">SPDYCheck.org</a></p>\n</li>\n<li><p>分析页面性能的网站<a href=\"http://www.webpagetest.org/\" target=\"_blank\" rel=\"external\">WebPagetest</a></p>\n</li>\n</ul>\n<h2 id=\"实验验证\"><a href=\"#实验验证\" class=\"headerlink\" title=\"实验验证\"></a>实验验证</h2><p>为了能够亲自证实HTTP2确实对web性能有了很大的改进，使用nodejs作为服务端，分别验证在使用HTTP2, HTTPS, HTTP和SPDY作为HTTP协议时，同时加载10张图片时web性能的表现，<a href=\"http://jiaolongHuang.github.io/code/http2-experiment.zip\">代码下载</a>。结果比较出乎意外：</p>\n<ul>\n<li><p>可以比较直观的观察到多路复用的表现<br><img src=\"/img/http2/http2-e.png\" alt=\"\" width=\"600px\"><br><img src=\"/img/http2/http1-e.png\" alt=\"\" width=\"600px\"></p>\n</li>\n<li><p>Server Push的验证<br><a href=\"https://www.imququ.com/\" target=\"_blank\" rel=\"external\">屈屈</a>的<a href=\"https://www.imququ.com/post/use-http2-now.html\" target=\"_blank\" rel=\"external\">博客</a>中有专门的介绍，这里我们也看一下。打开博客首页后可看到响应头中有<code>link:&lt;...&gt;</code>这样一个键值对，这是告诉服务器这个资源需要被推送。<br><img src=\"/img/http2/server-push.png\" alt=\"\" width=\"800px\"></p>\n</li>\n</ul>\n<p>然后使用之前提到过的<code>chrome://net-internals/#http2</code>工具来查看具体的Push过程<br><img src=\"/img/http2/push_promise.png\" alt=\"\" width=\"800px\"></p>\n<ul>\n<li>至于头部压缩字节变少，页面加载速度变慢并无明显结果。与<a href=\"http://www.infoq.com/cn/news/2015/02/https-spdy-http2-comparison\" target=\"_blank\" rel=\"external\">HTTPS、SPDY和HTTP/2的性能比较</a>的实验结果差的也比较多。</li>\n</ul>\n<p>猜测原因：由于是访问的本地资源，不能模拟网络拥塞的情况，故不能完全体现出http2的优势。</p>\n<h2 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h2><ol>\n<li><p>套接字：是支持TCP/IP网络通信的基本操作单元，可以看成是不同主机之间的进程进行双向通信的端点。是应用进程与tcp连接之间的门，通过套接字口来发送或获得报文。</p>\n</li>\n<li><p>HTTP队首阻塞：一个慢请求阻塞后面的所有请求。具体来说就是，假设客户端同时发送2个请求，一个高优先级，一个低优先级，即便低优先级的资源先准备好了，也不会先发送，而是先等着，等高优先级的响应发送完了再发送低优先级的。这样会导致网络资源浪费，服务器缓冲开销浪费，最终导致客户端等待时间无限期延迟。</p>\n</li>\n<li><p>tcp队首阻塞：tcp要求分组严格按照顺序交付，一个分组未收到，就会阻塞后续的所有高序号分组。直到重传那个丢失的分组。</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://http2.github.io/\" target=\"_blank\" rel=\"external\">HTTP/2</a></li>\n<li><a href=\"http://www.unclekevin.org/?p=402\" target=\"_blank\" rel=\"external\">HTTP/2标准的发展 8 – HTTP 头部压缩</a></li>\n<li><a href=\"https://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"external\">HPACK: Header Compression for HTTP/2</a></li>\n<li><a href=\"http://io.upyun.com/2015/05/13/http2/\" target=\"_blank\" rel=\"external\">HTTP/2 新特性浅析</a></li>\n<li><a href=\"http://www.cnblogs.com/ghj1976/p/4586529.html\" target=\"_blank\" rel=\"external\">为 HTTP/2 头压缩专门设计的 HPACK</a></li>\n<li><a href=\"http://www.cnblogs.com/ghj1976/p/4552583.html\" target=\"_blank\" rel=\"external\">HTTP2 概述</a></li>\n<li><a href=\"https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/present?slide=id.p19\" target=\"_blank\" rel=\"external\">HTTP/2 is here</a></li>\n<li><a href=\"https://docs.google.com/presentation/d/1l9c9ROjLTD8clOL0yFufAOMbxNC0D-19zCiXMgqtY-M/edit?pli=1#slide=id.p19\" target=\"_blank\" rel=\"external\">HTTP/2 all the things!</a></li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1439718170000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1439718170000,
				"published_by": 2
			},
			{
				"id": "cj914pnzl0034e0hyr0bv420m",
				"title": "HTTP2学习(三)—关于HTTP/1.1管道化的问答(翻译)",
				"slug": "http-pipelining",
				"markdown": "[关于HTTP/1.1管道化的问答](http://www-archive.mozilla.org/projects/netlib/HTTP//pipelining-faq.html)\n\n## 什么是http管道化\n通常，http请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。\nHTTP/1.1允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。（me：所有请求保持一个FIFO的队列，一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出；同时，服务器端返回这些请求的响应时也是按照FIFO的顺序）。管道化的表现可以大大提高页面加载的速度，尤其是在高延迟连接中。\n管道化同样也可以减少tcp/ip的数据包。通常MSS的大小是在536-1460字节，所以将许多个http请求放在一个tcp/ip包 里也是有可能的。减少加载一个网页所需数据包的数量可以在整体上对网络有益处，因为数据包越少，路由器和网络带来的负担就越少。\nHTTP/1.1需要服务器也支持管道化。但这并不意味着服务器需要管道化响应，而是当客户端发出管道化请求时，服务器不会响应失败。This obviously has the potential to introduce a new category of evangelism bugs（不会翻。。），因为仅有现代浏览器支持管道化。\n\n## 什么时候我们应该管道化请求\n只有幂等的请求（见注1）才可以被管道化，比如GET和HEAD。POST和PUT不应该被管道化。我们同样也不应该在建立新连接的时候发出管道化的请求 ，因为不能确源服务或代理是否支持HTTP/1.1。因此，管道化只能利用已存在的keep-alive连接。\n\n## 多少个请求应该被管道化\n如果连接过早的关闭，管道化许多请求是划不来的，因为我们会花费很多时间用来向网络里写请求，然后还不得不在新连接中重写一遍。而且，如果较早到达的请求需要花费很长的时间完成，一个过长的管道实际上会让用户感知到更长的延迟。HTTP/1.1标准也没有提供关于管道化请求理想数目的任何指导。实际上，我们建议每个服务器不超过2个keep-alive连接。显然，这个还得依赖于应用本身。鉴于上述的原因，浏览器可能不需要一个持续时间特别长的管道。2个可能是比较合适的值，但是还有待测试。\n\n## 如果一个请求被取消了，会发生什么？\n如果一请求被取消了，是不是意味着整个管道都被取消了呢？或者，是不是意味着这个被取消请求的响应应该被简单的丢弃，以便这个管道中的其他请求不会被强制重发？这个答案依赖于很多因素，包括，这个被取消请求的响应还有多少没有被收到。最原始的办法可能是简单的取消管道，然后重发所有的请求。仅仅当请求是幂等的时候才可以。这样原始的方法也可以产生好的影响，因为正在管道中被发送的请求可能属于同一个正在被取消的页面载入组。\n\n## 如果连接失败会发生什么？\n如果连接失败了或服务器在下载一个管道中的响应时中断了，浏览器必须有能力重新开始发送被丢失的请求。这种情况可以等同于上面讨论的被取消的例子。\n\n## 注\n1. **HTTP/方法的幂等性**：是指一次和多次请求某一个资源应该具有同样的副作用。\n幂等性的请求，实际上就是多次操作都不会改变结果的请求，比如GET，我可以多次从同一个地方获取资源，但是对于资源本身来说并不会发生什么变化，我GET10次和GET100次，资源都没有发生任何变化。而post则不同了，我提交表单10次，和100次，造成的结果是不同的，至少数据库里新增的数据有不同。\n\n## 解释\n1. 其实HTTP管道化就是将客户端的FIFO队列移到了服务端。在客户端可以依次发送所有要发送的请求（当然这些请求是在同一个域下的），一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出。在服务器端维持的FIFO队列，这个队列是按照资源的重要程度排列的。比如HTML比CSS要先返回，JS,CSS比图片先返回。\n\n2. 在服务器端会有一个缓冲区，来存放那些已经被处理好了但是还没轮到被发送的响应。比如服务器先后收到了A,B两个请求，A资源比B资源优先级要高，处理A需要10ms，处理B需要1ms，假设服务器可以并行处理请求，那么B的响应肯定是最先处理好了的，但是B响应不能先发出去，必须待在缓冲区里，等待A响应处理好了之后，先把A的响应发出去，B的响应才能够被发出去。因为服务端必须要遵循FIFO这个原则。\n\n3. HTTP管道化不是HTTP2的内容，是对HTTP1.1协议下，服务器不能很好处理并行请求的一个改进。\n\n4. 管道化的有序和TCP的有序是本质上的不同，管道化的有序，是消息与消息之间的有序。TCP中的有序，组成一个消息的多个报文段之间的有序。打个不太恰当的比方，就好比是A同学吃午餐和B同学吃午餐哪个先吃完饭可以去玩电脑一样，假设是A同学先进食堂，B同学再进食堂，他俩的吃饭速度相同，那么按照FIFO原则，不论是A同学是吃了苹果，梨，米饭，菜，还是B同学只吃了苹果和米饭。虽然B同学是先吃完，他吃的少，但是在管道化中，也还一定是A同学先去玩电脑，B同学跟着。而在TCP中，就好像是在形容，这顿饭，A同学是先吃了苹果，梨，米饭，菜还是先吃了菜，米饭，梨，这样的内部顺序。\n\n5. 管道做了哪些事，我的理解是创造了一个可以不用等待前一个请求的响应即可发送下一个请求的场所。至于注意些什么，除了知道有些设备不支持，其他的我也没实际经验（毕竟没用过，囧）",
				"html": "<p><a href=\"http://www-archive.mozilla.org/projects/netlib/HTTP//pipelining-faq.html\" target=\"_blank\" rel=\"external\">关于HTTP/1.1管道化的问答</a></p>\n<h2 id=\"什么是http管道化\"><a href=\"#什么是http管道化\" class=\"headerlink\" title=\"什么是http管道化\"></a>什么是http管道化</h2><p>通常，http请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。<br>HTTP/1.1允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。（me：所有请求保持一个FIFO的队列，一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出；同时，服务器端返回这些请求的响应时也是按照FIFO的顺序）。管道化的表现可以大大提高页面加载的速度，尤其是在高延迟连接中。<br>管道化同样也可以减少tcp/ip的数据包。通常MSS的大小是在536-1460字节，所以将许多个http请求放在一个tcp/ip包 里也是有可能的。减少加载一个网页所需数据包的数量可以在整体上对网络有益处，因为数据包越少，路由器和网络带来的负担就越少。<br>HTTP/1.1需要服务器也支持管道化。但这并不意味着服务器需要管道化响应，而是当客户端发出管道化请求时，服务器不会响应失败。This obviously has the potential to introduce a new category of evangelism bugs（不会翻。。），因为仅有现代浏览器支持管道化。</p>\n<h2 id=\"什么时候我们应该管道化请求\"><a href=\"#什么时候我们应该管道化请求\" class=\"headerlink\" title=\"什么时候我们应该管道化请求\"></a>什么时候我们应该管道化请求</h2><p>只有幂等的请求（见注1）才可以被管道化，比如GET和HEAD。POST和PUT不应该被管道化。我们同样也不应该在建立新连接的时候发出管道化的请求 ，因为不能确源服务或代理是否支持HTTP/1.1。因此，管道化只能利用已存在的keep-alive连接。</p>\n<h2 id=\"多少个请求应该被管道化\"><a href=\"#多少个请求应该被管道化\" class=\"headerlink\" title=\"多少个请求应该被管道化\"></a>多少个请求应该被管道化</h2><p>如果连接过早的关闭，管道化许多请求是划不来的，因为我们会花费很多时间用来向网络里写请求，然后还不得不在新连接中重写一遍。而且，如果较早到达的请求需要花费很长的时间完成，一个过长的管道实际上会让用户感知到更长的延迟。HTTP/1.1标准也没有提供关于管道化请求理想数目的任何指导。实际上，我们建议每个服务器不超过2个keep-alive连接。显然，这个还得依赖于应用本身。鉴于上述的原因，浏览器可能不需要一个持续时间特别长的管道。2个可能是比较合适的值，但是还有待测试。</p>\n<h2 id=\"如果一个请求被取消了，会发生什么？\"><a href=\"#如果一个请求被取消了，会发生什么？\" class=\"headerlink\" title=\"如果一个请求被取消了，会发生什么？\"></a>如果一个请求被取消了，会发生什么？</h2><p>如果一请求被取消了，是不是意味着整个管道都被取消了呢？或者，是不是意味着这个被取消请求的响应应该被简单的丢弃，以便这个管道中的其他请求不会被强制重发？这个答案依赖于很多因素，包括，这个被取消请求的响应还有多少没有被收到。最原始的办法可能是简单的取消管道，然后重发所有的请求。仅仅当请求是幂等的时候才可以。这样原始的方法也可以产生好的影响，因为正在管道中被发送的请求可能属于同一个正在被取消的页面载入组。</p>\n<h2 id=\"如果连接失败会发生什么？\"><a href=\"#如果连接失败会发生什么？\" class=\"headerlink\" title=\"如果连接失败会发生什么？\"></a>如果连接失败会发生什么？</h2><p>如果连接失败了或服务器在下载一个管道中的响应时中断了，浏览器必须有能力重新开始发送被丢失的请求。这种情况可以等同于上面讨论的被取消的例子。</p>\n<h2 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h2><ol>\n<li><strong>HTTP/方法的幂等性</strong>：是指一次和多次请求某一个资源应该具有同样的副作用。<br>幂等性的请求，实际上就是多次操作都不会改变结果的请求，比如GET，我可以多次从同一个地方获取资源，但是对于资源本身来说并不会发生什么变化，我GET10次和GET100次，资源都没有发生任何变化。而post则不同了，我提交表单10次，和100次，造成的结果是不同的，至少数据库里新增的数据有不同。</li>\n</ol>\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><ol>\n<li><p>其实HTTP管道化就是将客户端的FIFO队列移到了服务端。在客户端可以依次发送所有要发送的请求（当然这些请求是在同一个域下的），一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出。在服务器端维持的FIFO队列，这个队列是按照资源的重要程度排列的。比如HTML比CSS要先返回，JS,CSS比图片先返回。</p>\n</li>\n<li><p>在服务器端会有一个缓冲区，来存放那些已经被处理好了但是还没轮到被发送的响应。比如服务器先后收到了A,B两个请求，A资源比B资源优先级要高，处理A需要10ms，处理B需要1ms，假设服务器可以并行处理请求，那么B的响应肯定是最先处理好了的，但是B响应不能先发出去，必须待在缓冲区里，等待A响应处理好了之后，先把A的响应发出去，B的响应才能够被发出去。因为服务端必须要遵循FIFO这个原则。</p>\n</li>\n<li><p>HTTP管道化不是HTTP2的内容，是对HTTP1.1协议下，服务器不能很好处理并行请求的一个改进。</p>\n</li>\n<li><p>管道化的有序和TCP的有序是本质上的不同，管道化的有序，是消息与消息之间的有序。TCP中的有序，组成一个消息的多个报文段之间的有序。打个不太恰当的比方，就好比是A同学吃午餐和B同学吃午餐哪个先吃完饭可以去玩电脑一样，假设是A同学先进食堂，B同学再进食堂，他俩的吃饭速度相同，那么按照FIFO原则，不论是A同学是吃了苹果，梨，米饭，菜，还是B同学只吃了苹果和米饭。虽然B同学是先吃完，他吃的少，但是在管道化中，也还一定是A同学先去玩电脑，B同学跟着。而在TCP中，就好像是在形容，这顿饭，A同学是先吃了苹果，梨，米饭，菜还是先吃了菜，米饭，梨，这样的内部顺序。</p>\n</li>\n<li><p>管道做了哪些事，我的理解是创造了一个可以不用等待前一个请求的响应即可发送下一个请求的场所。至于注意些什么，除了知道有些设备不支持，其他的我也没实际经验（毕竟没用过，囧）</p>\n</li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1439707392000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1439707392000,
				"published_by": 2
			},
			{
				"id": "cj914po04003ze0hy1a31gwjr",
				"title": "HTTP2学习(二)—一条消息的历程",
				"slug": "message-road",
				"markdown": "\n在基于TCP/IP结构，HTTP1.1的网络中，一条消息从A主机发送到B主机收到，会经历哪些呢？\n<!-- more -->\n\n## \"历程\"\n<img src=\"http://p8.qhimg.com/d/inn/bccb4366/20150817101215.jpg\" alt=\"\" width=\"580px\">\n\n* 应用层（HTTP, HTTP报文）\n\n\tHTTP报文是基于文本的，**是没有长度限制**的。也就是说资源有多大，就会一次性都会发过去。HTTP报文的首部行之间是用换行回车来分隔。另外，发送过去的报文实际内容就是将一个个的字符用ASCII码来表示。\n\t<img src=\"/img/http2/http-layer.png\" alt=\"\">\n* 运输层(TCP，报文段)\n\t\n\t如果TCP需要发送一个很大的数据，TCP通常会把文件化成长度为**MSS**(注1)的若干块再发送。\n\t\n\t会将长报文划分成短报文，并提供拥塞控制机制\n\t\n\tTCP报文的首部一般是20字节，包括端口号，序号(注3)和确认号(注4)，以及做验证的一些字段。\n\t<img src=\"/img/http2/tcp-layer.png\" alt=\"\">\n\n* 网络层(IP, 数据报)\n\t\n\t增加了源IP地址和目的IP地址；同时规定了数据报长度（包括首部长），理论上是**65535字节**。\n\t\n\t有可能从发送方到接受方这一路径中每段链路使用的**链路层协议不同，且这些协议具有不同的MTU**(注2),因此就需要对ip数据报进行分片。\n\t\n\t只有完全重构为初始ip的数据报才会被交付到上层，否则会被直接丢弃。如果运输层是TCP，那么TCP会要求源重传。\n\t<img src=\"/img/http2/ip-layer.png\" alt=\"\">\n* 链路层(帧)\n\n\t传输的数据量有**固定大小**，不同的链路层协议能传送的最大数据量不同。可见[参考1](http://blog.chinaunix.net/uid-20530497-id-2878069.html)\n\t\n\t会增加源mac地址和目的mac地址。\n\t<img src=\"/img/http2/datalink-layer.png\" alt=\"\">\n\t\n## 注\n2. MSS: 最大报文段长度，不包括TCP报文的头部。受最大链路层帧长度**MTU**的限制。\n1. MTU: 最大传输单元，链路层协议不同，议具的MTU也有可能不同，其中以太网和PPP链路层的MTU是1500字节。\n2. 序号：这个分组的第一字节排在整个消息的第几位。\n3. 确认号：期望下次从主机那儿获得字节的序号。\n\n## 参考\n1. [链路层常见报文格式及长度](http://blog.chinaunix.net/uid-20530497-id-2878069.html)\n\n\n\n",
				"html": "<p>在基于TCP/IP结构，HTTP1.1的网络中，一条消息从A主机发送到B主机收到，会经历哪些呢？<br><a id=\"more\"></a></p>\n<h2 id=\"“历程”\"><a href=\"#“历程”\" class=\"headerlink\" title=\"“历程”\"></a>“历程”</h2><p><img src=\"http://p8.qhimg.com/d/inn/bccb4366/20150817101215.jpg\" alt=\"\" width=\"580px\"></p>\n<ul>\n<li><p>应用层（HTTP, HTTP报文）</p>\n<p>  HTTP报文是基于文本的，<strong>是没有长度限制</strong>的。也就是说资源有多大，就会一次性都会发过去。HTTP报文的首部行之间是用换行回车来分隔。另外，发送过去的报文实际内容就是将一个个的字符用ASCII码来表示。<br>  <img src=\"/img/http2/http-layer.png\" alt=\"\"></p>\n</li>\n<li><p>运输层(TCP，报文段)</p>\n<p>  如果TCP需要发送一个很大的数据，TCP通常会把文件化成长度为<strong>MSS</strong>(注1)的若干块再发送。</p>\n<p>  会将长报文划分成短报文，并提供拥塞控制机制</p>\n<p>  TCP报文的首部一般是20字节，包括端口号，序号(注3)和确认号(注4)，以及做验证的一些字段。<br>  <img src=\"/img/http2/tcp-layer.png\" alt=\"\"></p>\n</li>\n<li><p>网络层(IP, 数据报)</p>\n<p>  增加了源IP地址和目的IP地址；同时规定了数据报长度（包括首部长），理论上是<strong>65535字节</strong>。</p>\n<p>  有可能从发送方到接受方这一路径中每段链路使用的<strong>链路层协议不同，且这些协议具有不同的MTU</strong>(注2),因此就需要对ip数据报进行分片。</p>\n<p>  只有完全重构为初始ip的数据报才会被交付到上层，否则会被直接丢弃。如果运输层是TCP，那么TCP会要求源重传。<br>  <img src=\"/img/http2/ip-layer.png\" alt=\"\"></p>\n</li>\n<li><p>链路层(帧)</p>\n<p>  传输的数据量有<strong>固定大小</strong>，不同的链路层协议能传送的最大数据量不同。可见<a href=\"http://blog.chinaunix.net/uid-20530497-id-2878069.html\" target=\"_blank\" rel=\"external\">参考1</a></p>\n<p>  会增加源mac地址和目的mac地址。<br>  <img src=\"/img/http2/datalink-layer.png\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h2><ol>\n<li>MSS: 最大报文段长度，不包括TCP报文的头部。受最大链路层帧长度<strong>MTU</strong>的限制。</li>\n<li>MTU: 最大传输单元，链路层协议不同，议具的MTU也有可能不同，其中以太网和PPP链路层的MTU是1500字节。</li>\n<li>序号：这个分组的第一字节排在整个消息的第几位。</li>\n<li>确认号：期望下次从主机那儿获得字节的序号。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://blog.chinaunix.net/uid-20530497-id-2878069.html\" target=\"_blank\" rel=\"external\">链路层常见报文格式及长度</a></li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1439631770000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1439631770000,
				"published_by": 2
			},
			{
				"id": "cj914pnzi0032e0hy2udgbe5n",
				"title": "HTTP2学习(一)—HTTP的历史",
				"slug": "http-history",
				"markdown": "\n一直以来对HTTP都是只见树木不见森林的感觉，这次借着对HTTP2的学习，希望可以梳理出一条自己对HTTP的了解认识线。\n<!-- more -->\n\n## 背景\n* 在上世纪60年代，世界上占统治地位的通信网络是电话网络，它是基于电路交换[1]的。与此同时，随着分时计算机的出现和计算机重要性的提高，如何充分利用分散在世界各地的数字计算机为人们所共享就变的越发重要了。其中需要注意的是，这些用户所产生的流量是具有突发性的，也就是说具有活动的间断性。\n* 于是世界上的科学家们就发明了更能很好解决突发性的分组交换来替代电路交换。最开始是美国的阿帕网，ARPAnet，是世界上第一个分组交换机网络，也就是今天因特网的直接祖先。\n* HTTP协议是现代web的基础。其实HTTP协议的出现主要是为了推动万维网的应用，它们的发明者是同一个人。HTTP协议设计之初是非常简洁的，就是为了传输超文本文档，也就是HTTP0.9版本。\n\n## HTTP的版本\n* HTTP0.9\n\t* 请求：ASCII字符串＋CRLF结尾\n\t* 响应：ASCII字符流/HTML+CRLF结尾\n\t* 只能GET获取资源，不能发送携带数据的POST请求\n\t* 文档传完之后，断开连接\t\t\t\n* HTTP1.0（并不是真正的规范）\n\n\t随着页面上的内容逐渐丰富，除了文字，超链接，还有图片资源。\n\t人们对web应用的需求也不断增加，要求不仅能够访问HTML同时还需要能够提供有关请求和响应的元数据（首部字段），在页面上进行交互操作，比如表单提交，并且支持内容协商。\n\t* 请求/响应的首部可有多行首部字段构成\n\t* 响应对象前增加了一个响应状态行\n\t* 可以支持长连接，还是每次请求结束后默认都断开连接\n\n* HTTP1.1\n\t* 持久连接\n\t* 分块传输\n\t* 字节范围请求\n\t* 协商机制更健全，协商内容更多：内容编码，传输编码，缓存指令，客户端cookie等\n\t* HTTP pipling(实际使用受限，浏览器默认不开启，很多中间代理不提供该服务)\n\t\t\t\n* HTTP2 \n\t在web应用中资源越来越丰富的趋势中，由于tcp自身的特点以至于HTTP1.1的性能上受到了很大的限制，虽然我们有做一些针对性能提高的hack。HTTP2的出现主要是为了提高传输性能，降低延迟，提高吞吐量。\n\n从总体来说，HTTP0.9用了一行命令就启动了万维网，HTTP1.0是对0.9扩展的正式说明，而HTTP1.1则是一份官方标准。总之，HTTP1.x的设计的初衷是实现要简单。但是这也是以牺牲性能为代价的。所以，这也是现在HTTP2所要解决的问题。\n\n**解释**\n1. “HTTP1.x的设计的初衷是实现要简单。但是这也是以牺牲性能为代价的”\n比如没有处理并行连接和请求的快捷方法，没有为了减少不必要的请求开销而做优化（首部压缩）等等，这些以至于在页面资源极其丰富的今天，即便我们针对HTTP1.1做了很多HACK优化，然而性能还是没有得到很大的提升。而这些点在HTTP2中都得到了改进。\n\n## HTTP与tcp的关系\n* HTTP是应用层的协议，tcp是传输层的协议。HTTP协议并没有规定必须要使用tcp协议当作是传输层的协议，现在默认使用tcp当做是传输层协议，采用80端口（因为HTTP是无状态协议，要是使用未经改良的不可靠传输协议，很容易造成数据丢失）；另外，谷歌还研发了一种基于udp的多路传输协议QUIC(Quick UDP Internet Connections)(注2)，用来解决SPDY在TCP遇到的瓶颈而在UDP上做出的探索。\n* HTTP是一种无状态的协议，当前的请求与上一次的请求并无关系，也就是说这次HTTP请求做什么和上一次请求做什么是没有关系的，哪怕请求的是相同的资源。这样做的好处是，服务器不用为了保存状态而消耗过多的资源，坏处是重复发相同的状态，会浪费网络资源，造成网络拥塞，延迟增大。\n* tcp提供了可靠传输的性能，为精确传输做了优化，比如3次握手，差错检测，快速重传。同时还进行了拥塞预防与控制，慢启动等来减轻整个网络的拥塞程度。一个数据包从请求到收到，需要经过传播延迟，传输延迟，处理延迟和排队延迟。因此，tcp比较适合大块数据的精确传输，性价比高；若常有突发的连接请求，实际上是其负作用的。原因很简单，在拿到完整数据之前，tcp做了太多事，造成了太多延迟，至少1个RTT。\n\n## 注\n1. 电路交换：在端系统会话过程中，预留了端系统间所经路径所需要的资源，包括缓存，链路传输速率。\n2. QUIC能够处理传输可靠性、丢包或无序数据包等一系列UDP默认未处理的问题。它的高层类似SPDY，低层是在UDP上模仿实现TCP的面向连接特性和可靠性并加入类似TLS的加密过程\n\n## 参考\n1. [Google期望使用QUIC给互联网加速](http://www.infoq.com/cn/news/2014/02/quic/)\n\n",
				"html": "<p>一直以来对HTTP都是只见树木不见森林的感觉，这次借着对HTTP2的学习，希望可以梳理出一条自己对HTTP的了解认识线。<br><a id=\"more\"></a></p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li>在上世纪60年代，世界上占统治地位的通信网络是电话网络，它是基于电路交换[1]的。与此同时，随着分时计算机的出现和计算机重要性的提高，如何充分利用分散在世界各地的数字计算机为人们所共享就变的越发重要了。其中需要注意的是，这些用户所产生的流量是具有突发性的，也就是说具有活动的间断性。</li>\n<li>于是世界上的科学家们就发明了更能很好解决突发性的分组交换来替代电路交换。最开始是美国的阿帕网，ARPAnet，是世界上第一个分组交换机网络，也就是今天因特网的直接祖先。</li>\n<li>HTTP协议是现代web的基础。其实HTTP协议的出现主要是为了推动万维网的应用，它们的发明者是同一个人。HTTP协议设计之初是非常简洁的，就是为了传输超文本文档，也就是HTTP0.9版本。</li>\n</ul>\n<h2 id=\"HTTP的版本\"><a href=\"#HTTP的版本\" class=\"headerlink\" title=\"HTTP的版本\"></a>HTTP的版本</h2><ul>\n<li>HTTP0.9<ul>\n<li>请求：ASCII字符串＋CRLF结尾</li>\n<li>响应：ASCII字符流/HTML+CRLF结尾</li>\n<li>只能GET获取资源，不能发送携带数据的POST请求</li>\n<li>文档传完之后，断开连接            </li>\n</ul>\n</li>\n<li><p>HTTP1.0（并不是真正的规范）</p>\n<p>  随着页面上的内容逐渐丰富，除了文字，超链接，还有图片资源。<br>  人们对web应用的需求也不断增加，要求不仅能够访问HTML同时还需要能够提供有关请求和响应的元数据（首部字段），在页面上进行交互操作，比如表单提交，并且支持内容协商。</p>\n<ul>\n<li>请求/响应的首部可有多行首部字段构成</li>\n<li>响应对象前增加了一个响应状态行</li>\n<li>可以支持长连接，还是每次请求结束后默认都断开连接</li>\n</ul>\n</li>\n<li><p>HTTP1.1</p>\n<ul>\n<li>持久连接</li>\n<li>分块传输</li>\n<li>字节范围请求</li>\n<li>协商机制更健全，协商内容更多：内容编码，传输编码，缓存指令，客户端cookie等</li>\n<li>HTTP pipling(实际使用受限，浏览器默认不开启，很多中间代理不提供该服务)</li>\n</ul>\n</li>\n<li><p>HTTP2<br>  在web应用中资源越来越丰富的趋势中，由于tcp自身的特点以至于HTTP1.1的性能上受到了很大的限制，虽然我们有做一些针对性能提高的hack。HTTP2的出现主要是为了提高传输性能，降低延迟，提高吞吐量。</p>\n</li>\n</ul>\n<p>从总体来说，HTTP0.9用了一行命令就启动了万维网，HTTP1.0是对0.9扩展的正式说明，而HTTP1.1则是一份官方标准。总之，HTTP1.x的设计的初衷是实现要简单。但是这也是以牺牲性能为代价的。所以，这也是现在HTTP2所要解决的问题。</p>\n<p><strong>解释</strong></p>\n<ol>\n<li>“HTTP1.x的设计的初衷是实现要简单。但是这也是以牺牲性能为代价的”<br>比如没有处理并行连接和请求的快捷方法，没有为了减少不必要的请求开销而做优化（首部压缩）等等，这些以至于在页面资源极其丰富的今天，即便我们针对HTTP1.1做了很多HACK优化，然而性能还是没有得到很大的提升。而这些点在HTTP2中都得到了改进。</li>\n</ol>\n<h2 id=\"HTTP与tcp的关系\"><a href=\"#HTTP与tcp的关系\" class=\"headerlink\" title=\"HTTP与tcp的关系\"></a>HTTP与tcp的关系</h2><ul>\n<li>HTTP是应用层的协议，tcp是传输层的协议。HTTP协议并没有规定必须要使用tcp协议当作是传输层的协议，现在默认使用tcp当做是传输层协议，采用80端口（因为HTTP是无状态协议，要是使用未经改良的不可靠传输协议，很容易造成数据丢失）；另外，谷歌还研发了一种基于udp的多路传输协议QUIC(Quick UDP Internet Connections)(注2)，用来解决SPDY在TCP遇到的瓶颈而在UDP上做出的探索。</li>\n<li>HTTP是一种无状态的协议，当前的请求与上一次的请求并无关系，也就是说这次HTTP请求做什么和上一次请求做什么是没有关系的，哪怕请求的是相同的资源。这样做的好处是，服务器不用为了保存状态而消耗过多的资源，坏处是重复发相同的状态，会浪费网络资源，造成网络拥塞，延迟增大。</li>\n<li>tcp提供了可靠传输的性能，为精确传输做了优化，比如3次握手，差错检测，快速重传。同时还进行了拥塞预防与控制，慢启动等来减轻整个网络的拥塞程度。一个数据包从请求到收到，需要经过传播延迟，传输延迟，处理延迟和排队延迟。因此，tcp比较适合大块数据的精确传输，性价比高；若常有突发的连接请求，实际上是其负作用的。原因很简单，在拿到完整数据之前，tcp做了太多事，造成了太多延迟，至少1个RTT。</li>\n</ul>\n<h2 id=\"注\"><a href=\"#注\" class=\"headerlink\" title=\"注\"></a>注</h2><ol>\n<li>电路交换：在端系统会话过程中，预留了端系统间所经路径所需要的资源，包括缓存，链路传输速率。</li>\n<li>QUIC能够处理传输可靠性、丢包或无序数据包等一系列UDP默认未处理的问题。它的高层类似SPDY，低层是在UDP上模仿实现TCP的面向连接特性和可靠性并加入类似TLS的加密过程</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://www.infoq.com/cn/news/2014/02/quic/\" target=\"_blank\" rel=\"external\">Google期望使用QUIC给互联网加速</a></li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1439545370000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1439545370000,
				"published_by": 2
			},
			{
				"id": "cj914pnz7002le0hyhcnwt6iw",
				"title": "chart-pie",
				"slug": "chart-pie",
				"markdown": "\n看了w3cplus上的[这篇博文](http://www.w3cplus.com/css3/designing-simple-pie-charts-with-css.html)后，动手实践了下，弄清楚了实现的原理，同时在此过程中也发现了一些知识盲点，再此记录下。\n<!-- more -->\n3种方式，方便程度逐渐递增，但是浏览器的支持程度却也慢慢变差\n\n## css3实现饼图\n[小呆萌](http://jiaolonghuang.github.io/practice/pie/css3-chart.html)\n主要原理：整个图可以看成是2层纸板，最上面的纸板是半个的，下面的纸板是一个整圆，但是颜色是一半为底色A，一半为需要展现的颜色B。一开始的时候，上面的纸板颜色与底色相同是A，因为是0%，然后不断旋转角度，让需要展现的颜色B逐渐露出来。但是当过了50%之后，上面的纸板就需要变成颜色B了，因为需要展现的颜色应该是越变越多的。\n\n* 一半一半颜色的实现\n`background-image: linear-gradient( to right, transparent 50%, #ed885f 0);`\n\n* `border-radius: 0 100% 100% 0 / 50%;`\n以`/`为分界点，左边的是边框圆角的x半径，右边是y半径。x和y都遵循TRBL(上右下左)都顺序。因此上面的border-radius实际可表示为：\nborder-top-left-radius: 0 50%;\nbordr-top-right-radius: 100% 50%;\nborder-bottom-right-radius: 100% 50%;\nborder-bottom-left-radius: 0 50%;\n\n* animation-timing-function中的steps\nsteps(1, start) = step-start; \nsteps(1, end) = step-end;\nsteps(n, start)表示将2个关键帧之间的效果平均分为n步来过渡实现，其中呢，自动略过0%的部分，以下一帧的显示效果来填充间隔动画; 反之，亦然。\n比如\n```\n.div{\n\twidth: 100px;\n\theight: 100px;\n\tborder: 1px solid #000;\n\tbackground-color: #333;\n\tanimation-name: changeBg;\n\tanimation-duration: 10s;\n\tanimation-timing-function: steps( 2, start );\n}\n@keyframes changeBg{\n\tfrom{\n\t\tbackground-color: red;\n\t}\n\t50%{\n\t\tbackground-color: yellow;\n\t}\n\t100%{\n\t\tbackground-color: green;\n\t}\n}\n```\n这段代码的意思就是，从0%－50%之间会执行5s，并且此期间，动画会分成2步走，每步走2.5s，第一步首先背景会略过红色，而直接变成橙色，介于红色与黄色之间的一个过渡色，第二步，变成黄色，也就是以50%的这一帧的效果来填充了。剩下的50%同理。如下图所示。\n<img src=\"http://p8.qhimg.com/d/inn/50b09d40/20150814093917.png\" alt=\"\">\n\n* 下面两段代码的意思是一样的。没必要这样做，在 0% 和 100% keyframe中声明相同的属性和值，浏览器会在动画开始和结束时自动处理属性值。\n```\n@keyframes changeBg{\n\t50%{\n\t\tbackground-color: yellow;\n\t}\n}\n@keyframes changeBg{\n\tfrom{\n\t\tbackground-color: 默认值;\n\t}\n\t50%{\n\t\tbackground-color: yellow;\n\t}\n\t100%{\n\t\tbackground-color: 默认值;\n\t}\n}\n```\n* animation-delay: 负值\n就好像效果已经在动画开始之前就已经开始进行了。等动画开始的时候，就在那个点继续进行。比如一个效果需要进行15s，而delay了10s，那么在动画开始的时候，我们看到的就是这个效果从第10s之后直至15s的剩余过程。\n\n## svg实现饼图\n[小呆萌](http://jiaolonghuang.github.io/practice/pie/svg-chart.html)\n主要原理：还是利用stroke-dasharray的原理。一个技巧，虚线之间的间距，取一个大于或等于我们当前圆的周长的边距。如果stroke-width比较小出现的就是进度条式的样子。\n\n## conic-gradient\n一行css搞定`background: conic-gradient(#655 40%, yellowgreen 0);`,但是目前还没有浏览器直接支持这个属性，LEA VEROU自己写了一个polyfill来实现(Conical gradients, today!)[http://lea.verou.me/2015/06/conical-gradients-today/]\n",
				"html": "<p>看了w3cplus上的<a href=\"http://www.w3cplus.com/css3/designing-simple-pie-charts-with-css.html\" target=\"_blank\" rel=\"external\">这篇博文</a>后，动手实践了下，弄清楚了实现的原理，同时在此过程中也发现了一些知识盲点，再此记录下。<br><a id=\"more\"></a><br>3种方式，方便程度逐渐递增，但是浏览器的支持程度却也慢慢变差</p>\n<h2 id=\"css3实现饼图\"><a href=\"#css3实现饼图\" class=\"headerlink\" title=\"css3实现饼图\"></a>css3实现饼图</h2><p><a href=\"http://jiaolonghuang.github.io/practice/pie/css3-chart.html\">小呆萌</a><br>主要原理：整个图可以看成是2层纸板，最上面的纸板是半个的，下面的纸板是一个整圆，但是颜色是一半为底色A，一半为需要展现的颜色B。一开始的时候，上面的纸板颜色与底色相同是A，因为是0%，然后不断旋转角度，让需要展现的颜色B逐渐露出来。但是当过了50%之后，上面的纸板就需要变成颜色B了，因为需要展现的颜色应该是越变越多的。</p>\n<ul>\n<li><p>一半一半颜色的实现<br><code>background-image: linear-gradient( to right, transparent 50%, #ed885f 0);</code></p>\n</li>\n<li><p><code>border-radius: 0 100% 100% 0 / 50%;</code><br>以<code>/</code>为分界点，左边的是边框圆角的x半径，右边是y半径。x和y都遵循TRBL(上右下左)都顺序。因此上面的border-radius实际可表示为：<br>border-top-left-radius: 0 50%;<br>bordr-top-right-radius: 100% 50%;<br>border-bottom-right-radius: 100% 50%;<br>border-bottom-left-radius: 0 50%;</p>\n</li>\n<li><p>animation-timing-function中的steps<br>steps(1, start) = step-start;<br>steps(1, end) = step-end;<br>steps(n, start)表示将2个关键帧之间的效果平均分为n步来过渡实现，其中呢，自动略过0%的部分，以下一帧的显示效果来填充间隔动画; 反之，亦然。<br>比如</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.div</span>&#123;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</div><div class=\"line\">\t<span class=\"attribute\">background-color</span>: <span class=\"number\">#333</span>;</div><div class=\"line\">\t<span class=\"attribute\">animation-name</span>: changeBg;</div><div class=\"line\">\t<span class=\"attribute\">animation-duration</span>: <span class=\"number\">10s</span>;</div><div class=\"line\">\t<span class=\"attribute\">animation-timing-function</span>: <span class=\"built_in\">steps</span>( 2, start );</div><div class=\"line\">&#125;</div><div class=\"line\">@<span class=\"keyword\">keyframes</span> changeBg&#123;</div><div class=\"line\">\t<span class=\"selector-tag\">from</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: red;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t50%&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t100%&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: green;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这段代码的意思就是，从0%－50%之间会执行5s，并且此期间，动画会分成2步走，每步走2.5s，第一步首先背景会略过红色，而直接变成橙色，介于红色与黄色之间的一个过渡色，第二步，变成黄色，也就是以50%的这一帧的效果来填充了。剩下的50%同理。如下图所示。<br><img src=\"http://p8.qhimg.com/d/inn/50b09d40/20150814093917.png\" alt=\"\"></p>\n<ul>\n<li><p>下面两段代码的意思是一样的。没必要这样做，在 0% 和 100% keyframe中声明相同的属性和值，浏览器会在动画开始和结束时自动处理属性值。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@<span class=\"keyword\">keyframes</span> changeBg&#123;</div><div class=\"line\">\t50%&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@<span class=\"keyword\">keyframes</span> changeBg&#123;</div><div class=\"line\">\t<span class=\"selector-tag\">from</span>&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: 默认值;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t50%&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: yellow;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t100%&#123;</div><div class=\"line\">\t\t<span class=\"attribute\">background-color</span>: 默认值;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>animation-delay: 负值<br>就好像效果已经在动画开始之前就已经开始进行了。等动画开始的时候，就在那个点继续进行。比如一个效果需要进行15s，而delay了10s，那么在动画开始的时候，我们看到的就是这个效果从第10s之后直至15s的剩余过程。</p>\n</li>\n</ul>\n<h2 id=\"svg实现饼图\"><a href=\"#svg实现饼图\" class=\"headerlink\" title=\"svg实现饼图\"></a>svg实现饼图</h2><p><a href=\"http://jiaolonghuang.github.io/practice/pie/svg-chart.html\">小呆萌</a><br>主要原理：还是利用stroke-dasharray的原理。一个技巧，虚线之间的间距，取一个大于或等于我们当前圆的周长的边距。如果stroke-width比较小出现的就是进度条式的样子。</p>\n<h2 id=\"conic-gradient\"><a href=\"#conic-gradient\" class=\"headerlink\" title=\"conic-gradient\"></a>conic-gradient</h2><p>一行css搞定<code>background: conic-gradient(#655 40%, yellowgreen 0);</code>,但是目前还没有浏览器直接支持这个属性，LEA VEROU自己写了一个polyfill来实现(Conical gradients, today!)[<a href=\"http://lea.verou.me/2015/06/conical-gradients-today/\" target=\"_blank\" rel=\"external\">http://lea.verou.me/2015/06/conical-gradients-today/</a>]</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1439514723000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1439514723000,
				"published_by": 2
			},
			{
				"id": "cj914po0k004pe0hyy5y7i48h",
				"title": "如何使用svg画出具有动画效果的趋势线",
				"slug": "svg-chart",
				"markdown": "svg和canvas都是我们平时常用的html5图形开发技术。一般情况下常见的图形和图表使用它们来完成都没有太大的问题。但是两者在使用场景上还有一些差别。\n<!-- more -->\n\n## Canvas VS SVG\n* canvas是基于位图的。\n * 适合动态渲染和对象数据量大的绘制。\n * 但是canvas只能采用js驱动，不提供图形元素的标签，只有一个`<canvas>`标签，像圆呀，矩形呀等等基本图形都得使用js来实现。\n * 再者，与用户交互的单位是像素点。并且绘制完成后，不能进行修改，只能擦除画布后重新绘制。\n* svg是矢量图形，基于图形元素。\n * 除了`<svg>`标签之外，还提供`<circle>,<path>`等元素。更适合静态图形，对象数据量小，面积大的动画。\n * 可以修改svg中的dom，更容易编辑。所以，更适合做动态交互。\n * 同时，某些场景下，我们可以缓存svg中的dom结构，会比canvas的重绘减少工作量。\n\n## 怎么让趋势线动起来\n这里默认我们已经有了一定的svg基础，就是知道如何绘制基本图形。让趋势线动起来，方法大致可以有3种，[demo](http://jiaolonghuang.github.io/practice/my-first-svg.html)，分别有各自的优缺点。\n\n**首先第一种**，是利用stroke-dasharray和stroke-dashoffset + css3的animation\n\n* stroke-dasharray: x, y\n线长x-空隙长y-线长x-.....\nx = y时：stcok-dasharray: x, y的效果与stock-dasharray: x的相同\n\n* stroke-dashoffset: x\n决定stock-dasharray从x处开始。蓝色的是stock-dash的线，dashoffset决定了整条线向左移动多远\n<img src=\"http://p0.qhimg.com/d/inn/5d9d8f95/1.png\" >\n\n这三条线中stroke-dasharray: 10，stroke-dashoffset分别为0, 5, 10\n<img src=\"http://p9.qhimg.com/d/inn/8d901cf0/2.png\">\n\n\n这样呢，我们就可以现将趋势图path的stroke-dasharray，stroke-dashoffset都设置的非常大，然后最终stroke-dashoffset减少到0，这样趋势图就会有逐渐出现的效果。关键代码如下：\n```\n.chart path {\n\tstroke-dasharray: 1000;\n\tstroke-dashoffset: 1000;\n\tanimation: dash 1.5s linear forwards;\n}\n\n@keyframes dash {\n\tto {\n\t\tstroke-dashoffset: 10;\n\t}\n}\n```\n\n还有2行可能会用到的代码：\n```\nvar path = document.querySelector('path'); // 准确路径\nvar length = path.getTotalLength(); //线条长度\n```\n\n这种方式不仅可以针对规则图形来做动画，也可以针对任意不规则的图形。\n不过若图形是一个组合图形，想要有逐渐出现的效果就稍微麻烦些，需要对变化项不是stroke的元素，单独设置动画，比如demo中几个拐点的圆圈。\n兼容性: IE10-不支持, 主要是animation中不支持stroke相关属性的动画\n\n**第二种方法**是，利用js来动态改变趋势图容器的宽度\n\n这种方法就可以较好的解决组合图形的问题；同时兼容性也比较好。主要是利用定时器来逐渐增大容器的宽度。关键代码如下：\n```\nvar width = 0;\nvar st = setInterval(function(){\n\tif( width > 900){\n\t\tclearInterval( st );\n\t}\n\t$('.chart1').css('width', width);\n\twidth += 5;\n}, .1);\n```\n\n**第三种方法**是，利用animateTransform标签\n虽然有进入的效果，但是确是将整个path作为一个整体进行移入的，没有逐渐显示的效果；同时，IE下不支持svg的`<animate>`标签。\n这里提到这种方法，主要是想说明svg也可以利用标签完成css3中的animation动画效果。\n\n##参考的文章\n* [SVG API](http://tutorials.jenkov.com/svg/index.html)\n* [纯CSS实现帅气的SVG路径描边动画效果](http://www.zhangxinxu.com/wordpress/2014/04/animateion-line-drawing-svg-path-%E5%8A%A8%E7%94%BB-%E8%B7%AF%E5%BE%84/)\n* [超级强大的SVG SMIL animation动画详解](http://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/)\n* [Animated line drawing in SVG](https://jakearchibald.com/2013/animated-line-drawing-svg/)\n\n",
				"html": "<p>svg和canvas都是我们平时常用的html5图形开发技术。一般情况下常见的图形和图表使用它们来完成都没有太大的问题。但是两者在使用场景上还有一些差别。<br><a id=\"more\"></a></p>\n<h2 id=\"Canvas-VS-SVG\"><a href=\"#Canvas-VS-SVG\" class=\"headerlink\" title=\"Canvas VS SVG\"></a>Canvas VS SVG</h2><ul>\n<li>canvas是基于位图的。<ul>\n<li>适合动态渲染和对象数据量大的绘制。</li>\n<li>但是canvas只能采用js驱动，不提供图形元素的标签，只有一个<code>&lt;canvas&gt;</code>标签，像圆呀，矩形呀等等基本图形都得使用js来实现。</li>\n<li>再者，与用户交互的单位是像素点。并且绘制完成后，不能进行修改，只能擦除画布后重新绘制。</li>\n</ul>\n</li>\n<li>svg是矢量图形，基于图形元素。<ul>\n<li>除了<code>&lt;svg&gt;</code>标签之外，还提供<code>&lt;circle&gt;,&lt;path&gt;</code>等元素。更适合静态图形，对象数据量小，面积大的动画。</li>\n<li>可以修改svg中的dom，更容易编辑。所以，更适合做动态交互。</li>\n<li>同时，某些场景下，我们可以缓存svg中的dom结构，会比canvas的重绘减少工作量。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"怎么让趋势线动起来\"><a href=\"#怎么让趋势线动起来\" class=\"headerlink\" title=\"怎么让趋势线动起来\"></a>怎么让趋势线动起来</h2><p>这里默认我们已经有了一定的svg基础，就是知道如何绘制基本图形。让趋势线动起来，方法大致可以有3种，<a href=\"http://jiaolonghuang.github.io/practice/my-first-svg.html\">demo</a>，分别有各自的优缺点。</p>\n<p><strong>首先第一种</strong>，是利用stroke-dasharray和stroke-dashoffset + css3的animation</p>\n<ul>\n<li><p>stroke-dasharray: x, y<br>线长x-空隙长y-线长x-…..<br>x = y时：stcok-dasharray: x, y的效果与stock-dasharray: x的相同</p>\n</li>\n<li><p>stroke-dashoffset: x<br>决定stock-dasharray从x处开始。蓝色的是stock-dash的线，dashoffset决定了整条线向左移动多远<br><img src=\"http://p0.qhimg.com/d/inn/5d9d8f95/1.png\"></p>\n</li>\n</ul>\n<p>这三条线中stroke-dasharray: 10，stroke-dashoffset分别为0, 5, 10<br><img src=\"http://p9.qhimg.com/d/inn/8d901cf0/2.png\"></p>\n<p>这样呢，我们就可以现将趋势图path的stroke-dasharray，stroke-dashoffset都设置的非常大，然后最终stroke-dashoffset减少到0，这样趋势图就会有逐渐出现的效果。关键代码如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.chart</span> <span class=\"selector-tag\">path</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">stroke-dasharray</span>: <span class=\"number\">1000</span>;</div><div class=\"line\">\t<span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">1000</span>;</div><div class=\"line\">\t<span class=\"attribute\">animation</span>: dash <span class=\"number\">1.5s</span> linear forwards;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@<span class=\"keyword\">keyframes</span> dash &#123;</div><div class=\"line\">\t<span class=\"selector-tag\">to</span> &#123;</div><div class=\"line\">\t\t<span class=\"attribute\">stroke-dashoffset</span>: <span class=\"number\">10</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>还有2行可能会用到的代码：<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">document</span>.<span class=\"built_in\">querySelector</span>(<span class=\"string\">'path'</span>); <span class=\"comment\">// 准确路径</span></div><div class=\"line\"><span class=\"keyword\">var</span> length = path.getTotalLength(); <span class=\"comment\">//线条长度</span></div></pre></td></tr></table></figure></p>\n<p>这种方式不仅可以针对规则图形来做动画，也可以针对任意不规则的图形。<br>不过若图形是一个组合图形，想要有逐渐出现的效果就稍微麻烦些，需要对变化项不是stroke的元素，单独设置动画，比如demo中几个拐点的圆圈。<br>兼容性: IE10-不支持, 主要是animation中不支持stroke相关属性的动画</p>\n<p><strong>第二种方法</strong>是，利用js来动态改变趋势图容器的宽度</p>\n<p>这种方法就可以较好的解决组合图形的问题；同时兼容性也比较好。主要是利用定时器来逐渐增大容器的宽度。关键代码如下：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var width = <span class=\"number\">0</span><span class=\"comment\">;</span></div><div class=\"line\">var st = setInterval(<span class=\"name\">function</span>()&#123;</div><div class=\"line\">\tif( <span class=\"name\">width</span> &gt; <span class=\"number\">900</span>)&#123;</div><div class=\"line\">\t\tclearInterval( <span class=\"name\">st</span> )<span class=\"comment\">;</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t$('.chart1').css('width', width)<span class=\"comment\">;</span></div><div class=\"line\">\twidth += <span class=\"number\">5</span><span class=\"comment\">;</span></div><div class=\"line\">&#125;, .<span class=\"number\">1</span>)<span class=\"comment\">;</span></div></pre></td></tr></table></figure></p>\n<p><strong>第三种方法</strong>是，利用animateTransform标签<br>虽然有进入的效果，但是确是将整个path作为一个整体进行移入的，没有逐渐显示的效果；同时，IE下不支持svg的<code>&lt;animate&gt;</code>标签。<br>这里提到这种方法，主要是想说明svg也可以利用标签完成css3中的animation动画效果。</p>\n<p>##参考的文章</p>\n<ul>\n<li><a href=\"http://tutorials.jenkov.com/svg/index.html\" target=\"_blank\" rel=\"external\">SVG API</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2014/04/animateion-line-drawing-svg-path-%E5%8A%A8%E7%94%BB-%E8%B7%AF%E5%BE%84/\" target=\"_blank\" rel=\"external\">纯CSS实现帅气的SVG路径描边动画效果</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/\" target=\"_blank\" rel=\"external\">超级强大的SVG SMIL animation动画详解</a></li>\n<li><a href=\"https://jakearchibald.com/2013/animated-line-drawing-svg/\" target=\"_blank\" rel=\"external\">Animated line drawing in SVG</a></li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1438741299000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1438741299000,
				"published_by": 2
			},
			{
				"id": "cj914po0b004be0hy689w09km",
				"title": "如何使用thinkjs开发一个小系统",
				"slug": "secondThinkJs",
				"markdown": "\nthinkjs是一个简单易用，上手迅速的node.js MVC框架。方便的api, 开发起来简单又好用。\n<!-- more -->\n\n##安装thinkjs\nnpm install thinkjs\n更详细信息见[thinkjs官网](http://thinkjs.org/doc.html \"thinkjs官网\")\n\n##修改配置\n\n* 数据库配置：\n    修改文件： Conf/config.js\n\n     windows下如果使用mysql数据库，推荐使用navicat,可视化数据管理工具\n* 引入其他模块，如q框架\n    www目录下的index.js文件中，require('q');\n\n## 创建文件夹\nLib下创建：Controller,Model, Service, Dao; View文件夹与Lib并列\n* 创建Controller文件夹，Model文件夹，View文件（php常用）\n* 创建Controller文件夹，Service文件夹，Dao文件夹（java常用）\n\n## 全局变量，通用函数\n修改文件：App/Common/common.js\n\n变量和函数都挂在global下，如`global.strTonJson = function(list){};`， 或者某个对象的原型下，如`Date.prototype.format = function(format){};`\n\n##注意事项\n*  文件夹名的大小写\n   windows下不区分文件夹名的大小写，linux下严格区分.\n\n   比如在controller里有这样一个引用`var accService = require('../../service/AccService');`, 如果service文件夹的命名是`Service`，那么在windows下并不会报错，但是在linux环境中会找不到AccService这个文件\n\n## 部署上线\n*  更改配置\n    * 关闭debug，在www/index.js中（很耗内存，导致app卡死，再重启）\n* 连接数据库\n    * 在Conf/config.js中，将 数据库配置改为线上配置\n* 涉及到session，多个服务器之间的一致性\n\n##调试代码\n* 安装inspector:     `npm install node-inspector -g`\n* 之后输入命令：` node-debug index.js `，系统会自动打开浏览器，并且到达断点时屏幕右下方会弹出提示，在使用thinkjs时，刚刚启动程序时也会断点一次。\n<img src=\"/img/node-debug/start.png\" alt=\"\" height=\"300px\" width=\"600px\">\n<img src=\"/img/node-debug/end.png\" alt=\"\" height=\"300px\" width=\"600px\">\n\n## 关于Promise\n1. 使用promise.all\n当需要提前完成二个已上异步操作之后再进行下一步操作时，并且这几个操作之间又无顺序可言，此时，就可以用promise.all来管理。\n\n2. 事务，startTrans，commit，rollback\n比如需要同时向两张关联表插入数据，如组件表和组件版本表，为了保持数据的一致性，任意一张表插入失败都应判定这次操作是失败的。所以应回滚操作。而用事务就可以很好的解决。\n\n3. api不能满足需求时，自己写sql\n\n4. 要return，就需要从最外层就开始return\n否则，拿到的最外层的promise得到的是`undefined`\n\n5. 可以将经常使用到的一类方法（但不是Action），写在一个类中，之后有需要用到的就继承它即可。\n\n6. 给promise的function一个返回值，reject或resolve的\n\n7. 使用catche捕捉错误。\n\n8. 无论是正确还是错误都给一个返回值，用来提示用户或为下一步的处理程序提供方便\n\n## 参考\n1. [thinkjs官网](http://thinkjs.org/doc.html \"thinkjs官网\")\n1. [We have a problem with promises](http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/ \"We have a problem with promises\")",
				"html": "<p>thinkjs是一个简单易用，上手迅速的node.js MVC框架。方便的api, 开发起来简单又好用。<br><a id=\"more\"></a></p>\n<p>##安装thinkjs<br>npm install thinkjs<br>更详细信息见<a href=\"http://thinkjs.org/doc.html\" title=\"thinkjs官网\" target=\"_blank\" rel=\"external\">thinkjs官网</a></p>\n<p>##修改配置</p>\n<ul>\n<li><p>数据库配置：<br>  修改文件： Conf/config.js</p>\n<p>   windows下如果使用mysql数据库，推荐使用navicat,可视化数据管理工具</p>\n</li>\n<li>引入其他模块，如q框架<br>  www目录下的index.js文件中，require(‘q’);</li>\n</ul>\n<h2 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h2><p>Lib下创建：Controller,Model, Service, Dao; View文件夹与Lib并列</p>\n<ul>\n<li>创建Controller文件夹，Model文件夹，View文件（php常用）</li>\n<li>创建Controller文件夹，Service文件夹，Dao文件夹（java常用）</li>\n</ul>\n<h2 id=\"全局变量，通用函数\"><a href=\"#全局变量，通用函数\" class=\"headerlink\" title=\"全局变量，通用函数\"></a>全局变量，通用函数</h2><p>修改文件：App/Common/common.js</p>\n<p>变量和函数都挂在global下，如<code>global.strTonJson = function(list){};</code>， 或者某个对象的原型下，如<code>Date.prototype.format = function(format){};</code></p>\n<p>##注意事项</p>\n<ul>\n<li><p>文件夹名的大小写<br>windows下不区分文件夹名的大小写，linux下严格区分.</p>\n<p>比如在controller里有这样一个引用<code>var accService = require(&#39;../../service/AccService&#39;);</code>, 如果service文件夹的命名是<code>Service</code>，那么在windows下并不会报错，但是在linux环境中会找不到AccService这个文件</p>\n</li>\n</ul>\n<h2 id=\"部署上线\"><a href=\"#部署上线\" class=\"headerlink\" title=\"部署上线\"></a>部署上线</h2><ul>\n<li>更改配置<ul>\n<li>关闭debug，在www/index.js中（很耗内存，导致app卡死，再重启）</li>\n</ul>\n</li>\n<li>连接数据库<ul>\n<li>在Conf/config.js中，将 数据库配置改为线上配置</li>\n</ul>\n</li>\n<li>涉及到session，多个服务器之间的一致性</li>\n</ul>\n<p>##调试代码</p>\n<ul>\n<li>安装inspector:     <code>npm install node-inspector -g</code></li>\n<li>之后输入命令：<code>node-debug index.js</code>，系统会自动打开浏览器，并且到达断点时屏幕右下方会弹出提示，在使用thinkjs时，刚刚启动程序时也会断点一次。<br><img src=\"/img/node-debug/start.png\" alt=\"\" height=\"300px\" width=\"600px\"><br><img src=\"/img/node-debug/end.png\" alt=\"\" height=\"300px\" width=\"600px\"></li>\n</ul>\n<h2 id=\"关于Promise\"><a href=\"#关于Promise\" class=\"headerlink\" title=\"关于Promise\"></a>关于Promise</h2><ol>\n<li><p>使用promise.all<br>当需要提前完成二个已上异步操作之后再进行下一步操作时，并且这几个操作之间又无顺序可言，此时，就可以用promise.all来管理。</p>\n</li>\n<li><p>事务，startTrans，commit，rollback<br>比如需要同时向两张关联表插入数据，如组件表和组件版本表，为了保持数据的一致性，任意一张表插入失败都应判定这次操作是失败的。所以应回滚操作。而用事务就可以很好的解决。</p>\n</li>\n<li><p>api不能满足需求时，自己写sql</p>\n</li>\n<li><p>要return，就需要从最外层就开始return<br>否则，拿到的最外层的promise得到的是<code>undefined</code></p>\n</li>\n<li><p>可以将经常使用到的一类方法（但不是Action），写在一个类中，之后有需要用到的就继承它即可。</p>\n</li>\n<li><p>给promise的function一个返回值，reject或resolve的</p>\n</li>\n<li><p>使用catche捕捉错误。</p>\n</li>\n<li><p>无论是正确还是错误都给一个返回值，用来提示用户或为下一步的处理程序提供方便</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://thinkjs.org/doc.html\" title=\"thinkjs官网\" target=\"_blank\" rel=\"external\">thinkjs官网</a></li>\n<li><a href=\"http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/\" title=\"We have a problem with promises\" target=\"_blank\" rel=\"external\">We have a problem with promises</a></li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1437651758000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1437651758000,
				"published_by": 2
			},
			{
				"id": "cj914po0m004se0hyosvl4b18",
				"title": "关于table中合并单元格的显示",
				"slug": "tableSpan",
				"markdown": "\n最近遇到都一个需求是需要显示一个行合并的列表。知识点比较简单，但是在用的时候容易乱，这里记载下。\n<!-- more -->\n\n### rowspan, colspan\n这两个属性是用在td和tr标签上的。其中**rowspan**表示合并几行，从表现上来看是，单元格变高了。**colspan**表示合并几列，从表现上看是变宽了。\n使用时：\n1. rowspan=3表示，这个单元格将占3行，其中自己一行，另外还要再占2行。那么在计算这两个被占的行的单元格时，就需要少算1个，因为已经被第一行的占去了一个。\n2. 同理，colspan=2, 表示，这个单元格将占去2列的位置，其中自己一列，还有它旁边的1列。\n3. 需要注意的是，每一行中，原子单元格的个数是一样的，```自己这一行中的单元格＋被其他行占的单元格＝固定每行单元格```\n4. 可以动手画草图，有利于我们计算正确的单元格。\n\n### 示意图\n[源码在这里](http://jiaolongHuang.github.io/practice/table/table-span.html)\n<img src=\"http://p9.qhimg.com/d/inn/92db269a/table.png\" width=\"60%\">",
				"html": "<p>最近遇到都一个需求是需要显示一个行合并的列表。知识点比较简单，但是在用的时候容易乱，这里记载下。<br><a id=\"more\"></a></p>\n<h3 id=\"rowspan-colspan\"><a href=\"#rowspan-colspan\" class=\"headerlink\" title=\"rowspan, colspan\"></a>rowspan, colspan</h3><p>这两个属性是用在td和tr标签上的。其中<strong>rowspan</strong>表示合并几行，从表现上来看是，单元格变高了。<strong>colspan</strong>表示合并几列，从表现上看是变宽了。<br>使用时：</p>\n<ol>\n<li>rowspan=3表示，这个单元格将占3行，其中自己一行，另外还要再占2行。那么在计算这两个被占的行的单元格时，就需要少算1个，因为已经被第一行的占去了一个。</li>\n<li>同理，colspan=2, 表示，这个单元格将占去2列的位置，其中自己一列，还有它旁边的1列。</li>\n<li>需要注意的是，每一行中，原子单元格的个数是一样的，<code>自己这一行中的单元格＋被其他行占的单元格＝固定每行单元格</code></li>\n<li>可以动手画草图，有利于我们计算正确的单元格。</li>\n</ol>\n<h3 id=\"示意图\"><a href=\"#示意图\" class=\"headerlink\" title=\"示意图\"></a>示意图</h3><p><a href=\"http://jiaolongHuang.github.io/practice/table/table-span.html\">源码在这里</a><br><img src=\"http://p9.qhimg.com/d/inn/92db269a/table.png\" width=\"60%\"></p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1431308816000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1431308816000,
				"published_by": 2
			},
			{
				"id": "cj914pnzf002ve0hyb43hhybp",
				"title": "《众筹翻译》(20150420更新)",
				"slug": "firstThinkJs",
				"markdown": "\n这是一个小而传统的管理系统，但这不是一个生来就是作为玩具的系统，这是一个需要投入使用的真实系统。\n<!-- more -->\n正因为如此，一直怀着小心翼翼的心态写下第一行代码到现在。\n\n##背景\n1. 项目背景。内部小的管理系统。传统的增改查，权限管理。难点在于，数据之间的同步以及多个action对同一张表的操作。\n2. 技术背景。thinkJs, MySQL, artTemplate, jQuery Validate, jQuery, Materialize\n\n##难点(挑战)\n1. 没有设计图，只有需求。\n2. 对技术中使用的框架不熟悉。\n3. 之前业务中大多是在前人的基础上，针对页面局部进行实现，而缺乏全局统筹的实践能力（比如与提出一些通用方法，通用结构）。\n4. 工作量较大（加班解决@@）。涉及到的逻辑比较复杂。可能到后面为了完成功能而完成功能，忽略了代码了重用性，健壮性等等。\n\n##收获\n1. 用心做一件事，总是会做好的。（前期的UI设计与框架应用，毕竟自己的审美观一再受到质疑。。）\n2. 熟悉了thinkJs的用法和Promise的一些特性。deferred，终了还是没用上。\n4. 对于一个管理系统中权限的管理（通常是判断当前用户能否访问某个url路径），可以采用白名单的方式。所谓的白名单，就是一个对象列表，在访问这个url时，就判断访问的url是否在这个列表里，如果在，那么就允许通过，否则就提示没有权限。\n3. 对SQL语句的温习：多表查询，内联，左联，右联；日期格式化；null的用法\n5. 数据库中码表的使用，就是先将一些固定的状态码写死，比如用户类型，积分值与类型对应等，再次查询时只需联表查询。比如要存积分，如果直接存积分金额会不安全，容易被篡改。但若改为获得积分类型，再通过联表获得积分值，这样虽然也存在被篡改的风险，但是范围已缩小，安全点。\n6. 翻页与瀑布流。瀑布流处理列表中有状态个改变的不太方便（下面有介绍）。但是翻页，会存在用户视线上下跳跃的情况，体验不太好。\n7. 如果逻辑较复杂，流程状态较多的，可以先画流程图，捋清楚了再写。这次就是返工了好几遍。\n\n##值得记录的\n为了满足需求，同一种分页展示，背后采用了3种不同的方法，（如果展示了2+页数据，其中一条数据状态改变了，也要保持2+页的原有顺序，除非是刷新页面，重新获取一遍数据。）\n1. 可以改变数据的状态，取出全部数据，前端做分页\n2. 可以改变数据的状态，一页一页的从数据库里取，将已改变状态的数据放在一个缓存中，下一次也还取出这些数据。\n3. 不可以改变数据的状态，一页一页的从数据库里取。\n\n##令我感动的\n在整个过程中，FM小盆友一直鼓励我。在技术上给予帮助，在心理上给予鼓励。给自己继续把'代码积木'搭下去的信心。\n\n##欠缺\n1. 异常处理\n2. 代码健壮性\n3. 怎么写的优雅点啊。T_T\n4. 也正是以上3点的不足，让自己对自己的代码没有信心。不过正如FM小盆友所讲'好代码都是改出来的'。所以希望待系统上线之时，再来完善这边文章时，可以多一份信心。\n\n##'感悟'\n1. 先说thinkjs\n用过的都说它和thinkphp很像，我没用过thinkphp，但用过也同样是MVC模式的CI框架。所以在了解thinkjs的大体框架后，对它的使用思路并不陌生。不同点大概也只是，controller和model的语法不同，一个php一个js。\n2. 再说前端模板artTemplate\n* artTemplate，体积小，最大的特点是采用了预编译的方式，使得解析速度很快；其次还可以定位模板渲染错误的位置（虽然自认为没太多帮助到我）。但是使用过程中发现其功能很单薄，不像smarty那样有丰富的全局函数。\n\n* 首先thinkjs里默认的view层使用的是ejs模板，那么为什么还要引入一个新的模板artTemplate呢。\n如果view里的页面没有需要'二次请求'才能获取数据的片段，那么只使用一种前端模板同一种界定符是没有问题的。但是如果有，那么该如何处理呢？\n\t* 同一种模板，不区分界定符\n\t\t这里面使用模板，如果不区分界定符号，那么在view渲染时不知道是首次就应该解析渲染了还是等‘二次请求’时再渲染。\n\t* 不同的前端模板\n\t\t本身界定符就不同，解析时会被分开\n3. Materialize的UI框架，与bootstrap差不多，响应式，网格结构。符合谷歌全新设计理念Material design。\n用过之后自我感觉，如果要实现某种样式，类名会比较臃肿。form表单元素表现不是很好，有一些问题作者没有考虑到。比如selection里获取option的值，没有去除option里value的空格（这个比较坑）。但是，整体UI风格尊滴很舒服，漂亮。\n",
				"html": "<p>这是一个小而传统的管理系统，但这不是一个生来就是作为玩具的系统，这是一个需要投入使用的真实系统。<br><a id=\"more\"></a><br>正因为如此，一直怀着小心翼翼的心态写下第一行代码到现在。</p>\n<p>##背景</p>\n<ol>\n<li>项目背景。内部小的管理系统。传统的增改查，权限管理。难点在于，数据之间的同步以及多个action对同一张表的操作。</li>\n<li>技术背景。thinkJs, MySQL, artTemplate, jQuery Validate, jQuery, Materialize</li>\n</ol>\n<p>##难点(挑战)</p>\n<ol>\n<li>没有设计图，只有需求。</li>\n<li>对技术中使用的框架不熟悉。</li>\n<li>之前业务中大多是在前人的基础上，针对页面局部进行实现，而缺乏全局统筹的实践能力（比如与提出一些通用方法，通用结构）。</li>\n<li>工作量较大（加班解决@@）。涉及到的逻辑比较复杂。可能到后面为了完成功能而完成功能，忽略了代码了重用性，健壮性等等。</li>\n</ol>\n<p>##收获</p>\n<ol>\n<li>用心做一件事，总是会做好的。（前期的UI设计与框架应用，毕竟自己的审美观一再受到质疑。。）</li>\n<li>熟悉了thinkJs的用法和Promise的一些特性。deferred，终了还是没用上。</li>\n<li>对于一个管理系统中权限的管理（通常是判断当前用户能否访问某个url路径），可以采用白名单的方式。所谓的白名单，就是一个对象列表，在访问这个url时，就判断访问的url是否在这个列表里，如果在，那么就允许通过，否则就提示没有权限。</li>\n<li>对SQL语句的温习：多表查询，内联，左联，右联；日期格式化；null的用法</li>\n<li>数据库中码表的使用，就是先将一些固定的状态码写死，比如用户类型，积分值与类型对应等，再次查询时只需联表查询。比如要存积分，如果直接存积分金额会不安全，容易被篡改。但若改为获得积分类型，再通过联表获得积分值，这样虽然也存在被篡改的风险，但是范围已缩小，安全点。</li>\n<li>翻页与瀑布流。瀑布流处理列表中有状态个改变的不太方便（下面有介绍）。但是翻页，会存在用户视线上下跳跃的情况，体验不太好。</li>\n<li>如果逻辑较复杂，流程状态较多的，可以先画流程图，捋清楚了再写。这次就是返工了好几遍。</li>\n</ol>\n<p>##值得记录的<br>为了满足需求，同一种分页展示，背后采用了3种不同的方法，（如果展示了2+页数据，其中一条数据状态改变了，也要保持2+页的原有顺序，除非是刷新页面，重新获取一遍数据。）</p>\n<ol>\n<li>可以改变数据的状态，取出全部数据，前端做分页</li>\n<li>可以改变数据的状态，一页一页的从数据库里取，将已改变状态的数据放在一个缓存中，下一次也还取出这些数据。</li>\n<li>不可以改变数据的状态，一页一页的从数据库里取。</li>\n</ol>\n<p>##令我感动的<br>在整个过程中，FM小盆友一直鼓励我。在技术上给予帮助，在心理上给予鼓励。给自己继续把’代码积木’搭下去的信心。</p>\n<p>##欠缺</p>\n<ol>\n<li>异常处理</li>\n<li>代码健壮性</li>\n<li>怎么写的优雅点啊。T_T</li>\n<li>也正是以上3点的不足，让自己对自己的代码没有信心。不过正如FM小盆友所讲’好代码都是改出来的’。所以希望待系统上线之时，再来完善这边文章时，可以多一份信心。</li>\n</ol>\n<p>##’感悟’</p>\n<ol>\n<li>先说thinkjs<br>用过的都说它和thinkphp很像，我没用过thinkphp，但用过也同样是MVC模式的CI框架。所以在了解thinkjs的大体框架后，对它的使用思路并不陌生。不同点大概也只是，controller和model的语法不同，一个php一个js。</li>\n<li>再说前端模板artTemplate</li>\n</ol>\n<ul>\n<li><p>artTemplate，体积小，最大的特点是采用了预编译的方式，使得解析速度很快；其次还可以定位模板渲染错误的位置（虽然自认为没太多帮助到我）。但是使用过程中发现其功能很单薄，不像smarty那样有丰富的全局函数。</p>\n</li>\n<li><p>首先thinkjs里默认的view层使用的是ejs模板，那么为什么还要引入一个新的模板artTemplate呢。<br>如果view里的页面没有需要’二次请求’才能获取数据的片段，那么只使用一种前端模板同一种界定符是没有问题的。但是如果有，那么该如何处理呢？</p>\n<ul>\n<li>同一种模板，不区分界定符<br>  这里面使用模板，如果不区分界定符号，那么在view渲染时不知道是首次就应该解析渲染了还是等‘二次请求’时再渲染。</li>\n<li>不同的前端模板<br>  本身界定符就不同，解析时会被分开</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>Materialize的UI框架，与bootstrap差不多，响应式，网格结构。符合谷歌全新设计理念Material design。<br>用过之后自我感觉，如果要实现某种样式，类名会比较臃肿。form表单元素表现不是很好，有一些问题作者没有考虑到。比如selection里获取option的值，没有去除option里value的空格（这个比较坑）。但是，整体UI风格尊滴很舒服，漂亮。</li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1428912193000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1428912193000,
				"published_by": 2
			},
			{
				"id": "cj914po0f004he0hyxvrwreiq",
				"title": "UTC,GMT等时间概念",
				"slug": "shiqu",
				"markdown": "\n**备忘**。这业务中涉及到需要计算世界时间时，往往会因为时区的关系而有点晕头转向。这里就简单的介绍一下几个关于时间的概念和在前端中与之相关的方法。\n<!-- more -->\n\n##UTC,GMT和CST是什么关系？\n\n* 先来说下GMT是什么。是格林威治(在英国)平均时间。\n* UTC，几乎可以等同于GMT，只是比GMT更严格。\n* 时区。全球24个时区，把以伦敦为中心的世界地图展开，UTC和GMT的伦敦是0区，伦敦的右边直到新西兰的东部不远的斐济为东区，而左边到太平洋中间为西区。一般用5位时区差来表示与UTC相差的小时数，东区为正，西区为负。如北京时区是东八区，领先UTC八个小时，记为+0800；纽约的时区是西五区，比UTC落后五个小时，记为 -0500。**UTC + 时区差 ＝ 本地时间**\n\n* CST，可以同时表示美国，澳大利亚，中国，古巴四个国家的标准时间：\n\t* Central Standard Time (USA) UT-6:00\n\t* Central Standard Time (Australia) UT+9:30\n\t* China Standard Time UT+8:00\n\t* Cuba Standard Time UT-4:00\n\n## 前端中与时间相关的方法\n\n需要注意的是：\n在前端中，无论是php还是js中，有格式显示出来的时间，都是与本地相关，即与本地系统设置(或系统默认)的时区相关。\n如果对方法进行不带时区传参，那就是取的默认。\n\n**php中：**\n\n* time(),从 Unix 纪元（January 1 1970 00:00:00 **GMT**）到当前时间的**秒**。比如如果系统时间分别设置为`Thu Mar 12 2015 07:52:53 GMT+0800 (China Standard Time)`和`Wed Mar 11 2015 20:52:53 GMT-0300 (Local Standard Time)`，通过time()获取到的值是相同的。\n* date_default_timezone_set()设置时区。之后date()格式化之后的时间都是根据设置的时区来显示。\n\n**JS中：**\n\n* new Date(timestamp)，相同的timestamp，在不同时区，new Date()之后的值不同(也就是显示，与本地相关)。但是，如果不带时区直接进行设置，new Date('Thu Mar 12 2015 07:52:53'),如果是在GMT+0800就是相对于GMT+0800将时间设置为Thu Mar 12 2015 07:52:53，如果是在GMT-0300，就是相对于\nGMT-0300将时间设置为Thu Mar 12 2015 07:52:53。设置之后再次分别获取它们的时间戳，getTime()是不同的，因为相同时间，不同时区，相对于格林威治时间的差值不同。\n* getTime()，是获取距1970 年 1 月 1 日之间的**毫秒数**\n* getTimezoneOffset()，获取格林威治时间与本地时间之间的时差，**分钟数**。`UTC时间 + 时区差 = 本地时间`。<0，表示早于UTC时间。比如：\n\n```\n北京所在的东八区时区差记为+0800，纽约所在的西五区时区差记为-0500。\n假设现在是北京时间2015年3月12日，12:35,那么UTC时间和纽约时间可以分别计算为：\n(1) UTC时间 + 时区差(北京) = 本地时间(北京) => UTC时间 = 1235 - (+0800) = 0435,就是2015年3月12日，凌晨4:35\n(2) UTC时间 + 时区差(纽约) = 本地时间(纽约) => 本地时间(纽约) = 本地时间(北京) - 时区差(北京) + 时区差(纽约) = 1235 - (+0800) + (-0500) = -0065。\n(3) **如果出现负数，说明提前一天，需要加上2400**。本地时间(纽约) = -0065 + 2400 = 2335，说明是2015年3月11日，23:35 \n\n注，如果地区又使用夏时令时间，又还会做相应的加减。\n```\n\n* Date.UTC函数采用UTC，返回指定的时间距GMT时间1970年1月1日午夜的毫秒数;而Date对象构造函数采用当地时间。\n\n## 业务中的应用场景\n\n正确显示世界各地时间。显然，正常的逻辑是，无论我们是在北京还是在纽约搜索伦敦时间的时候都应该显示的是伦敦当地的时间，而与用户所在地区的时区无关。\n之前用了new Date()和绝对的时间戳，导致在不同时区，用户搜到的城市时间不同。业务逻辑如下图：\n<img src=\"/img/shiqu/3.png\" alt=\"\" height=\"400px\">\n图2：(其实看到的也是假象)\n<img src=\"/img/shiqu/2.png\" alt=\"\" width=\"500px\">\n图3：(带时区进行时间设置)\n<img src=\"/img/shiqu/1.png\" alt=\"\" width=\"500px\">\n\n##参考的文章\n* [UTC GMT 时区 时间戳](http://blog.csdn.net/iamtrooper/article/details/3900321)\n* [php100里关于Date对象](http://www.php100.com/manual/Javascript/html/jsobjdate.htm)\n",
				"html": "<p><strong>备忘</strong>。这业务中涉及到需要计算世界时间时，往往会因为时区的关系而有点晕头转向。这里就简单的介绍一下几个关于时间的概念和在前端中与之相关的方法。<br><a id=\"more\"></a></p>\n<p>##UTC,GMT和CST是什么关系？</p>\n<ul>\n<li>先来说下GMT是什么。是格林威治(在英国)平均时间。</li>\n<li>UTC，几乎可以等同于GMT，只是比GMT更严格。</li>\n<li><p>时区。全球24个时区，把以伦敦为中心的世界地图展开，UTC和GMT的伦敦是0区，伦敦的右边直到新西兰的东部不远的斐济为东区，而左边到太平洋中间为西区。一般用5位时区差来表示与UTC相差的小时数，东区为正，西区为负。如北京时区是东八区，领先UTC八个小时，记为+0800；纽约的时区是西五区，比UTC落后五个小时，记为 -0500。<strong>UTC + 时区差 ＝ 本地时间</strong></p>\n</li>\n<li><p>CST，可以同时表示美国，澳大利亚，中国，古巴四个国家的标准时间：</p>\n<ul>\n<li>Central Standard Time (USA) UT-6:00</li>\n<li>Central Standard Time (Australia) UT+9:30</li>\n<li>China Standard Time UT+8:00</li>\n<li>Cuba Standard Time UT-4:00</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"前端中与时间相关的方法\"><a href=\"#前端中与时间相关的方法\" class=\"headerlink\" title=\"前端中与时间相关的方法\"></a>前端中与时间相关的方法</h2><p>需要注意的是：<br>在前端中，无论是php还是js中，有格式显示出来的时间，都是与本地相关，即与本地系统设置(或系统默认)的时区相关。<br>如果对方法进行不带时区传参，那就是取的默认。</p>\n<p><strong>php中：</strong></p>\n<ul>\n<li>time(),从 Unix 纪元（January 1 1970 00:00:00 <strong>GMT</strong>）到当前时间的<strong>秒</strong>。比如如果系统时间分别设置为<code>Thu Mar 12 2015 07:52:53 GMT+0800 (China Standard Time)</code>和<code>Wed Mar 11 2015 20:52:53 GMT-0300 (Local Standard Time)</code>，通过time()获取到的值是相同的。</li>\n<li>date_default_timezone_set()设置时区。之后date()格式化之后的时间都是根据设置的时区来显示。</li>\n</ul>\n<p><strong>JS中：</strong></p>\n<ul>\n<li>new Date(timestamp)，相同的timestamp，在不同时区，new Date()之后的值不同(也就是显示，与本地相关)。但是，如果不带时区直接进行设置，new Date(‘Thu Mar 12 2015 07:52:53’),如果是在GMT+0800就是相对于GMT+0800将时间设置为Thu Mar 12 2015 07:52:53，如果是在GMT-0300，就是相对于<br>GMT-0300将时间设置为Thu Mar 12 2015 07:52:53。设置之后再次分别获取它们的时间戳，getTime()是不同的，因为相同时间，不同时区，相对于格林威治时间的差值不同。</li>\n<li>getTime()，是获取距1970 年 1 月 1 日之间的<strong>毫秒数</strong></li>\n<li>getTimezoneOffset()，获取格林威治时间与本地时间之间的时差，<strong>分钟数</strong>。<code>UTC时间 + 时区差 = 本地时间</code>。&lt;0，表示早于UTC时间。比如：</li>\n</ul>\n<figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">北京所在的东八区时区差记为<span class=\"number\">+0800</span>，纽约所在的西五区时区差记为<span class=\"number\">-0500</span>。</div><div class=\"line\">假设现在是北京时间<span class=\"number\">2015</span>年<span class=\"number\">3</span>月<span class=\"number\">12</span>日，<span class=\"number\">12</span>:<span class=\"number\">35</span>,那么UTC时间和纽约时间可以分别计算为：</div><div class=\"line\"><span class=\"comment\">(1)</span> UTC时间 + 时区差<span class=\"comment\">(北京)</span> = 本地时间<span class=\"comment\">(北京)</span> =&gt; UTC时间 = <span class=\"number\">1235</span> - <span class=\"comment\">(+0800)</span> = <span class=\"number\">0435</span>,就是<span class=\"number\">2015</span>年<span class=\"number\">3</span>月<span class=\"number\">12</span>日，凌晨<span class=\"number\">4</span>:<span class=\"number\">35</span></div><div class=\"line\"><span class=\"comment\">(2)</span> UTC时间 + 时区差<span class=\"comment\">(纽约)</span> = 本地时间<span class=\"comment\">(纽约)</span> =&gt; 本地时间<span class=\"comment\">(纽约)</span> = 本地时间<span class=\"comment\">(北京)</span> - 时区差<span class=\"comment\">(北京)</span> + 时区差<span class=\"comment\">(纽约)</span> = <span class=\"number\">1235</span> - <span class=\"comment\">(+0800)</span> + <span class=\"comment\">(-0500)</span> = <span class=\"number\">-0065</span>。</div><div class=\"line\"><span class=\"comment\">(3)</span> **如果出现负数，说明提前一天，需要加上<span class=\"number\">2400</span>**。本地时间<span class=\"comment\">(纽约)</span> = <span class=\"number\">-0065</span> + <span class=\"number\">2400</span> = <span class=\"number\">2335</span>，说明是<span class=\"number\">2015</span>年<span class=\"number\">3</span>月<span class=\"number\">11</span>日，<span class=\"number\">23</span>:<span class=\"number\">35</span> </div><div class=\"line\"></div><div class=\"line\">注，如果地区又使用夏时令时间，又还会做相应的加减。</div></pre></td></tr></table></figure>\n<ul>\n<li>Date.UTC函数采用UTC，返回指定的时间距GMT时间1970年1月1日午夜的毫秒数;而Date对象构造函数采用当地时间。</li>\n</ul>\n<h2 id=\"业务中的应用场景\"><a href=\"#业务中的应用场景\" class=\"headerlink\" title=\"业务中的应用场景\"></a>业务中的应用场景</h2><p>正确显示世界各地时间。显然，正常的逻辑是，无论我们是在北京还是在纽约搜索伦敦时间的时候都应该显示的是伦敦当地的时间，而与用户所在地区的时区无关。<br>之前用了new Date()和绝对的时间戳，导致在不同时区，用户搜到的城市时间不同。业务逻辑如下图：<br><img src=\"/img/shiqu/3.png\" alt=\"\" height=\"400px\"><br>图2：(其实看到的也是假象)<br><img src=\"/img/shiqu/2.png\" alt=\"\" width=\"500px\"><br>图3：(带时区进行时间设置)<br><img src=\"/img/shiqu/1.png\" alt=\"\" width=\"500px\"></p>\n<p>##参考的文章</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/iamtrooper/article/details/3900321\" target=\"_blank\" rel=\"external\">UTC GMT 时区 时间戳</a></li>\n<li><a href=\"http://www.php100.com/manual/Javascript/html/jsobjdate.htm\" target=\"_blank\" rel=\"external\">php100里关于Date对象</a></li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1426132719000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1426132719000,
				"published_by": 2
			},
			{
				"id": "cj914po02003xe0hye3lxu6s6",
				"title": "margin",
				"slug": "margin",
				"markdown": "\n先放两个链接\n<!-- more -->\n\n## 链接\n\nhttp://www.hicss.net/do-not-tell-me-you-understand-margin/\nhttp://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\n",
				"html": "<p>先放两个链接<br><a id=\"more\"></a></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://www.hicss.net/do-not-tell-me-you-understand-margin/\" target=\"_blank\" rel=\"external\">http://www.hicss.net/do-not-tell-me-you-understand-margin/</a><br><a href=\"http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html\" target=\"_blank\" rel=\"external\">http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html</a></p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1422412127000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1422412127000,
				"published_by": 2
			},
			{
				"id": "cj914po0p0050e0hy901s1587",
				"title": "关于Visual formatting model的学习",
				"slug": "vfm",
				"markdown": "\n文档树中的一个元素在网页中是如何通过CSS来确定它自己的布局呢？\n<!-- more -->我们可以把页面中的元素都可以看成是一个矩形的框，那么之前的问题显然与两种因素有关，框的位置和框的大小。那么这两种因素又是如何计算的呢？\n\n## 几个名词概念\n* containing block\n* block-level element,block-level box,block container,block box\n* inline-level element\n* 匿名块级(行内)元素\n* Block Formatting Context(BFC)，Inline Formatting Context(IFC)，都是指containing box中的一种布局的方式\n\nVFM可以理解为是一种文字排版的方式，通常一种box对应的一种排版的上下文，但是在block box中可能存在两种，BFC和IFC。\n\n## 几个block**名词之间的关系\n\n(这里谈论的元素，默认是在普通文档流中)\n\n(1) 首先是block-level element，表象是，这些元素会独占一行，即使是不能占满，也要霸道的不把那一行让给别的元素。\n\n这样的一些元素有，**(1)display:block的(2)display:list-item的(li)(3)display:table的**。\n\n这些block-level element会创建一个叫block-level box的东西，可以给它设置宽和高，已经垂直方向上的margin。\n\n但是不是每一个block-level box都是block-level element，比如table box和replaced element。\n\n(2) 接着是block container，是指只包括block-level box，或者建立了inline formatting context的一种容器，而IFC只能包含inline-level element.\n\n也就是说block container,要么只能全包含block-level box，要么只能全包含inline-level box(block container中的行内元素会被匿名块级盒子包裹，从整体上来看还是一个呈现出block的)。\n\n它可以有以下几种，**(1)block-level box(2)non-replaced inline-block(3)non-replaced table cells**.\n\n(3) 再有如果一个box既是block container又是block-level box，那么这个box被称之为block box。\n\n这部分有点绕，可以看一下下面的示意图\n\n<img src=\"http://p3.qhimg.com/t0138b558f254893586.png\">\n\n## BFC是什么\n\n从表现来看，是处于BFC中的box，从container top开始，由上至下，垂直方向的一个个'落'下来；这些box上下之间的间隙由各box的margin决定，会有margin叠加；并且这些box的margin box的左边挨着container的content box的左边缘；\n\n什么时候情况下能构建出BFC？\n\nfloat,绝对定位的元素；inline-block，table-cell,table-caption的block container；`overflow != visible`的block box\n\n## containing box\n\n通常我们说一个元素的containing box，是要在它的祖先元素上查找这个box。并且这个元素的大小与它的containing box的内容框的大小有关，这个元素的位置与containing box是谁有关。\n\n## 如何确定元素的位置\n\n首先，我们应当清楚的以下3种定位的方案：\n\n(1) 正常文档流中包括的position为relative的块级和行内元素，还有block-level box的block formatting和inline-level box的inline formatting\n\n(2) 绝对定位\n\n(3) float\n\n在[知乎](http://www.zhihu.com/question/20086234)上看到的这个解释的比较好：\n\n<img src=\"http://p2.qhimg.com/t0142268f62285125f7.png\">\n\n## 如何确定元素的大小\n\n先了解下一耳熟能详的盒模型：\n\n<img src=\"http://p2.qhimg.com/t0148b42c70f85c342b.png\" alt=\"\">\n\n关于width，height，margin，padding，再来看下面的这个图，然后再讨论有auto时是如何计算的？\n\n<img src=\"http://p6.qhimg.com/t01666d976006575e06.png\">\n\n\n(1) 对于块级元素(**非替换的行内元素直接设置width,height,垂直方向上的margin是不会生效的**)，从水平方向来说，需要满足下面的公式：\n\n`margin-left+border-left+padding-left+width+padding-right+border-right+margin-right=CBWidth(包含块的content box的宽度)`\n\n(tips:下面讨论的场景都是没有为元素设置padding和border的情况下)\n\n一个auto时：\n\n设置auto的这个属性的宽度=CBWidth-另外两个不是auto的值\n\n二个auto时：\n\n* margin-left(margin-right)和width是auto，那么margin-left(margin-right)会被置为0，而width会尽可能的宽，直到满足上述公式。比如CBWidth=400px,margin-right=100px,那么此时margin-left=0,width=300px.\n* margin-left,margin-right是auto，那么它们俩的宽度将均分CBWidth-width之后的值。也就是假设，CBWidth=400px,width=100px,那么此时margin-left=150px,margin-right=150px.这也就是为什么设置margin-left:auto,margin-right:auto之后，元素会水平居中对齐。\n\n三个auto时：\n\nmargin-left和margin-right都会被置为0，然后width会尽可能的宽，直到等于CBWidth\n\n(2) 对于inline box来说，只有line-height，font-size，vertical这3个属性能对其高度影响\n\nvertical只应用于行内元素，替换元素。vertical设置为%时，是相对于这个元素自身的line-height的。\n\n## 我所理解的VFM里的关系\n\n<img src=\"http://p9.qhimg.com/t01eb9bd2556f0405c6.png\" alt=\"\">\n\n## 参考文章\n* http://swordair.com/block-level-box-block-container-box-block-box/\n* [w3c CS2.1之box](http://www.w3.org/TR/CSS2/box.html)\n* [w3c CS2.1之Visual formatting model](http://www.w3.org/TR/CSS2/visuren.html)\n* [w3c CS2.1之Visual formatting model details](http://www.w3.org/TR/CSS2/visudet.html)\n* http://w3help.org/zh-cn/kb/010/\n* [css-tricks--the-css-box-model](http://css-tricks.com/the-css-box-model/)\n* [不要告诉我你懂margin(里面有好多与margin相关的IE bug及解决方案)](http://www.hicss.net/do-not-tell-me-you-understand-margin/)\n",
				"html": "<p>文档树中的一个元素在网页中是如何通过CSS来确定它自己的布局呢？<br><a id=\"more\"></a>我们可以把页面中的元素都可以看成是一个矩形的框，那么之前的问题显然与两种因素有关，框的位置和框的大小。那么这两种因素又是如何计算的呢？</p>\n<h2 id=\"几个名词概念\"><a href=\"#几个名词概念\" class=\"headerlink\" title=\"几个名词概念\"></a>几个名词概念</h2><ul>\n<li>containing block</li>\n<li>block-level element,block-level box,block container,block box</li>\n<li>inline-level element</li>\n<li>匿名块级(行内)元素</li>\n<li>Block Formatting Context(BFC)，Inline Formatting Context(IFC)，都是指containing box中的一种布局的方式</li>\n</ul>\n<p>VFM可以理解为是一种文字排版的方式，通常一种box对应的一种排版的上下文，但是在block box中可能存在两种，BFC和IFC。</p>\n<h2 id=\"几个block-名词之间的关系\"><a href=\"#几个block-名词之间的关系\" class=\"headerlink\" title=\"几个block**名词之间的关系\"></a>几个block**名词之间的关系</h2><p>(这里谈论的元素，默认是在普通文档流中)</p>\n<p>(1) 首先是block-level element，表象是，这些元素会独占一行，即使是不能占满，也要霸道的不把那一行让给别的元素。</p>\n<p>这样的一些元素有，<strong>(1)display:block的(2)display:list-item的(li)(3)display:table的</strong>。</p>\n<p>这些block-level element会创建一个叫block-level box的东西，可以给它设置宽和高，已经垂直方向上的margin。</p>\n<p>但是不是每一个block-level box都是block-level element，比如table box和replaced element。</p>\n<p>(2) 接着是block container，是指只包括block-level box，或者建立了inline formatting context的一种容器，而IFC只能包含inline-level element.</p>\n<p>也就是说block container,要么只能全包含block-level box，要么只能全包含inline-level box(block container中的行内元素会被匿名块级盒子包裹，从整体上来看还是一个呈现出block的)。</p>\n<p>它可以有以下几种，<strong>(1)block-level box(2)non-replaced inline-block(3)non-replaced table cells</strong>.</p>\n<p>(3) 再有如果一个box既是block container又是block-level box，那么这个box被称之为block box。</p>\n<p>这部分有点绕，可以看一下下面的示意图</p>\n<p><img src=\"http://p3.qhimg.com/t0138b558f254893586.png\"></p>\n<h2 id=\"BFC是什么\"><a href=\"#BFC是什么\" class=\"headerlink\" title=\"BFC是什么\"></a>BFC是什么</h2><p>从表现来看，是处于BFC中的box，从container top开始，由上至下，垂直方向的一个个’落’下来；这些box上下之间的间隙由各box的margin决定，会有margin叠加；并且这些box的margin box的左边挨着container的content box的左边缘；</p>\n<p>什么时候情况下能构建出BFC？</p>\n<p>float,绝对定位的元素；inline-block，table-cell,table-caption的block container；<code>overflow != visible</code>的block box</p>\n<h2 id=\"containing-box\"><a href=\"#containing-box\" class=\"headerlink\" title=\"containing box\"></a>containing box</h2><p>通常我们说一个元素的containing box，是要在它的祖先元素上查找这个box。并且这个元素的大小与它的containing box的内容框的大小有关，这个元素的位置与containing box是谁有关。</p>\n<h2 id=\"如何确定元素的位置\"><a href=\"#如何确定元素的位置\" class=\"headerlink\" title=\"如何确定元素的位置\"></a>如何确定元素的位置</h2><p>首先，我们应当清楚的以下3种定位的方案：</p>\n<p>(1) 正常文档流中包括的position为relative的块级和行内元素，还有block-level box的block formatting和inline-level box的inline formatting</p>\n<p>(2) 绝对定位</p>\n<p>(3) float</p>\n<p>在<a href=\"http://www.zhihu.com/question/20086234\" target=\"_blank\" rel=\"external\">知乎</a>上看到的这个解释的比较好：</p>\n<p><img src=\"http://p2.qhimg.com/t0142268f62285125f7.png\"></p>\n<h2 id=\"如何确定元素的大小\"><a href=\"#如何确定元素的大小\" class=\"headerlink\" title=\"如何确定元素的大小\"></a>如何确定元素的大小</h2><p>先了解下一耳熟能详的盒模型：</p>\n<p><img src=\"http://p2.qhimg.com/t0148b42c70f85c342b.png\" alt=\"\"></p>\n<p>关于width，height，margin，padding，再来看下面的这个图，然后再讨论有auto时是如何计算的？</p>\n<p><img src=\"http://p6.qhimg.com/t01666d976006575e06.png\"></p>\n<p>(1) 对于块级元素(<strong>非替换的行内元素直接设置width,height,垂直方向上的margin是不会生效的</strong>)，从水平方向来说，需要满足下面的公式：</p>\n<p><code>margin-left+border-left+padding-left+width+padding-right+border-right+margin-right=CBWidth(包含块的content box的宽度)</code></p>\n<p>(tips:下面讨论的场景都是没有为元素设置padding和border的情况下)</p>\n<p>一个auto时：</p>\n<p>设置auto的这个属性的宽度=CBWidth-另外两个不是auto的值</p>\n<p>二个auto时：</p>\n<ul>\n<li>margin-left(margin-right)和width是auto，那么margin-left(margin-right)会被置为0，而width会尽可能的宽，直到满足上述公式。比如CBWidth=400px,margin-right=100px,那么此时margin-left=0,width=300px.</li>\n<li>margin-left,margin-right是auto，那么它们俩的宽度将均分CBWidth-width之后的值。也就是假设，CBWidth=400px,width=100px,那么此时margin-left=150px,margin-right=150px.这也就是为什么设置margin-left:auto,margin-right:auto之后，元素会水平居中对齐。</li>\n</ul>\n<p>三个auto时：</p>\n<p>margin-left和margin-right都会被置为0，然后width会尽可能的宽，直到等于CBWidth</p>\n<p>(2) 对于inline box来说，只有line-height，font-size，vertical这3个属性能对其高度影响</p>\n<p>vertical只应用于行内元素，替换元素。vertical设置为%时，是相对于这个元素自身的line-height的。</p>\n<h2 id=\"我所理解的VFM里的关系\"><a href=\"#我所理解的VFM里的关系\" class=\"headerlink\" title=\"我所理解的VFM里的关系\"></a>我所理解的VFM里的关系</h2><p><img src=\"http://p9.qhimg.com/t01eb9bd2556f0405c6.png\" alt=\"\"></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"http://swordair.com/block-level-box-block-container-box-block-box/\" target=\"_blank\" rel=\"external\">http://swordair.com/block-level-box-block-container-box-block-box/</a></li>\n<li><a href=\"http://www.w3.org/TR/CSS2/box.html\" target=\"_blank\" rel=\"external\">w3c CS2.1之box</a></li>\n<li><a href=\"http://www.w3.org/TR/CSS2/visuren.html\" target=\"_blank\" rel=\"external\">w3c CS2.1之Visual formatting model</a></li>\n<li><a href=\"http://www.w3.org/TR/CSS2/visudet.html\" target=\"_blank\" rel=\"external\">w3c CS2.1之Visual formatting model details</a></li>\n<li><a href=\"http://w3help.org/zh-cn/kb/010/\" target=\"_blank\" rel=\"external\">http://w3help.org/zh-cn/kb/010/</a></li>\n<li><a href=\"http://css-tricks.com/the-css-box-model/\" target=\"_blank\" rel=\"external\">css-tricks–the-css-box-model</a></li>\n<li><a href=\"http://www.hicss.net/do-not-tell-me-you-understand-margin/\" target=\"_blank\" rel=\"external\">不要告诉我你懂margin(里面有好多与margin相关的IE bug及解决方案)</a></li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1422254006000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1422254006000,
				"published_by": 2
			},
			{
				"id": "cj914pnz9002oe0hy450ahhkx",
				"title": "如何制作一个时钟",
				"slug": "clock",
				"markdown": "\n如何制作一个时钟呢。这里的时钟指的是，带有指针的那种，而不是电子的。方法至少有2种（因为目前只实践了这两种），css3和canvas\n<!-- more -->\n\n##基础数学知识\n\n我们观察一下时钟，首先想到的是与**角度**有关。再有是，秒针，分针，时针之间的**进位**关系。\n在讲解这两点之前，先考大家一个问题，4点15时，分针与时针之间的夹角是多少呢？（这可是鹅厂某年的面试题之一）\n\n0. 我们都知道`1s = 1 / 60min`,`1min = 1 / 60h`;\n1. 观察任意一款手表或时钟，我们会发现，通常时钟的表盘会被分成12个大格，`5*12=60`个小格，而整个表盘是`360°`，也就是说每个小格是`6°`。换句话说，秒针和分针每动一下，都会走过1小格，走过了`6°`，而时针动一下，则走过了一大格，`5*6°=30°`；因此，秒针和分针移动的基值是6°，时针是30°；\n2. 另外在分针走动的时候，时针也不是静止不动的，而是不甘寂寞的默默向前移动，也就是说当分针动一下，走了6°时，时针实际上也挪动了`1 / 60 * 30° `。所以，计算时针角度时不要忽略了分针对其的影响。（虽然秒针对分针也有着同样的影响，但几乎看不出来，所以，通常我们会将其忽略）\n\n##如何用JS取到当前的秒，分，时\n\n我们制作的时针是基于当前时间，而用角度的形式将其表现出来的，所以取得当前时间是首步\n\n* 获得当前时间，`var date = new Date()`,获得当前时间，以毫秒数表示。\n* `getFullYear()`,4位年份\n* `getMonth()`,从0-11，分别表示1-12月\n* `getDate()`,月份中的天数\n* `getDay()`,从0-6，分别表示星期日-星期六\n* `getHours()`,0-23\n* `getMinutes()`,0-59\n* `getSecond()`,0-59\n\n##确定各指针的角度\n\n综上两个知识点，我们可以将各指针的角度表示为：\n\n```\n\tsdegree = nSeconds * 6 - 90;\n\tmdegree = nMinutes * 6 - 90;\n\thdegree = (nHour%12) * 30 + Math.floor((nMinutes/60)*30) - 90;\n\t（-90，是因为rotateZ角度旋转规则，默认是从水平开始，逆时针为+，顺时针为-）\n```\n##各指针之间的进位关系\n\n如果还要显示此时此刻时钟的数字，那么就会面临另一个难点，临界情况，如，从`2014-12-13 12:38:59-->2014-12-13 12:39:00`，`2014-12-13 12:59:59-->2014-12-13 13:00:00`,`2014-12-13 23:59:59-->2014-12-14 00:00:00`的情况\n\n```\nif(minute != origMinute){\n\ttext(doms.minute,minute);\n\tif(minute == \"00\" && hour != origHour){\n\t\ttext(doms.hour,hour);\n\t\tif(hour == \"00\" && day != origDay){\n\t\t\ttext(doms.day,day);\n\t\t\t// 根据显示文案的不同，如果有必要，重新获取本地的年，月，日\n\t\t\ttext(doms.date,zeroFill(date.getMonth()+1)+\"月\"+zeroFill(date.getDate())+\"日\");\n\t\t}\n\t}\n}\n```\n\n##涉及到的CSS3知识点\n\n1. `transform:rotateZ()`\n\n\t只需要注意1点：rotateZ(弧度)，单位是弧度，即将我们计算的角度通过公式`1° = 180° / π`转化\n\n2. `transform-origin`\n\n\t`transform-origin:left center;`，设定指针的旋转点为最左端，否则，指针将围绕着自己的中点，进行自旋转。\n\n3. `transform: translateZ`\n\n\t**制作表盘中的格格**，这些格格是采用绝对定位，都挤在表盘的中间，这时用`tranform:translateX(75px)`让它们离中心远一点，到表盘边缘去。\n\n[css3时钟](http://jiaolonghuang.github.io/practice/clock.html)--[北京时间](http://m.so.com/s?q=%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4&src=home_input&srcg=home)--[纽约时间](http://m.so.com/s?q=%E7%BA%BD%E7%BA%A6%E6%97%B6%E9%97%B4&src=home_input&srcg=home&pq=%E7%BA%BD%E7%BA%A6shiai%0D%0A%E6%97%B6%E9%97%B4&rg=0&_ms=0&log_id=1499220)\n\n##涉及到的canvas知识点\n\n由于canvas自身的技术特点，在实现上与css3略有不同。\n\n1. 每一秒钟，当前的时钟都不是前一秒的时钟，而是一个新绘制成的时钟。各指针都是重新绘制的。\n\n2. 也就是时钟状态改变的时候，都需要擦除画布，绘制指针\n\n3. canvas也有与css3中transform类似的方法，如rotate，translate，transform，scale等\n\n[canvas时钟](http://jiaolonghuang.github.io/practice/canvas.html)\n\n##校正时间\n\n通常，我们会使用一个定时器（每秒调用一次函数）来让指针动起来。但是当在移动端时，系统处于节约资源的考虑，当屏幕暗下去时，会禁用一些资源，这个定时器就不会工作了。当我们再次点亮屏幕时，发现时间还是停留在上一次关闭屏幕时的状态，只有当再次刷新页面时，时间也会恢复成准确时间。这时，我们可以通过设定**另一个定时器**的方法来校正时间。\n\n```\n// localNow:打开页面时的本地时间\n// now: 打开页面时的系统时间\n// clocker.date: 使用第一个定时器计算的时间\nsetInterval(function(e){\n\tvar localRange = (+new Date) - localNow,\n\t\tactualRange = (+clocker.date) - (+now);\n\tif(Math.abs(localRange - actualRange)/1000 > 10){\n\t\tvar date = new Date();\n\t\tdate.setTime(+now + localRange);\n\t\tclocker.setDate(date).stop().start(callback);\n\t\tdoms.tip.style.visibility = \"visible\";\n\t\tdoms.info.style.visibility = \"hidden\";\n\t\tsetTimeout(function(){\n\t\t\tdoms.tip.style.visibility = \"hidden\";\n\t\t\tdoms.info.style.visibility = \"visible\";\n\t\t},1000);\n\t}\n},500);\n```\n\n##参考的文章\n\n* [js+css3时钟](http://www.cnblogs.com/sky000/archive/2011/02/27/1966173.html)\n\n* [canvas的translate、scale、rotate等方法](http://blog.csdn.net/fengyee_zju/article/details/16994099)\n\n* [CST和GMT时间的区别](http://www.cnblogs.com/sanshi/archive/2009/08/28/1555717.html)\n\n\n\n\n\n",
				"html": "<p>如何制作一个时钟呢。这里的时钟指的是，带有指针的那种，而不是电子的。方法至少有2种（因为目前只实践了这两种），css3和canvas<br><a id=\"more\"></a></p>\n<p>##基础数学知识</p>\n<p>我们观察一下时钟，首先想到的是与<strong>角度</strong>有关。再有是，秒针，分针，时针之间的<strong>进位</strong>关系。<br>在讲解这两点之前，先考大家一个问题，4点15时，分针与时针之间的夹角是多少呢？（这可是鹅厂某年的面试题之一）</p>\n<ol>\n<li>我们都知道<code>1s = 1 / 60min</code>,<code>1min = 1 / 60h</code>;</li>\n<li>观察任意一款手表或时钟，我们会发现，通常时钟的表盘会被分成12个大格，<code>5*12=60</code>个小格，而整个表盘是<code>360°</code>，也就是说每个小格是<code>6°</code>。换句话说，秒针和分针每动一下，都会走过1小格，走过了<code>6°</code>，而时针动一下，则走过了一大格，<code>5*6°=30°</code>；因此，秒针和分针移动的基值是6°，时针是30°；</li>\n<li>另外在分针走动的时候，时针也不是静止不动的，而是不甘寂寞的默默向前移动，也就是说当分针动一下，走了6°时，时针实际上也挪动了<code>1 / 60 * 30°</code>。所以，计算时针角度时不要忽略了分针对其的影响。（虽然秒针对分针也有着同样的影响，但几乎看不出来，所以，通常我们会将其忽略）</li>\n</ol>\n<p>##如何用JS取到当前的秒，分，时</p>\n<p>我们制作的时针是基于当前时间，而用角度的形式将其表现出来的，所以取得当前时间是首步</p>\n<ul>\n<li>获得当前时间，<code>var date = new Date()</code>,获得当前时间，以毫秒数表示。</li>\n<li><code>getFullYear()</code>,4位年份</li>\n<li><code>getMonth()</code>,从0-11，分别表示1-12月</li>\n<li><code>getDate()</code>,月份中的天数</li>\n<li><code>getDay()</code>,从0-6，分别表示星期日-星期六</li>\n<li><code>getHours()</code>,0-23</li>\n<li><code>getMinutes()</code>,0-59</li>\n<li><code>getSecond()</code>,0-59</li>\n</ul>\n<p>##确定各指针的角度</p>\n<p>综上两个知识点，我们可以将各指针的角度表示为：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sdegree = nSeconds * <span class=\"number\">6</span> - <span class=\"number\">90</span>;</div><div class=\"line\">mdegree = nMinutes * <span class=\"number\">6</span> - <span class=\"number\">90</span>;</div><div class=\"line\">hdegree = (nHour%<span class=\"number\">12</span>) * <span class=\"number\">30</span> + Math.floor((nMinutes/<span class=\"number\">60</span>)*<span class=\"number\">30</span>) - <span class=\"number\">90</span>;</div><div class=\"line\">（<span class=\"number\">-90</span>，是因为rotateZ角度旋转规则，默认是从水平开始，逆时针为+，顺时针为-）</div></pre></td></tr></table></figure>\n<p>##各指针之间的进位关系</p>\n<p>如果还要显示此时此刻时钟的数字，那么就会面临另一个难点，临界情况，如，从<code>2014-12-13 12:38:59--&gt;2014-12-13 12:39:00</code>，<code>2014-12-13 12:59:59--&gt;2014-12-13 13:00:00</code>,<code>2014-12-13 23:59:59--&gt;2014-12-14 00:00:00</code>的情况</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">minute</span> != origMinute)&#123;</div><div class=\"line\">\t<span class=\"built_in\">text</span>(doms.<span class=\"built_in\">minute</span>,<span class=\"built_in\">minute</span>);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">minute</span> == <span class=\"string\">\"00\"</span> &amp;&amp; <span class=\"built_in\">hour</span> != origHour)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">text</span>(doms.<span class=\"built_in\">hour</span>,<span class=\"built_in\">hour</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">hour</span> == <span class=\"string\">\"00\"</span> &amp;&amp; <span class=\"built_in\">day</span> != origDay)&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">text</span>(doms.<span class=\"built_in\">day</span>,<span class=\"built_in\">day</span>);</div><div class=\"line\">\t\t\t<span class=\"comment\">// 根据显示文案的不同，如果有必要，重新获取本地的年，月，日</span></div><div class=\"line\">\t\t\t<span class=\"built_in\">text</span>(doms.date,zeroFill(date.getMonth()+<span class=\"number\">1</span>)+<span class=\"string\">\"月\"</span>+zeroFill(date.getDate())+<span class=\"string\">\"日\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>##涉及到的CSS3知识点</p>\n<ol>\n<li><p><code>transform:rotateZ()</code></p>\n<p> 只需要注意1点：rotateZ(弧度)，单位是弧度，即将我们计算的角度通过公式<code>1° = 180° / π</code>转化</p>\n</li>\n<li><p><code>transform-origin</code></p>\n<p> <code>transform-origin:left center;</code>，设定指针的旋转点为最左端，否则，指针将围绕着自己的中点，进行自旋转。</p>\n</li>\n<li><p><code>transform: translateZ</code></p>\n<p> <strong>制作表盘中的格格</strong>，这些格格是采用绝对定位，都挤在表盘的中间，这时用<code>tranform:translateX(75px)</code>让它们离中心远一点，到表盘边缘去。</p>\n</li>\n</ol>\n<p><a href=\"http://jiaolonghuang.github.io/practice/clock.html\">css3时钟</a>–<a href=\"http://m.so.com/s?q=%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4&amp;src=home_input&amp;srcg=home\" target=\"_blank\" rel=\"external\">北京时间</a>–<a href=\"http://m.so.com/s?q=%E7%BA%BD%E7%BA%A6%E6%97%B6%E9%97%B4&amp;src=home_input&amp;srcg=home&amp;pq=%E7%BA%BD%E7%BA%A6shiai%0D%0A%E6%97%B6%E9%97%B4&amp;rg=0&amp;_ms=0&amp;log_id=1499220\" target=\"_blank\" rel=\"external\">纽约时间</a></p>\n<p>##涉及到的canvas知识点</p>\n<p>由于canvas自身的技术特点，在实现上与css3略有不同。</p>\n<ol>\n<li><p>每一秒钟，当前的时钟都不是前一秒的时钟，而是一个新绘制成的时钟。各指针都是重新绘制的。</p>\n</li>\n<li><p>也就是时钟状态改变的时候，都需要擦除画布，绘制指针</p>\n</li>\n<li><p>canvas也有与css3中transform类似的方法，如rotate，translate，transform，scale等</p>\n</li>\n</ol>\n<p><a href=\"http://jiaolonghuang.github.io/practice/canvas.html\">canvas时钟</a></p>\n<p>##校正时间</p>\n<p>通常，我们会使用一个定时器（每秒调用一次函数）来让指针动起来。但是当在移动端时，系统处于节约资源的考虑，当屏幕暗下去时，会禁用一些资源，这个定时器就不会工作了。当我们再次点亮屏幕时，发现时间还是停留在上一次关闭屏幕时的状态，只有当再次刷新页面时，时间也会恢复成准确时间。这时，我们可以通过设定<strong>另一个定时器</strong>的方法来校正时间。</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// localNow:打开页面时的本地时间</span></div><div class=\"line\"><span class=\"comment\">// now: 打开页面时的系统时间</span></div><div class=\"line\"><span class=\"comment\">// clocker.date: 使用第一个定时器计算的时间</span></div><div class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">var</span> localRange = (+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>) - localNow,</div><div class=\"line\">\t\tactualRange = (+clocker.date) - (+now);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">Math</span>.abs(localRange - actualRange)/<span class=\"number\">1000</span> &gt; <span class=\"number\">10</span>)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">var</span> <span class=\"built_in\">date</span> = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\">\t\t<span class=\"built_in\">date</span>.setTime(+now + localRange);</div><div class=\"line\">\t\tclocker.setDate(<span class=\"built_in\">date</span>).stop().start(callback);</div><div class=\"line\">\t\tdoms.tip.style.visibility = <span class=\"string\">\"visible\"</span>;</div><div class=\"line\">\t\tdoms.info.style.visibility = <span class=\"string\">\"hidden\"</span>;</div><div class=\"line\">\t\tsetTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\tdoms.tip.style.visibility = <span class=\"string\">\"hidden\"</span>;</div><div class=\"line\">\t\t\tdoms.info.style.visibility = <span class=\"string\">\"visible\"</span>;</div><div class=\"line\">\t\t&#125;,<span class=\"number\">1000</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;,<span class=\"number\">500</span>);</div></pre></td></tr></table></figure>\n<p>##参考的文章</p>\n<ul>\n<li><p><a href=\"http://www.cnblogs.com/sky000/archive/2011/02/27/1966173.html\" target=\"_blank\" rel=\"external\">js+css3时钟</a></p>\n</li>\n<li><p><a href=\"http://blog.csdn.net/fengyee_zju/article/details/16994099\" target=\"_blank\" rel=\"external\">canvas的translate、scale、rotate等方法</a></p>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/sanshi/archive/2009/08/28/1555717.html\" target=\"_blank\" rel=\"external\">CST和GMT时间的区别</a></p>\n</li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1418461445000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1418461445000,
				"published_by": 2
			},
			{
				"id": "cj914po0c004de0hyai2u1jt7",
				"title": "一周培训总结",
				"slug": "share-copy",
				"markdown": "\n> 庆幸当初的选择，珍惜现在的好机会，持之以恒，坚持~干巴爹\n> 电子版培训笔记，未展开赘述..\n<!-- more -->\n\n##20141104\n###大话重构 - by小强\n\n要看的几篇内容\n\n* HTML5设计原理\n* 面向对象的css\n* 打败ie的葵花宝典\n\n嵌套规则：块级可嵌套所有行内元素，除了`a标签`之外的所有行内元素，不可嵌套块元素\n\n不要给id，class指定标签名\n\n只有在必要时才将class限制在**最近**的父元素内？？(如何理解)\n\n基于web标准的网站：\n* 语义化\n* 结构，界面，行为相分离\n\n层叠：\n* 一层套一层的样式\n* 优先级\n\n高性能HTML：\n* 指定文档字符集\n* 避免空链接属性\n* 避免嵌套层次过深\n\n[分享PPT,7969](http://yunpan.cn/csUVqd4yAmKd2)\n\n### 编写可阅读的代码 - by LC\n* 《人月神话》\n* 《大教堂与集市》\n* 奥卡姆剃刀，不要过度设计 -> 原则上的取舍平衡\n* 德摩根定理\n* 边米特法则，最少知识法则，LKP\n* 别人理解所需时间最小化\n\n[分享PPT](http://www.slideshare.net/LC2009/ss-41099384)\n\n##20141105\n###Jquery开发- by岳文\n\n选择器\n* jquery是用的选择器引擎是**Sizzle**，Sizzle的流程是，分隔表达式->查找元素->过滤元素；Sizzle总是选择先尽可能利用原生方法来查询选择来缩小待选范围，然后才会在待查找范围筛选元素。\n* jquery中css选择器总是从左向右查找，但是如果最右边的第一个选择器中有id，那么就先找第一个，缩小范围后再继续从左向右找。\n* 查找原则就是尽可能的缩小检索范围（特异性越高，检索范围就越小）。一般情况下，ID数量小于NAME数量,NAME数量又小于TAG数量。因此判断顺序就是['ID','NAME','TAG']。\n* $( \":radio\" ) == $( \"[type=radio]\" );在实际应用中，$( \":radio\" ) == $( \"*:radio\" ); 所以建议，$( \"input:radio\" )这样更好。但是$( \":radio\" )是jquery字定义的的，而[type=\"radio\"]是采用了原生的querySelectorAll()实现，所以在现代浏览器中，建议使用[type=\"radio\"]。\n* 自定义的选择器比原生的慢\n* querySelector 最慢，字符串->选择器\n* find(),filter()的区别\n$('div').find('.rain'),在所有div元素内部查找class为rain的元素，组成一个集合。等同于$('div .rain')\n$('div').filter('.rain'),筛选出class为rain的所有div，组成一个集合。\n\n属性\n* attr()与prop()的区别,[可以参考这个](http://www.cnblogs.com/dolphinx/p/3348582.html)\n* 以`checked=\"checked\"`为例，attr(\"checked\")与prop(\"checked\")返回的值是？\n简单说，对于值是true/false的property，如checked等可以动态改变，attr得到的是**checked**，而prop得到的是**true**；prop的改变不会 影响attr，但attr改变会影响prop\n并且以版本1.6为界限，1.6之前，attr得到的是布尔值，并随着checkbox状态的变化而变化；1.6时，始终取得的是最开始checkbox的值，不会动态变化，并且为“checked”这样的字符串；1.6+，会随着checkbox状态的变化而变化，但是返回的是“checked”这样的字符串。\n**所以，浏览器兼容的判断checkebox是否被选中应该使用property**\n\n事件\n* js事件执行的过程，捕获阶段->目标阶段->冒泡阶段\n* attachEvent，addEventListener\n* bind/unbind, live/die, delegate/undelegate,**on/off**\nlive其最终实现也是用的on\n\n延迟对象\n* 分别异步A与B，拼装返回显示在页面？？延迟加载\n* deffered对象\n\n[分享PPT](http://www.slideshare.net/chevionlu/j-query-41184509)\n\n###HTTP- by屈屈\n\n消息推送的方法\n* 轮询，浪费\n* 长轮询，服务端不处理，不返回，等着，挂着。facebook\n* webSocket, 双向通信\n\n跳转\n* 301，永久重定向，客户端直接访问了B域\n* 302，临时重定向\n* 304\n\n502，网关，服务端错误日志\n\n代理，浏览器代替人手工发请求\n\nX-*,自定义的属性\n\n显示文档\n* 判断类型\n* 调用不同引擎\n* img，图片引擎\n\nGET\n* 没有实体\n\nPOST\n* 有实体\n* 带content-length，如果最终的content的内容长度对不上会报错。\n\ncookie\n* 服务端告诉客户端，下次发请求时要带的\n* session，是一个以key当索引，具体的东西放在缓存中，存放的位置：\n内存->对象，重启会丢失\nmemery cache, 不利于分布式\n数据库\n\n**domain，浏览器自己解决的？？？？这是啥**\n\n几个与缓存相关的字段：\n\n* expires，绝对时间。如果客户端与服务器时间不准。\n* max-age，为了改进上面的问题，存的是相对时间\n* ETag，md5(文件内容)，其值与时间无关 ，具体实现方式有不同，没有具体规定\n* expires，在这时间之间啊，浏览器都不应发请求\n* **优先用与时间无关的，或关系小的**\n\ngzip\n* 压缩传输内容，但是不会压缩图片，因为图片本身就是压缩过的。\n* 比如原图4.8K，传的实际大小是5.6k，多出的0.8k，是请求头的大小。\n\n长连接\n\n* HTTP/1.1，默认支持长连接\n* connection: keep-alive\n* 如果有connection：close，则不会有content-length，因为不需要判断内容是多长，读完即可关闭\n\n.php文件大小 ，是它能输出内容的大小。因为php是动态语言\n.js文件大小，因为是静态文件，它的大小就是其本身的大小。\n\n\n* 分块传输\nTransfer-Encodeing:chunked\n长度->内容->长度->内容....直到最后为长度为0时，标志着整个文件传输完成\n\n几个问题？\n\n* 复用TCP时，如何知道每个文件的大小？\n根据所读的content-length的值来判断，如果gzip了，那么就是gzip之后的大小。\n\n* 如果一个文件大小未知，又要保持长连接，如何做到？\n分块传输，在正文中告诉长度\n\n* 能否做到构造IP？\n不能，会把东西发到别人那儿。\n\n* POST是否真的是安全的？\nNO，内容都在正文里。抓包可获得\n**如何做到安全？**\nhttps，在http之上，加了一层\nVPN,整个网络\n加token等等\n\n[PPT看这里看这里](http://jiaolonghuang.github.io/sharing/HTTP.pdf)\n##20141107\n###移动webapp开发- by代平\n\nweb应用开发\n* 分辨率\n* CPU/GPU\n* 传感设备\n\n**尽量用css3还原设计图，而不是用图**\n\nclick的300ms延时，原因？\n* click->touch，touched后才出发click，系统需要确认确实是click事件\n\nmobile开发时,jquery动画效率不高，因为底层没有用transform来实现，zepto好点\n\n单页，多页复杂\n\n###XSS- by成银\n\n先来一个问题：\n* 转义？when？how？\n* 过滤？when？how？\n\nXSS的分类\n* 反射，提前闭合标签，执行恶意js\n* 存储\n* dom，setTimeout，setInterval，可以传string，如果string里有标签\n\n> 不要轻信用户的任何输入！！\n> 尽量还原用户输入\n\n使用模板时，进行校验：\n\n* 入库不做处理\n* 逻辑层不做处理\n* 所有过滤，转义都应在模板里进行->FE\n* 因为逻辑层无法知道变量在模板里的环境（属性？js变量？标签？）\n\ntips：js里的‘/’需要转义，为了防止在正则里，页面不可用\n\n[分享PPT](http://360.75team.com/~lichengyin/ppt/XSS/#/)\n\n##20141108\n###构建可复用的组件- by瓜瓜\n\n一个好组件的特性\n\n[这次先看PPT](http://melonhuang.github.io/sharing/)\n* 易用\n* 一致：代码风格\n* 灵活: 可扩展\n* 可读：逻辑清晰\n\n可扩展性\n**css,js，都不要太具体，只有必须的才写上**\n\n比如一个轮播图\n* 基础的只有切换\n* 怎样的切换效果，通过继承来使用\n\n###各种好用的开发工具- by文博\n\n**todo：**\n好多需要实践的，待实践后补充\n\n调试\n* $ in console,$ 代表 document.querySelector(css选择器)\n* $$,document.querySelectorAll(css选择器)\n* 先选中元素，再console，$0=选中的这个元素\n\n[分享PPT](http://360.75team.com/~zhaowenbo/sharing/)\n\n> 写在最后的话：\n> 这里只记录了分享时的点，并没有详细解释很多，每一个点都可以展开深入了解很多。\n> 分享者所分享的内容，都是经过自己沉淀积累得来的，可能有些地方也未必就是真理，但是至少，给我们提供了一个大方向和可以借鉴的学习方法论\n> 总之，还是那句话，我们要形成自己的见解和看法，别人的经验未必适用于自己\n\n\n",
				"html": "<blockquote>\n<p>庆幸当初的选择，珍惜现在的好机会，持之以恒，坚持~干巴爹<br>电子版培训笔记，未展开赘述..<br><a id=\"more\"></a></p>\n</blockquote>\n<p>##20141104</p>\n<p>###大话重构 - by小强</p>\n<p>要看的几篇内容</p>\n<ul>\n<li>HTML5设计原理</li>\n<li>面向对象的css</li>\n<li>打败ie的葵花宝典</li>\n</ul>\n<p>嵌套规则：块级可嵌套所有行内元素，除了<code>a标签</code>之外的所有行内元素，不可嵌套块元素</p>\n<p>不要给id，class指定标签名</p>\n<p>只有在必要时才将class限制在<strong>最近</strong>的父元素内？？(如何理解)</p>\n<p>基于web标准的网站：</p>\n<ul>\n<li>语义化</li>\n<li>结构，界面，行为相分离</li>\n</ul>\n<p>层叠：</p>\n<ul>\n<li>一层套一层的样式</li>\n<li>优先级</li>\n</ul>\n<p>高性能HTML：</p>\n<ul>\n<li>指定文档字符集</li>\n<li>避免空链接属性</li>\n<li>避免嵌套层次过深</li>\n</ul>\n<p><a href=\"http://yunpan.cn/csUVqd4yAmKd2\" target=\"_blank\" rel=\"external\">分享PPT,7969</a></p>\n<h3 id=\"编写可阅读的代码-by-LC\"><a href=\"#编写可阅读的代码-by-LC\" class=\"headerlink\" title=\"编写可阅读的代码 - by LC\"></a>编写可阅读的代码 - by LC</h3><ul>\n<li>《人月神话》</li>\n<li>《大教堂与集市》</li>\n<li>奥卡姆剃刀，不要过度设计 -&gt; 原则上的取舍平衡</li>\n<li>德摩根定理</li>\n<li>边米特法则，最少知识法则，LKP</li>\n<li>别人理解所需时间最小化</li>\n</ul>\n<p><a href=\"http://www.slideshare.net/LC2009/ss-41099384\" target=\"_blank\" rel=\"external\">分享PPT</a></p>\n<p>##20141105</p>\n<p>###Jquery开发- by岳文</p>\n<p>选择器</p>\n<ul>\n<li>jquery是用的选择器引擎是<strong>Sizzle</strong>，Sizzle的流程是，分隔表达式-&gt;查找元素-&gt;过滤元素；Sizzle总是选择先尽可能利用原生方法来查询选择来缩小待选范围，然后才会在待查找范围筛选元素。</li>\n<li>jquery中css选择器总是从左向右查找，但是如果最右边的第一个选择器中有id，那么就先找第一个，缩小范围后再继续从左向右找。</li>\n<li>查找原则就是尽可能的缩小检索范围（特异性越高，检索范围就越小）。一般情况下，ID数量小于NAME数量,NAME数量又小于TAG数量。因此判断顺序就是[‘ID’,’NAME’,’TAG’]。</li>\n<li>$( “:radio” ) == $( “[type=radio]” );在实际应用中，$( “:radio” ) == $( “*:radio” ); 所以建议，$( “input:radio” )这样更好。但是$( “:radio” )是jquery字定义的的，而[type=”radio”]是采用了原生的querySelectorAll()实现，所以在现代浏览器中，建议使用[type=”radio”]。</li>\n<li>自定义的选择器比原生的慢</li>\n<li>querySelector 最慢，字符串-&gt;选择器</li>\n<li>find(),filter()的区别<br>$(‘div’).find(‘.rain’),在所有div元素内部查找class为rain的元素，组成一个集合。等同于$(‘div .rain’)<br>$(‘div’).filter(‘.rain’),筛选出class为rain的所有div，组成一个集合。</li>\n</ul>\n<p>属性</p>\n<ul>\n<li>attr()与prop()的区别,<a href=\"http://www.cnblogs.com/dolphinx/p/3348582.html\" target=\"_blank\" rel=\"external\">可以参考这个</a></li>\n<li>以<code>checked=&quot;checked&quot;</code>为例，attr(“checked”)与prop(“checked”)返回的值是？<br>简单说，对于值是true/false的property，如checked等可以动态改变，attr得到的是<strong>checked</strong>，而prop得到的是<strong>true</strong>；prop的改变不会 影响attr，但attr改变会影响prop<br>并且以版本1.6为界限，1.6之前，attr得到的是布尔值，并随着checkbox状态的变化而变化；1.6时，始终取得的是最开始checkbox的值，不会动态变化，并且为“checked”这样的字符串；1.6+，会随着checkbox状态的变化而变化，但是返回的是“checked”这样的字符串。<br><strong>所以，浏览器兼容的判断checkebox是否被选中应该使用property</strong></li>\n</ul>\n<p>事件</p>\n<ul>\n<li>js事件执行的过程，捕获阶段-&gt;目标阶段-&gt;冒泡阶段</li>\n<li>attachEvent，addEventListener</li>\n<li>bind/unbind, live/die, delegate/undelegate,<strong>on/off</strong><br>live其最终实现也是用的on</li>\n</ul>\n<p>延迟对象</p>\n<ul>\n<li>分别异步A与B，拼装返回显示在页面？？延迟加载</li>\n<li>deffered对象</li>\n</ul>\n<p><a href=\"http://www.slideshare.net/chevionlu/j-query-41184509\" target=\"_blank\" rel=\"external\">分享PPT</a></p>\n<p>###HTTP- by屈屈</p>\n<p>消息推送的方法</p>\n<ul>\n<li>轮询，浪费</li>\n<li>长轮询，服务端不处理，不返回，等着，挂着。facebook</li>\n<li>webSocket, 双向通信</li>\n</ul>\n<p>跳转</p>\n<ul>\n<li>301，永久重定向，客户端直接访问了B域</li>\n<li>302，临时重定向</li>\n<li>304</li>\n</ul>\n<p>502，网关，服务端错误日志</p>\n<p>代理，浏览器代替人手工发请求</p>\n<p>X-*,自定义的属性</p>\n<p>显示文档</p>\n<ul>\n<li>判断类型</li>\n<li>调用不同引擎</li>\n<li>img，图片引擎</li>\n</ul>\n<p>GET</p>\n<ul>\n<li>没有实体</li>\n</ul>\n<p>POST</p>\n<ul>\n<li>有实体</li>\n<li>带content-length，如果最终的content的内容长度对不上会报错。</li>\n</ul>\n<p>cookie</p>\n<ul>\n<li>服务端告诉客户端，下次发请求时要带的</li>\n<li>session，是一个以key当索引，具体的东西放在缓存中，存放的位置：<br>内存-&gt;对象，重启会丢失<br>memery cache, 不利于分布式<br>数据库</li>\n</ul>\n<p><strong>domain，浏览器自己解决的？？？？这是啥</strong></p>\n<p>几个与缓存相关的字段：</p>\n<ul>\n<li>expires，绝对时间。如果客户端与服务器时间不准。</li>\n<li>max-age，为了改进上面的问题，存的是相对时间</li>\n<li>ETag，md5(文件内容)，其值与时间无关 ，具体实现方式有不同，没有具体规定</li>\n<li>expires，在这时间之间啊，浏览器都不应发请求</li>\n<li><strong>优先用与时间无关的，或关系小的</strong></li>\n</ul>\n<p>gzip</p>\n<ul>\n<li>压缩传输内容，但是不会压缩图片，因为图片本身就是压缩过的。</li>\n<li>比如原图4.8K，传的实际大小是5.6k，多出的0.8k，是请求头的大小。</li>\n</ul>\n<p>长连接</p>\n<ul>\n<li>HTTP/1.1，默认支持长连接</li>\n<li>connection: keep-alive</li>\n<li>如果有connection：close，则不会有content-length，因为不需要判断内容是多长，读完即可关闭</li>\n</ul>\n<p>.php文件大小 ，是它能输出内容的大小。因为php是动态语言<br>.js文件大小，因为是静态文件，它的大小就是其本身的大小。</p>\n<ul>\n<li>分块传输<br>Transfer-Encodeing:chunked<br>长度-&gt;内容-&gt;长度-&gt;内容….直到最后为长度为0时，标志着整个文件传输完成</li>\n</ul>\n<p>几个问题？</p>\n<ul>\n<li><p>复用TCP时，如何知道每个文件的大小？<br>根据所读的content-length的值来判断，如果gzip了，那么就是gzip之后的大小。</p>\n</li>\n<li><p>如果一个文件大小未知，又要保持长连接，如何做到？<br>分块传输，在正文中告诉长度</p>\n</li>\n<li><p>能否做到构造IP？<br>不能，会把东西发到别人那儿。</p>\n</li>\n<li><p>POST是否真的是安全的？<br>NO，内容都在正文里。抓包可获得<br><strong>如何做到安全？</strong><br>https，在http之上，加了一层<br>VPN,整个网络<br>加token等等</p>\n</li>\n</ul>\n<p><a href=\"http://jiaolonghuang.github.io/sharing/HTTP.pdf\">PPT看这里看这里</a></p>\n<p>##20141107</p>\n<p>###移动webapp开发- by代平</p>\n<p>web应用开发</p>\n<ul>\n<li>分辨率</li>\n<li>CPU/GPU</li>\n<li>传感设备</li>\n</ul>\n<p><strong>尽量用css3还原设计图，而不是用图</strong></p>\n<p>click的300ms延时，原因？</p>\n<ul>\n<li>click-&gt;touch，touched后才出发click，系统需要确认确实是click事件</li>\n</ul>\n<p>mobile开发时,jquery动画效率不高，因为底层没有用transform来实现，zepto好点</p>\n<p>单页，多页复杂</p>\n<p>###XSS- by成银</p>\n<p>先来一个问题：</p>\n<ul>\n<li>转义？when？how？</li>\n<li>过滤？when？how？</li>\n</ul>\n<p>XSS的分类</p>\n<ul>\n<li>反射，提前闭合标签，执行恶意js</li>\n<li>存储</li>\n<li>dom，setTimeout，setInterval，可以传string，如果string里有标签</li>\n</ul>\n<blockquote>\n<p>不要轻信用户的任何输入！！<br>尽量还原用户输入</p>\n</blockquote>\n<p>使用模板时，进行校验：</p>\n<ul>\n<li>入库不做处理</li>\n<li>逻辑层不做处理</li>\n<li>所有过滤，转义都应在模板里进行-&gt;FE</li>\n<li>因为逻辑层无法知道变量在模板里的环境（属性？js变量？标签？）</li>\n</ul>\n<p>tips：js里的‘/’需要转义，为了防止在正则里，页面不可用</p>\n<p><a href=\"http://360.75team.com/~lichengyin/ppt/XSS/#/\" target=\"_blank\" rel=\"external\">分享PPT</a></p>\n<p>##20141108</p>\n<p>###构建可复用的组件- by瓜瓜</p>\n<p>一个好组件的特性</p>\n<p><a href=\"http://melonhuang.github.io/sharing/\" target=\"_blank\" rel=\"external\">这次先看PPT</a></p>\n<ul>\n<li>易用</li>\n<li>一致：代码风格</li>\n<li>灵活: 可扩展</li>\n<li>可读：逻辑清晰</li>\n</ul>\n<p>可扩展性<br><strong>css,js，都不要太具体，只有必须的才写上</strong></p>\n<p>比如一个轮播图</p>\n<ul>\n<li>基础的只有切换</li>\n<li>怎样的切换效果，通过继承来使用</li>\n</ul>\n<p>###各种好用的开发工具- by文博</p>\n<p><strong>todo：</strong><br>好多需要实践的，待实践后补充</p>\n<p>调试</p>\n<ul>\n<li>$ in console,$ 代表 document.querySelector(css选择器)</li>\n<li>$$,document.querySelectorAll(css选择器)</li>\n<li>先选中元素，再console，$0=选中的这个元素</li>\n</ul>\n<p><a href=\"http://360.75team.com/~zhaowenbo/sharing/\" target=\"_blank\" rel=\"external\">分享PPT</a></p>\n<blockquote>\n<p>写在最后的话：<br>这里只记录了分享时的点，并没有详细解释很多，每一个点都可以展开深入了解很多。<br>分享者所分享的内容，都是经过自己沉淀积累得来的，可能有些地方也未必就是真理，但是至少，给我们提供了一个大方向和可以借鉴的学习方法论<br>总之，还是那句话，我们要形成自己的见解和看法，别人的经验未必适用于自己</p>\n</blockquote>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1415107236000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1415107236000,
				"published_by": 2
			},
			{
				"id": "cj914pnzb002pe0hy0fny3782",
				"title": "css动效练习集合",
				"slug": "css-practice",
				"markdown": "\n每周一个小练习，持之以恒，坚持~干巴爹\n<!-- more -->\n\n* 20141012 - [animation练习](http://jiaolonghuang.github.io/practice/animation.html)\n* 20141016 - [hover练习1](http://jiaolonghuang.github.io/practice/animation1.html)\n* 20141016 - [hover练习2](http://jiaolonghuang.github.io/practice/animation2.html)\n* 20141020 - [hover练习3](http://jiaolonghuang.github.io/practice/animation-end.html)\n* 20141102 - [transform练习之rotate,translateZ](http://jiaolonghuang.github.io/practice/rotate.html)\n* 20141117 - [百度图片搜索，右侧百科介绍](http://jiaolonghuang.github.io/practice/clone-baidu.html)\n* 20141201 - [径向动画菜单-从中心向四周散开](http://jiaolonghuang.github.io/practice/20141201.html)-[可自定起始角度的(20150201)](http://jiaolonghuang.github.io/practice/circle_menu_new.html)\n* 20141204 - [仿window桌面鼠标选中区域](http://jiaolonghuang.github.io/practice/selectedRec.html)\n* 20141209 - [css3时钟](http://jiaolonghuang.github.io/practice/clock.html)---[canvas时钟](http://jiaolonghuang.github.io/practice/canvas.html)\n* 20141221 - [进度条(无限滚动)](http://jiaolonghuang.github.io/practice/ProgressBars/index.html)\n* 20141231 - [hover-circle-border和hover-top-bottom](http://jiaolonghuang.github.io/practice/hover/hover-circle.html)\n* 20150115 - [一个移动端的页面-memory(使用模拟移动设备打开)](http://jiaolonghuang.github.io/practice/memory.html)---[hover练习-桑格花](http://jiaolonghuang.github.io/practice/flower.html)\n* 20150125 - [图片层叠效果](http://jiaolonghuang.github.io/practice/20150125.html)---[animation会'走'的进度条](http://jiaolonghuang.github.io/practice/20150125-prograss.html)(这次的两个小练习都不是技术很难的，但却是创意很难一下子想到的，算是积累素材吧。)\n* 20150210 - [汉堡包菜单按钮](http://jiaolonghuang.github.io/practice/20150210.html)(精巧的效果需要精密的计算,比如时差，长度等等)\n* 20150716 - [太极图](http://jiaolonghuang.github.io/practice/taiji.html)(利用元素的before和after伪元素可以做出很多规则的图形，基本图形是三角，再利用旋转，border-radius，变形等都可以组合成很多复杂的图形,是一个组合分解的过程)\n* 20150805 - [svg制作有动画效果的趋势线](http://jiaolonghuang.github.io/practice/my-first-svg.html)(3种方法)\n* 20150814 - [css3-pie-chart](http://jiaolonghuang.github.io/practice/pie/css3-chart.html)&&[svg-pie-chart](http://jiaolonghuang.github.io/practice/pie/svg-chart.html)",
				"html": "<p>每周一个小练习，持之以恒，坚持~干巴爹<br><a id=\"more\"></a></p>\n<ul>\n<li>20141012 - <a href=\"http://jiaolonghuang.github.io/practice/animation.html\">animation练习</a></li>\n<li>20141016 - <a href=\"http://jiaolonghuang.github.io/practice/animation1.html\">hover练习1</a></li>\n<li>20141016 - <a href=\"http://jiaolonghuang.github.io/practice/animation2.html\">hover练习2</a></li>\n<li>20141020 - <a href=\"http://jiaolonghuang.github.io/practice/animation-end.html\">hover练习3</a></li>\n<li>20141102 - <a href=\"http://jiaolonghuang.github.io/practice/rotate.html\">transform练习之rotate,translateZ</a></li>\n<li>20141117 - <a href=\"http://jiaolonghuang.github.io/practice/clone-baidu.html\">百度图片搜索，右侧百科介绍</a></li>\n<li>20141201 - <a href=\"http://jiaolonghuang.github.io/practice/20141201.html\">径向动画菜单-从中心向四周散开</a>-<a href=\"http://jiaolonghuang.github.io/practice/circle_menu_new.html\">可自定起始角度的(20150201)</a></li>\n<li>20141204 - <a href=\"http://jiaolonghuang.github.io/practice/selectedRec.html\">仿window桌面鼠标选中区域</a></li>\n<li>20141209 - <a href=\"http://jiaolonghuang.github.io/practice/clock.html\">css3时钟</a>—<a href=\"http://jiaolonghuang.github.io/practice/canvas.html\">canvas时钟</a></li>\n<li>20141221 - <a href=\"http://jiaolonghuang.github.io/practice/ProgressBars/index.html\">进度条(无限滚动)</a></li>\n<li>20141231 - <a href=\"http://jiaolonghuang.github.io/practice/hover/hover-circle.html\">hover-circle-border和hover-top-bottom</a></li>\n<li>20150115 - <a href=\"http://jiaolonghuang.github.io/practice/memory.html\">一个移动端的页面-memory(使用模拟移动设备打开)</a>—<a href=\"http://jiaolonghuang.github.io/practice/flower.html\">hover练习-桑格花</a></li>\n<li>20150125 - <a href=\"http://jiaolonghuang.github.io/practice/20150125.html\">图片层叠效果</a>—<a href=\"http://jiaolonghuang.github.io/practice/20150125-prograss.html\">animation会’走’的进度条</a>(这次的两个小练习都不是技术很难的，但却是创意很难一下子想到的，算是积累素材吧。)</li>\n<li>20150210 - <a href=\"http://jiaolonghuang.github.io/practice/20150210.html\">汉堡包菜单按钮</a>(精巧的效果需要精密的计算,比如时差，长度等等)</li>\n<li>20150716 - <a href=\"http://jiaolonghuang.github.io/practice/taiji.html\">太极图</a>(利用元素的before和after伪元素可以做出很多规则的图形，基本图形是三角，再利用旋转，border-radius，变形等都可以组合成很多复杂的图形,是一个组合分解的过程)</li>\n<li>20150805 - <a href=\"http://jiaolonghuang.github.io/practice/my-first-svg.html\">svg制作有动画效果的趋势线</a>(3种方法)</li>\n<li>20150814 - <a href=\"http://jiaolonghuang.github.io/practice/pie/css3-chart.html\">css3-pie-chart</a>&amp;&amp;<a href=\"http://jiaolonghuang.github.io/practice/pie/svg-chart.html\">svg-pie-chart</a></li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1414985897000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1414985897000,
				"published_by": 2
			},
			{
				"id": "cj914pnzd002se0hyz6ai0as2",
				"title": "CSS学习1：《精通CSS》读书笔记",
				"slug": "css-study",
				"markdown": "\n温故而知新，持之以恒，坚持~干巴爹\n<!-- more -->\n\n###基础知识\n\n1. 文档的意义：代码易维护；面向程序和其他设备更有意义；代码更少，下载更快\n2. ID：页面上特定的元素，且唯一；持久性结构元素，主导航，内容区等；一次性元素，form等\n3. 命名：这个元素是什么，而不是长的什么样。可以通过这个命名找到对应的元素。重用。\n4. 确定这个元素只会出现一次，用ID；以后可能需要相似的元素，用类。\n5. IE6在标准模式下，正常盒模型；混杂模式下，老式专有盒模型。\n6. DTD不存在或不正确，会触发混杂模式；有**过渡DTD而没有URI？？？**也会；DTD不是页面中的第一个元素，IE6也会触发。\n7. css，import速度比link慢\n\n###可视化格式模型\n\n1. outline不会影响元素的大小和定位。ie7+\n2. **普通文档流**中**块框**垂直margin才会叠加。float，absoulte，inline框的margin都不会叠加。\n3. 普通流中的元素框位置由元素在html中的位置决定\n4. 行内框，垂直padding，垂直margin，垂直边框，对其**高度**无影响。显式设定其height和weight没有效果。除非修改**行高**\n5. 在块级元素标签(如p)开头处添加一些文本 ，这些文本形成匿名块级框。\n```html\n<div>hello world~~~~~~~<p>hello</p></div>\n```\n6. 同理，如果在行内元素标签(如span)开头加文本，则形成匿名行内框。\n```html\n<a href=\"##\">hello world~~~~~~~<span>hello</span></a>\n```\n7. position\n* relative: 元素占据自己原来的位置，移动是相对于自己原来的位置\n* absolute: 不占据空间。普通文档流中的其他元素就好像没看到它一样。移动相对于离它最近的已定位(除了static的)的祖先元素。\n* ie6的bug，相对于relative进行absolute，右边或底部，需要确保relative的祖先元素设定了宽高，否则会相对画布定位。\n* fixed，相对于viewport的绝对定位。ie7+\n8. float,元素不在文档的普通流中。其他没浮动的元素(框好像没看到它，但是框内的文本信息，会环绕着浮动元素)像没看到它一样。浮动停止的位置，是碰到包含框的边缘或是其他浮动元素的边缘。\n9. opacity,不透明度。除了对背景生效，元素中包含的内容也继承了这个属性。\n\n###浏览器，table，form\n1. 浏览器默认对页面缩放而不是文本，也就是说，布局，格式和文字大小都会同比例变化\n2. border-spacing(IE8+),IE7-,可以用cellspacing\n3. fieldset,legend,label(for),input(与img一样是可置换元素，表现和inline-block差不多，display是inline的，却可以 设置宽高)\n4. 对于button标签，ie6,ie7，提交元素本身的内容，其他浏览器提交value的值。如果页面上 有多个按钮 ，ie6会提交所有按钮的内容。",
				"html": "<p>温故而知新，持之以恒，坚持~干巴爹<br><a id=\"more\"></a></p>\n<p>###基础知识</p>\n<ol>\n<li>文档的意义：代码易维护；面向程序和其他设备更有意义；代码更少，下载更快</li>\n<li>ID：页面上特定的元素，且唯一；持久性结构元素，主导航，内容区等；一次性元素，form等</li>\n<li>命名：这个元素是什么，而不是长的什么样。可以通过这个命名找到对应的元素。重用。</li>\n<li>确定这个元素只会出现一次，用ID；以后可能需要相似的元素，用类。</li>\n<li>IE6在标准模式下，正常盒模型；混杂模式下，老式专有盒模型。</li>\n<li>DTD不存在或不正确，会触发混杂模式；有<strong>过渡DTD而没有URI？？？</strong>也会；DTD不是页面中的第一个元素，IE6也会触发。</li>\n<li>css，import速度比link慢</li>\n</ol>\n<p>###可视化格式模型</p>\n<ol>\n<li>outline不会影响元素的大小和定位。ie7+</li>\n<li><strong>普通文档流</strong>中<strong>块框</strong>垂直margin才会叠加。float，absoulte，inline框的margin都不会叠加。</li>\n<li>普通流中的元素框位置由元素在html中的位置决定</li>\n<li>行内框，垂直padding，垂直margin，垂直边框，对其<strong>高度</strong>无影响。显式设定其height和weight没有效果。除非修改<strong>行高</strong></li>\n<li><p>在块级元素标签(如p)开头处添加一些文本 ，这些文本形成匿名块级框。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>hello world~~~~~~~<span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>同理，如果在行内元素标签(如span)开头加文本，则形成匿名行内框。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"##\"</span>&gt;</span>hello world~~~~~~~<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>position</p>\n</li>\n</ol>\n<ul>\n<li>relative: 元素占据自己原来的位置，移动是相对于自己原来的位置</li>\n<li>absolute: 不占据空间。普通文档流中的其他元素就好像没看到它一样。移动相对于离它最近的已定位(除了static的)的祖先元素。</li>\n<li>ie6的bug，相对于relative进行absolute，右边或底部，需要确保relative的祖先元素设定了宽高，否则会相对画布定位。</li>\n<li>fixed，相对于viewport的绝对定位。ie7+</li>\n</ul>\n<ol>\n<li>float,元素不在文档的普通流中。其他没浮动的元素(框好像没看到它，但是框内的文本信息，会环绕着浮动元素)像没看到它一样。浮动停止的位置，是碰到包含框的边缘或是其他浮动元素的边缘。</li>\n<li>opacity,不透明度。除了对背景生效，元素中包含的内容也继承了这个属性。</li>\n</ol>\n<p>###浏览器，table，form</p>\n<ol>\n<li>浏览器默认对页面缩放而不是文本，也就是说，布局，格式和文字大小都会同比例变化</li>\n<li>border-spacing(IE8+),IE7-,可以用cellspacing</li>\n<li>fieldset,legend,label(for),input(与img一样是可置换元素，表现和inline-block差不多，display是inline的，却可以 设置宽高)</li>\n<li>对于button标签，ie6,ie7，提交元素本身的内容，其他浏览器提交value的值。如果页面上 有多个按钮 ，ie6会提交所有按钮的内容。</li>\n</ol>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1414467858000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1414467858000,
				"published_by": 2
			},
			{
				"id": "cj914po0h004ke0hyyp4vdkgs",
				"title": "JS学习1：如何写出一个suggest组件",
				"slug": "sug",
				"markdown": "##| suggest是什么？\n* suggest(后文统一简称为sug)的中文意思是，'建议，提议;暗示;使想起;启示'。经常被用做用户的输入提示。\n<!-- more -->\n* 也就是说sug的主要功能是提示用户输入，而不是一个结果的展示框，更不是一个实时的下拉列表。（为什么要这样区别，后面会娓娓道来~）\n* 当然，用sug来做数据的校验更是不合适的。\n\n---\n\n##| sug的逻辑及会涉及的事件？\n\n好的，我们先来梳理一下当我们使用sug时自己的操作习惯和流程。\n\n1. 首先我们期望，sug可以根据自己在输入框中**输入**或**删除**字符，而给出不同的提示。也就是说这是一个实时动态变化的。\n2. 当我们可以根据键盘的上、下键来选择自己本来想要输入的内容，这样自己可以节省很多时间和体力嘛（其实就是懒）\n3. 当使用键盘选中后，敲回车时，sug中被选中的内容会自动跑到input输入框里。\n4. 除了使用上下键，我们可能还期望使用鼠标点击某个内容，就可以让被选中的内容跑到输入框里。\n5. 为了满足第3点，就需要当鼠标移上某个内容时，这个内容必须要与其他未选中的内容区分，否则我们也不知道是选的哪一个啊。\n6. 另外呢，我们当然还期望有比较好的用户体验啦。\n * 点击除了sug列表的其他位置时，sug会消失\n * sug列表中默认就选中第一条数据，而不是需要按一下神马键再选中第一条，多此一举。\n * 按上、下键来选择内容时，如果列表中只有1条数据，那无论怎么按上下键，就保持原状啊；如果有多条，那可以循环去按呀，从头->尾，从尾->头。\n \n---\n\n那么按照上述的逻辑，映射到代码层面上，我们会需要监听和涉及到哪些事件呢？\n####|| input\n* 与ie兼容，同时监听`propertychange`(IE专有，好牛气的赶脚)\n* 为啥不用onchange事件呢？oninput，onpropertychange，onchange究竟有啥区别呢？\n * onpropertychange, IE专有，当前对象的属性(`checked,value,selectedIndex`)发生变化时，都会触发这个事件\n * oninput, 现代浏览器可用，只有当前对象的value值发生变化时，才会触发该事件\n * onchange, value值发生了变化，并且失去焦点时才会触发；并且是由鼠标或键盘改变，如果是脚本改变的值，那也不能触发该事件。\n * 还有一个onkeyup事件，这个能用来监听用户通过键盘输入的value值变化，但是如果是复制粘贴来的值，就无法检测到。\n\n**所以，综上选择oninput & onpropertychange 为监听输入框值变化的方案**\n\n---\n\n####|| click\n* 被选中li节点\n * 将对应的数据添加到input中\n* sug范围外的区域\n * remove所有的sug列表\n \n---\n\n####|| keydown\n\n在这里，值得注意的是，我们需要设置一个sug类的私有变量selectedNode，用来保存当前被选中的节点。这样在之后通过enter或click才能将被选中的值放入input中。\n\n* up, down, enter对应的`e.keycode`分别是`38`,`40`,`13`\n* up,down\n在这儿，需要完成两件事，(1)删除上一次selectedNode的背景，(2)保存当前被选中的节点为selectedNode。\n当然，还需要注意，如果sug列表中节点的数量**大于1**时，才需要完成上面2件事。否则保持现状即可。\n* enter\n在改写**@小生爱** 的源码中，有这样一个小bug，如果sug中有值，而sug列表自身被隐藏，enter会把默认选中的第一条选到input中。\n为了解决这个问题，在enter时间中，我首先检测当前的sug列表是否是隐藏着的，如果是，那么就不执行enter事件。也就避免了将本来默认选中的第1条数据误添加到input中。\n\n---\n\n####|| mouseover\n\n鼠标滑过li节点时，对应的节点变为选中状态，增强用户体验。\n\n---\n####|| 确定sug的位置\n\n一般我们期望的sug位置是在input输入框的正下方，所以可以确定：\n\n* `sug的top = input输入框距当前视口顶部的距离 + input输入框本身的高度`\n* `sug的left = input输入框距当前视口左边的距离` \n* 获得input输入框距当前视口的距离，`$(input).offset()`\n* input输入框本身的高度,`$(input).offsetHeight`\n\n---\n\n最后，[附上sug列表的js代码](http://jiaolonghuang.github.io/jsme/sug.js).\n\n---\n##| 可改进的点\n\n目前这样做完，在体验上还是有可改进点的(目前只想到了这一个- -.等以后想到了随时补充)。\n\n* blur: blur时，检测数据，并remove sug.\n\n---\n\n##| 具体写码时的坑\n* placeholder兼容\n检测如果文档创建一个新的input，其中是否具有placeholder属性\n```\nvar placeholder = function (){\n    // 判断是否支持placeholder\n    if('placeholder' in document.createElement('input')) return false;\n\t// 要添加holder的表单节点\n\tvar elInputs = $('.js-placeholder', root);\n\t// 初始化表单\n\t$.each(elInputs, function (){\n\t\t$(this).val($(this).attr('placeholder'));\n\t});\n\t// 添加事件\n\telInputs.on('focus blur', function (e){\n\t\tvar type = e.type;\n\t\tvar elInput = $(this);\n\t\t// 表单默认值\n\t\tvar initInput = elInput.attr('placeholder');\n\t\tif(type == 'focus' && elInput.val() == initInput){\n\t\t\t// 获取焦点 表单置空\n\t\t\telInput.val('');\n\t\t}else if(type=='blur' && elInput.val()==''){\n\t\t\telInput.val(initInput);\n\t\t}\n\t});\n};\n```\n* 纳尼？ie6/7下,背景消失了！！！\n\n * 这种现象一般是由于代码里同时包含这两句，`display:inline-block;text-indent: -999em`\n\n * 原因：ie6/7并未实现真的的`inline-block`，它只所有具有`inline-block`的某些特征，是因为元素触发了`hasLayout`，而因此让元素拥有了`inline-block`的表症。\n * **如何解决呢？** 无非两种，从**`display`**来考虑，从**与字体相关的**考虑\n * 方案一：display：block\n * 方案二：font-size:0;line-height:0\n * 方案三：line-height:900px；overflow：hidden\n\n* ie7,`width: 100%`,没宽度了？\n\n* [如何写出一个合适的input](http://qianduanblog.com/post/css-learning-21-using-html-css-write-an-input-box.html)\n * 不要给input设置固定高度\n * 用padding撑开input的高度\n * 不要给input设置行高\n * 如果需要改变光标的高度，改变font-size的值\n\n* 如何弥补把sug当作查询结果集的缺点？\n * 查询已知的现有数据集，再做一次验证。\n\n* pm想用sug当结果显示框，结果呢？\n\n * 之前说到过sug本质上一个提示功能，为用户的输入起到一定的辅助功能。当遇到这样的场景时，就显得特别不合适了。\n * 背景：\n(1)input中的内容来源有两个，从sug中选中的，用户自己输入的；\n(2)当用户输入一个百分百匹配的词时，sug并不会给出提示(你都知道要输入啥了，就没有提示的必要了呀)\n * 场景：\n将用户输入框内的正确内容做为参数传给后端。我们知道sug里的内容，肯定是百分之百正确的，所以根据sug得到的内容可以直接发到后端。但是当用户输入‘望京西’时，这是一个百分百匹配的词，sug中返回的结果是空。\n这时，我们如果分辨不是从sug中得来的input内容是正确的还是错误的呢？\n也就是说，没有直接的办法可以判断‘望京西’和‘望京西乱七八糟’哪个是正确的。\n这时，使用sug作为结果显示框是不妥的，应当像上一条提到的一样，再次查询已知的现有结果集，来做验证。\n\n---\n##| 小技巧\n* `flag && a = b`\n其实这样等同于,不仅代码变得简洁了，而且更有效率了。\n```\nif(flag){\n\ta =b\n}\n```\n* 验证是否包含在某个数据集中？**Hash，对象**\n`obj['key'] == 1`，不用循环遍历\n* 指定异步回调函数名\n```\ndataType: jsonp,\njsonpCallback: 回调函数名,\ndata:{\n\ta : a,\n\tb : b\n\t}\n```\n\n",
				"html": "<p>##| suggest是什么？</p>\n<ul>\n<li>suggest(后文统一简称为sug)的中文意思是，’建议，提议;暗示;使想起;启示’。经常被用做用户的输入提示。<a id=\"more\"></a></li>\n<li>也就是说sug的主要功能是提示用户输入，而不是一个结果的展示框，更不是一个实时的下拉列表。（为什么要这样区别，后面会娓娓道来~）</li>\n<li>当然，用sug来做数据的校验更是不合适的。</li>\n</ul>\n<hr>\n<p>##| sug的逻辑及会涉及的事件？</p>\n<p>好的，我们先来梳理一下当我们使用sug时自己的操作习惯和流程。</p>\n<ol>\n<li>首先我们期望，sug可以根据自己在输入框中<strong>输入</strong>或<strong>删除</strong>字符，而给出不同的提示。也就是说这是一个实时动态变化的。</li>\n<li>当我们可以根据键盘的上、下键来选择自己本来想要输入的内容，这样自己可以节省很多时间和体力嘛（其实就是懒）</li>\n<li>当使用键盘选中后，敲回车时，sug中被选中的内容会自动跑到input输入框里。</li>\n<li>除了使用上下键，我们可能还期望使用鼠标点击某个内容，就可以让被选中的内容跑到输入框里。</li>\n<li>为了满足第3点，就需要当鼠标移上某个内容时，这个内容必须要与其他未选中的内容区分，否则我们也不知道是选的哪一个啊。</li>\n<li>另外呢，我们当然还期望有比较好的用户体验啦。<ul>\n<li>点击除了sug列表的其他位置时，sug会消失</li>\n<li>sug列表中默认就选中第一条数据，而不是需要按一下神马键再选中第一条，多此一举。</li>\n<li>按上、下键来选择内容时，如果列表中只有1条数据，那无论怎么按上下键，就保持原状啊；如果有多条，那可以循环去按呀，从头-&gt;尾，从尾-&gt;头。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p>那么按照上述的逻辑，映射到代码层面上，我们会需要监听和涉及到哪些事件呢？</p>\n<p>####|| input</p>\n<ul>\n<li>与ie兼容，同时监听<code>propertychange</code>(IE专有，好牛气的赶脚)</li>\n<li>为啥不用onchange事件呢？oninput，onpropertychange，onchange究竟有啥区别呢？<ul>\n<li>onpropertychange, IE专有，当前对象的属性(<code>checked,value,selectedIndex</code>)发生变化时，都会触发这个事件</li>\n<li>oninput, 现代浏览器可用，只有当前对象的value值发生变化时，才会触发该事件</li>\n<li>onchange, value值发生了变化，并且失去焦点时才会触发；并且是由鼠标或键盘改变，如果是脚本改变的值，那也不能触发该事件。</li>\n<li>还有一个onkeyup事件，这个能用来监听用户通过键盘输入的value值变化，但是如果是复制粘贴来的值，就无法检测到。</li>\n</ul>\n</li>\n</ul>\n<p><strong>所以，综上选择oninput &amp; onpropertychange 为监听输入框值变化的方案</strong></p>\n<hr>\n<p>####|| click</p>\n<ul>\n<li>被选中li节点<ul>\n<li>将对应的数据添加到input中</li>\n</ul>\n</li>\n<li>sug范围外的区域<ul>\n<li>remove所有的sug列表</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>####|| keydown</p>\n<p>在这里，值得注意的是，我们需要设置一个sug类的私有变量selectedNode，用来保存当前被选中的节点。这样在之后通过enter或click才能将被选中的值放入input中。</p>\n<ul>\n<li>up, down, enter对应的<code>e.keycode</code>分别是<code>38</code>,<code>40</code>,<code>13</code></li>\n<li>up,down<br>在这儿，需要完成两件事，(1)删除上一次selectedNode的背景，(2)保存当前被选中的节点为selectedNode。<br>当然，还需要注意，如果sug列表中节点的数量<strong>大于1</strong>时，才需要完成上面2件事。否则保持现状即可。</li>\n<li>enter<br>在改写<strong>@小生爱</strong> 的源码中，有这样一个小bug，如果sug中有值，而sug列表自身被隐藏，enter会把默认选中的第一条选到input中。<br>为了解决这个问题，在enter时间中，我首先检测当前的sug列表是否是隐藏着的，如果是，那么就不执行enter事件。也就避免了将本来默认选中的第1条数据误添加到input中。</li>\n</ul>\n<hr>\n<p>####|| mouseover</p>\n<p>鼠标滑过li节点时，对应的节点变为选中状态，增强用户体验。</p>\n<hr>\n<p>####|| 确定sug的位置</p>\n<p>一般我们期望的sug位置是在input输入框的正下方，所以可以确定：</p>\n<ul>\n<li><code>sug的top = input输入框距当前视口顶部的距离 + input输入框本身的高度</code></li>\n<li><code>sug的left = input输入框距当前视口左边的距离</code> </li>\n<li>获得input输入框距当前视口的距离，<code>$(input).offset()</code></li>\n<li>input输入框本身的高度,<code>$(input).offsetHeight</code></li>\n</ul>\n<hr>\n<p>最后，<a href=\"http://jiaolonghuang.github.io/jsme/sug.js\">附上sug列表的js代码</a>.</p>\n<hr>\n<p>##| 可改进的点</p>\n<p>目前这样做完，在体验上还是有可改进点的(目前只想到了这一个- -.等以后想到了随时补充)。</p>\n<ul>\n<li>blur: blur时，检测数据，并remove sug.</li>\n</ul>\n<hr>\n<p>##| 具体写码时的坑</p>\n<ul>\n<li><p>placeholder兼容<br>检测如果文档创建一个新的input，其中是否具有placeholder属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> placeholder = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 判断是否支持placeholder</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">'placeholder'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'input'</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">\t<span class=\"comment\">// 要添加holder的表单节点</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> elInputs = $(<span class=\"string\">'.js-placeholder'</span>, root);</div><div class=\"line\">\t<span class=\"comment\">// 初始化表单</span></div><div class=\"line\">\t$.each(elInputs, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t$(<span class=\"keyword\">this</span>).val($(<span class=\"keyword\">this</span>).attr(<span class=\"string\">'placeholder'</span>));</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t<span class=\"comment\">// 添加事件</span></div><div class=\"line\">\telInputs.on(<span class=\"string\">'focus blur'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> type = e.type;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> elInput = $(<span class=\"keyword\">this</span>);</div><div class=\"line\">\t\t<span class=\"comment\">// 表单默认值</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> initInput = elInput.attr(<span class=\"string\">'placeholder'</span>);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(type == <span class=\"string\">'focus'</span> &amp;&amp; elInput.val() == initInput)&#123;</div><div class=\"line\">\t\t\t<span class=\"comment\">// 获取焦点 表单置空</span></div><div class=\"line\">\t\t\telInput.val(<span class=\"string\">''</span>);</div><div class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(type==<span class=\"string\">'blur'</span> &amp;&amp; elInput.val()==<span class=\"string\">''</span>)&#123;</div><div class=\"line\">\t\t\telInput.val(initInput);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>纳尼？ie6/7下,背景消失了！！！</p>\n<ul>\n<li><p>这种现象一般是由于代码里同时包含这两句，<code>display:inline-block;text-indent: -999em</code></p>\n</li>\n<li><p>原因：ie6/7并未实现真的的<code>inline-block</code>，它只所有具有<code>inline-block</code>的某些特征，是因为元素触发了<code>hasLayout</code>，而因此让元素拥有了<code>inline-block</code>的表症。</p>\n</li>\n<li><strong>如何解决呢？</strong> 无非两种，从<strong><code>display</code></strong>来考虑，从<strong>与字体相关的</strong>考虑</li>\n<li>方案一：display：block</li>\n<li>方案二：font-size:0;line-height:0</li>\n<li>方案三：line-height:900px；overflow：hidden</li>\n</ul>\n</li>\n<li><p>ie7,<code>width: 100%</code>,没宽度了？</p>\n</li>\n<li><p><a href=\"http://qianduanblog.com/post/css-learning-21-using-html-css-write-an-input-box.html\" target=\"_blank\" rel=\"external\">如何写出一个合适的input</a></p>\n<ul>\n<li>不要给input设置固定高度</li>\n<li>用padding撑开input的高度</li>\n<li>不要给input设置行高</li>\n<li>如果需要改变光标的高度，改变font-size的值</li>\n</ul>\n</li>\n<li><p>如何弥补把sug当作查询结果集的缺点？</p>\n<ul>\n<li>查询已知的现有数据集，再做一次验证。</li>\n</ul>\n</li>\n<li><p>pm想用sug当结果显示框，结果呢？</p>\n<ul>\n<li>之前说到过sug本质上一个提示功能，为用户的输入起到一定的辅助功能。当遇到这样的场景时，就显得特别不合适了。</li>\n<li>背景：<br>(1)input中的内容来源有两个，从sug中选中的，用户自己输入的；<br>(2)当用户输入一个百分百匹配的词时，sug并不会给出提示(你都知道要输入啥了，就没有提示的必要了呀)</li>\n<li>场景：<br>将用户输入框内的正确内容做为参数传给后端。我们知道sug里的内容，肯定是百分之百正确的，所以根据sug得到的内容可以直接发到后端。但是当用户输入‘望京西’时，这是一个百分百匹配的词，sug中返回的结果是空。<br>这时，我们如果分辨不是从sug中得来的input内容是正确的还是错误的呢？<br>也就是说，没有直接的办法可以判断‘望京西’和‘望京西乱七八糟’哪个是正确的。<br>这时，使用sug作为结果显示框是不妥的，应当像上一条提到的一样，再次查询已知的现有结果集，来做验证。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>##| 小技巧</p>\n<ul>\n<li><p><code>flag &amp;&amp; a = b</code><br>其实这样等同于,不仅代码变得简洁了，而且更有效率了。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"title\">if</span><span class=\"params\">(flag)</span></span>&#123;</div><div class=\"line\">\t<span class=\"selector-tag\">a</span> =<span class=\"selector-tag\">b</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>验证是否包含在某个数据集中？<strong>Hash，对象</strong><br><code>obj[&#39;key&#39;] == 1</code>，不用循环遍历</p>\n</li>\n<li>指定异步回调函数名<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">dataType: jsonp,</div><div class=\"line\">jsonpCallback: 回调函数名,</div><div class=\"line\">data:&#123;</div><div class=\"line\">\t<span class=\"selector-tag\">a</span> : <span class=\"selector-tag\">a</span>,</div><div class=\"line\">\t<span class=\"selector-tag\">b</span> : <span class=\"selector-tag\">b</span></div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1414130802000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1414130802000,
				"published_by": 2
			},
			{
				"id": "cj914pnws0000e0hy6vz33pp5",
				"title": "MUSIC开发结束小记",
				"slug": "0",
				"markdown": "\n感谢\n\n在这里心里最想感谢的人是，培培，真的是几乎在培培手把手的指导下完成了3个独立页面。并且不仅授我予鱼，更是授我予渔。\n\n在梳理完开发过程中遇到的技术细节外，这里想更多的谈谈自己心理上的感受和收获。\n\n这次开发大体时间上的安排如下：\n\n9.18-9.26 工作时间：8天\n\n9.18, 9.19, 9.21纯静态页面\n\n9.22,9.23套数据，与php联调\n\n9.24改全部歌单左侧，喜欢收藏\n\n9.25改全部歌单左侧，提测\n\n9.26 上线\n\n态度\n\n关键词：工作值得 产品 预期\n\n1）  只要是自己感兴趣的就是值得的\n\n这次的开发任务在一个熟练开发的眼里也许是一个很简单的任务，但是作为一个新人的\n\n自己接到任务时心里还是很紧张的。一方面是自己对开发环境和流程的不熟悉，另一方面是怕最后完成的质量不高，不仅仅是最终出来的效果，更是代码的美观性。所以自己也是花了很多精力在上面。我一直认为，一个人从事的工作，至少应该是自己擅长或是喜欢的，如果两者都没有，那这个人工作的时候一定是痛苦的。现在我并不十分擅长这个工作，但幸运的是它是我所喜欢的，所以无论花多少时间和精力我都觉得是值得的，而且我自己也有信心最终会变成既喜欢又擅长的工作。一切都是值得的。\n\n2）最后的成品不仅满足有预期，最好可以超出预期\n\n以前总存有侥幸心里，在开发过程中，有小的瑕疵，总不愿去面对，想着pm测试的时候不会发现，想蒙混过关，而不愿去找解决方案。现在会“硬着头皮”去解决问题，这样不仅是对产品负责，更是对自己负责，作为一个新人，想得到成长，必须要有直面困难的勇气，并增长解决问题的本领。\n\n当pm或者设计看到超出她们预期的产品时，那惊奇的语气，都是对自己前一阶段付出的肯定，自己的心里也非常开心。\n\n成长\n\n关键词：方法体系\n\n1）独立解决问题的能力，排查问题的方法。\n\n2）接触一个新的领域时，先从手头上用到的知识点入手，查阅各种关于这个知识点的资料，再了解过后，再查阅与这个知识点相关的其他知识点的资料，再深入了解。也就是先深度遍历再广度遍历的”织网式”学习。\n\n值得借鉴的\n\n关键词：新人上级 确认\n\n产品频繁改需求（设计频繁改设计图）\n\n这次负责设计的同学也是一个新人，在pm要求出图时间比较紧，出的设计图只找了直接上级确认，而没有找最上级确认，就交给了开发，导致开发完成后又返工。映射到自己身上，我自己认为积极向上级确认总是没错的。并且抄送邮件未必是件好事，重要的事还是当面确认比较好。\n\n对产品的想法\n\n关键词：说服依据\n\nPm也是人，pm的想法肯定也会存在不合理的地方。作为一个fe，那我认为我们既是一个产品的开发工作者，同时也是这个产品的第一个使用者。如果这个产品有用户体验上的瑕疵，或是对产品有更好的改进想法，可以及时与pm沟通，有理有据的说出自己的想法。\n\n当然也会遇到产品不合理的需求，那么这时如何有理有据的说服产品的不合理需求，就显得很重要了。首先肯定建立在自己对产品和技术有了深入了解的基础上，之后提出解决方案，分析和比较产品现在这样和改进之后的差别点。\n\n槽点\n\n1\\. 开发、测试、上线流程略微复杂繁琐。静态页、动态页开发傻傻分不清楚。不仅仅开发代码规范有差别，测试地址，上线流程也有很大的差别。尤其是，静态页的发布，一个分类项里面包含十几个页面，因为一些疏忽，一共发布了3次，也就是流程走了3次，一面嘴里念念有词（怕点错了），一面鼠标按个不停。另外就是批量发布时，成功率略低，单个页面成功与否没有明显的提醒。所以为了放心，只能一个一个的发。\n\n虽然现在已经有了一些开发插件在一定程度上减轻了这种流程上的繁琐，但是我认为还是有很大的改进空间。我认为，一个理想的开发平台，应当是，傻瓜式一键操作，简单粗暴。不区分是什么静态页还是动态页，当然了，在是建立在对开发流程和目前的发布平台较为了解的基础上才可以做到的。\n\n2.可参考的文档比较少。大多是依靠前辈的口口相传来了解到可能遇到的坑和开发的流程。这样一方面协同工作的效率比较低，另一方面对下一个新人再接手做这件事时，还需要再向之前的前辈询问， 开发的成本就高了。当然这也是需要从自己做起，平时多注意积累。\n\n疑惑？\n\n当面对一个陌生的领域时，开发前不可能一下子把所有可能遇到的问题都提前了解到，在这种情况下，该如何与导师（上级）沟通？频率过高，会打断影响导师的正常工作？把一段时间内遇到的问题集中问，可能会让自己的开发一直处于卡壳状态?这样的节奏该如何把握。\n\n                                                                                                                         2014.9.28.0:12\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>感谢</p>\n<p>在这里心里最想感谢的人是，培培，真的是几乎在培培手把手的指导下完成了3个独立页面。并且不仅授我予鱼，更是授我予渔。</p>\n<p>在梳理完开发过程中遇到的技术细节外，这里想更多的谈谈自己心理上的感受和收获。</p>\n<p>这次开发大体时间上的安排如下：</p>\n<p>9.18-9.26 工作时间：8天</p>\n<p>9.18, 9.19, 9.21纯静态页面</p>\n<p>9.22,9.23套数据，与php联调</p>\n<p>9.24改全部歌单左侧，喜欢收藏</p>\n<p>9.25改全部歌单左侧，提测</p>\n<p>9.26 上线</p>\n<p>态度</p>\n<p>关键词：工作值得 产品 预期</p>\n<p>1）  只要是自己感兴趣的就是值得的</p>\n<p>这次的开发任务在一个熟练开发的眼里也许是一个很简单的任务，但是作为一个新人的</p>\n<p>自己接到任务时心里还是很紧张的。一方面是自己对开发环境和流程的不熟悉，另一方面是怕最后完成的质量不高，不仅仅是最终出来的效果，更是代码的美观性。所以自己也是花了很多精力在上面。我一直认为，一个人从事的工作，至少应该是自己擅长或是喜欢的，如果两者都没有，那这个人工作的时候一定是痛苦的。现在我并不十分擅长这个工作，但幸运的是它是我所喜欢的，所以无论花多少时间和精力我都觉得是值得的，而且我自己也有信心最终会变成既喜欢又擅长的工作。一切都是值得的。</p>\n<p>2）最后的成品不仅满足有预期，最好可以超出预期</p>\n<p>以前总存有侥幸心里，在开发过程中，有小的瑕疵，总不愿去面对，想着pm测试的时候不会发现，想蒙混过关，而不愿去找解决方案。现在会“硬着头皮”去解决问题，这样不仅是对产品负责，更是对自己负责，作为一个新人，想得到成长，必须要有直面困难的勇气，并增长解决问题的本领。</p>\n<p>当pm或者设计看到超出她们预期的产品时，那惊奇的语气，都是对自己前一阶段付出的肯定，自己的心里也非常开心。</p>\n<p>成长</p>\n<p>关键词：方法体系</p>\n<p>1）独立解决问题的能力，排查问题的方法。</p>\n<p>2）接触一个新的领域时，先从手头上用到的知识点入手，查阅各种关于这个知识点的资料，再了解过后，再查阅与这个知识点相关的其他知识点的资料，再深入了解。也就是先深度遍历再广度遍历的”织网式”学习。</p>\n<p>值得借鉴的</p>\n<p>关键词：新人上级 确认</p>\n<p>产品频繁改需求（设计频繁改设计图）</p>\n<p>这次负责设计的同学也是一个新人，在pm要求出图时间比较紧，出的设计图只找了直接上级确认，而没有找最上级确认，就交给了开发，导致开发完成后又返工。映射到自己身上，我自己认为积极向上级确认总是没错的。并且抄送邮件未必是件好事，重要的事还是当面确认比较好。</p>\n<p>对产品的想法</p>\n<p>关键词：说服依据</p>\n<p>Pm也是人，pm的想法肯定也会存在不合理的地方。作为一个fe，那我认为我们既是一个产品的开发工作者，同时也是这个产品的第一个使用者。如果这个产品有用户体验上的瑕疵，或是对产品有更好的改进想法，可以及时与pm沟通，有理有据的说出自己的想法。</p>\n<p>当然也会遇到产品不合理的需求，那么这时如何有理有据的说服产品的不合理需求，就显得很重要了。首先肯定建立在自己对产品和技术有了深入了解的基础上，之后提出解决方案，分析和比较产品现在这样和改进之后的差别点。</p>\n<p>槽点</p>\n<p>1. 开发、测试、上线流程略微复杂繁琐。静态页、动态页开发傻傻分不清楚。不仅仅开发代码规范有差别，测试地址，上线流程也有很大的差别。尤其是，静态页的发布，一个分类项里面包含十几个页面，因为一些疏忽，一共发布了3次，也就是流程走了3次，一面嘴里念念有词（怕点错了），一面鼠标按个不停。另外就是批量发布时，成功率略低，单个页面成功与否没有明显的提醒。所以为了放心，只能一个一个的发。</p>\n<p>虽然现在已经有了一些开发插件在一定程度上减轻了这种流程上的繁琐，但是我认为还是有很大的改进空间。我认为，一个理想的开发平台，应当是，傻瓜式一键操作，简单粗暴。不区分是什么静态页还是动态页，当然了，在是建立在对开发流程和目前的发布平台较为了解的基础上才可以做到的。</p>\n<p>2.可参考的文档比较少。大多是依靠前辈的口口相传来了解到可能遇到的坑和开发的流程。这样一方面协同工作的效率比较低，另一方面对下一个新人再接手做这件事时，还需要再向之前的前辈询问， 开发的成本就高了。当然这也是需要从自己做起，平时多注意积累。</p>\n<p>疑惑？</p>\n<p>当面对一个陌生的领域时，开发前不可能一下子把所有可能遇到的问题都提前了解到，在这种情况下，该如何与导师（上级）沟通？频率过高，会打断影响导师的正常工作？把一段时间内遇到的问题集中问，可能会让自己的开发一直处于卡壳状态?这样的节奏该如何把握。</p>\n<pre><code>2014.9.28.0:12\n</code></pre><p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1411833900000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1411833900000,
				"published_by": 2
			},
			{
				"id": "cj914pnwy0002e0hyj91lyx1j",
				"title": "行内非替换元素的实际高度",
				"slug": "1",
				"markdown": "\n晚上一个小师妹，问我为什么会出现下面这样的情况：\n\n这个问题之前自己还从没遇到过。\n\n1.刚看到这个问题时，心里还不确定是因为什么原因引起的，觉得可能和span的padding有关系，就先重置了*{margin：0px；}发现，红色背景元素不再高出。但是当将灰色背景的div向右下移动一定距离时，发现问题还是存在的。\n\n2.接着，怀疑是与行内元素的盒模型有关。但不能确定是与垂直方向的padding相关，还是和line-height相关。还在猜测会不会在某种情况下行内元素撑破了其父元素（block）的盒模型。\n\n在先后更改了span的padding-top,padding-bottom，line-height后发现，影响这样情况的是line-height。当line-height=它内容的值+padding-top+padding-bottom的值时，它表现的和预期一样。\n\n3.为什么会这样呢？自己又查了一些资料。\n\n最后得出的结论是，非替换的行内元素，其真正高度只有其内容的line-height有关。与垂直方向的padding，margin，border都无关。\n\n\n1、元素可以设置内边距，外边距，宽度，高度以及边框的宽度，而行内非替换元素在显示时还是有稍微差别，行内非替换元素的上下内边距、上下边框宽度，上下外边距并不会影响元素的高度，即对相对其它元素的距离不会以此改变，如a元素。\n\n2、当你将块元素与行内非替换元素放一起时，譬如行内非替换元素上面，块元素下面，假设行内非替换元素有5px的边框，你会发现快元素与行内非替换元素的之间的距离并不是相对行内非替换元素的边框而言，好像边框不存在一样。出现该情况是因为行内非替换元素由line-height决定，默认line-height为其内容的高度。\n\n\n1. http://www.75team.com/archives/501\n\n2. http://blog.csdn.net/fuyun2000/article/details/4399332\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>晚上一个小师妹，问我为什么会出现下面这样的情况：</p>\n<p>这个问题之前自己还从没遇到过。</p>\n<p>1.刚看到这个问题时，心里还不确定是因为什么原因引起的，觉得可能和span的padding有关系，就先重置了*{margin：0px；}发现，红色背景元素不再高出。但是当将灰色背景的div向右下移动一定距离时，发现问题还是存在的。</p>\n<p>2.接着，怀疑是与行内元素的盒模型有关。但不能确定是与垂直方向的padding相关，还是和line-height相关。还在猜测会不会在某种情况下行内元素撑破了其父元素（block）的盒模型。</p>\n<p>在先后更改了span的padding-top,padding-bottom，line-height后发现，影响这样情况的是line-height。当line-height=它内容的值+padding-top+padding-bottom的值时，它表现的和预期一样。</p>\n<p>3.为什么会这样呢？自己又查了一些资料。</p>\n<p>最后得出的结论是，非替换的行内元素，其真正高度只有其内容的line-height有关。与垂直方向的padding，margin，border都无关。</p>\n<p>1、元素可以设置内边距，外边距，宽度，高度以及边框的宽度，而行内非替换元素在显示时还是有稍微差别，行内非替换元素的上下内边距、上下边框宽度，上下外边距并不会影响元素的高度，即对相对其它元素的距离不会以此改变，如a元素。</p>\n<p>2、当你将块元素与行内非替换元素放一起时，譬如行内非替换元素上面，块元素下面，假设行内非替换元素有5px的边框，你会发现快元素与行内非替换元素的之间的距离并不是相对行内非替换元素的边框而言，好像边框不存在一样。出现该情况是因为行内非替换元素由line-height决定，默认line-height为其内容的高度。</p>\n<ol>\n<li><p><a href=\"http://www.75team.com/archives/501\" target=\"_blank\" rel=\"external\">http://www.75team.com/archives/501</a></p>\n</li>\n<li><p><a href=\"http://blog.csdn.net/fuyun2000/article/details/4399332\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/fuyun2000/article/details/4399332</a></p>\n</li>\n</ol>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1410793980000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1410793980000,
				"published_by": 2
			},
			{
				"id": "cj914pny80012e0hyiq1sm4v1",
				"title": "熟悉而又陌生的table(续）",
				"slug": "2",
				"markdown": "\n针对table中，单元格的内容过长是否会破坏table结构，是否会做截断，做了测试，总结的规律如下：\n\n1. table:fixed之后，指定col宽度，对td做 \n`{    white-space: nowrap;     overflow: hidden;     text-overflow: ellipsis; }` 如果是在table上做，结构不会乱，但是超出宽度的不会被截断\n\n2. table:fixed之后，没有指定col宽度，默认每列的宽度为平均分\n\n3. 如果没有fixed，只指定col宽度，需要在td中加标签，一个block元素，p等，在p上做 `{ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }`，并且需要指定p的宽度，如100px，但宽度不能是%。\n\n4. 如果没有fixed，指定col了宽度，但没有在td中加标签，而是在td上做 `{ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }`，即使给td再指定宽度，如100px，也没有截断的效果。会破坏结构。如果不加那段代码，就会折行显示。 \n5. 如果没有fixed，指定了col了宽度，也没有在td中加标签，而是在table上了加了 `{ white-space: nowrap;     overflow: hidden;     text-overflow: ellipsis;}`，那么超出指定宽度后就会结构乱掉，因为，不能换行（white-space: nowrap;）\n\n另外：\n\n1. 表格还可以用ul，li来实现，每一行是一个li，每个单元格是一个span，对这个span设置display：inline-block\n\n2. 给表格的每行加下划线，必须加在td上，如果加在tr上，在ie7以下，就不显示了。\n\n3. 判断单元格内容是否为空，应该保留td标签，再进行判断。否则，会使一行的下划线不完整。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>针对table中，单元格的内容过长是否会破坏table结构，是否会做截断，做了测试，总结的规律如下：</p>\n<ol>\n<li><p>table:fixed之后，指定col宽度，对td做<br><code>{    white-space: nowrap;     overflow: hidden;     text-overflow: ellipsis; }</code> 如果是在table上做，结构不会乱，但是超出宽度的不会被截断</p>\n</li>\n<li><p>table:fixed之后，没有指定col宽度，默认每列的宽度为平均分</p>\n</li>\n<li><p>如果没有fixed，只指定col宽度，需要在td中加标签，一个block元素，p等，在p上做 <code>{ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }</code>，并且需要指定p的宽度，如100px，但宽度不能是%。</p>\n</li>\n<li><p>如果没有fixed，指定col了宽度，但没有在td中加标签，而是在td上做 <code>{ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }</code>，即使给td再指定宽度，如100px，也没有截断的效果。会破坏结构。如果不加那段代码，就会折行显示。 </p>\n</li>\n<li>如果没有fixed，指定了col了宽度，也没有在td中加标签，而是在table上了加了 <code>{ white-space: nowrap;     overflow: hidden;     text-overflow: ellipsis;}</code>，那么超出指定宽度后就会结构乱掉，因为，不能换行（white-space: nowrap;）</li>\n</ol>\n<p>另外：</p>\n<ol>\n<li><p>表格还可以用ul，li来实现，每一行是一个li，每个单元格是一个span，对这个span设置display：inline-block</p>\n</li>\n<li><p>给表格的每行加下划线，必须加在td上，如果加在tr上，在ie7以下，就不显示了。</p>\n</li>\n<li><p>判断单元格内容是否为空，应该保留td标签，再进行判断。否则，会使一行的下划线不完整。</p>\n</li>\n</ol>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1410600180000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1410600180000,
				"published_by": 2
			},
			{
				"id": "cj914pnyg001he0hyf5egpfz6",
				"title": "常用变量缩写对照表",
				"slug": "3",
				"markdown": "\n世上规范千千万，遵循一种有秩序。\n\n保持所有代码的一致性。使用相同的命名规则。这世界上没有最好的命名规范。\n\n函数: 动词+定语（形容词）+宾语（名词））\n\n比如getResponse，sendRequest\n\n成员变量: 名词或者偏正短语（形容词+中心语（名词）） \n比如RequestHeaders，BufferSize 变量名缩写 count；index 代替num，\napplication =>  app \naverage =>  avg \ncurren =>  cur \ncontrol =>  ctrl \nconfig =>  conf \ndelete =>  del \ndocument =>  doc \ndialog =>  dlg \nerror =>  err \nescpae =>  esc \nlength =>  len \nmessage =>  msg \npassword =>  pwd \npicture =>  pic \nposition =>  pos \nprint =>  prn \nserver =>  srv \nstring =>  str \nsource =>  src \ntemporary =>  temp \nwindow =>  win\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>世上规范千千万，遵循一种有秩序。</p>\n<p>保持所有代码的一致性。使用相同的命名规则。这世界上没有最好的命名规范。</p>\n<p>函数: 动词+定语（形容词）+宾语（名词））</p>\n<p>比如getResponse，sendRequest</p>\n<p>成员变量: 名词或者偏正短语（形容词+中心语（名词））<br>比如RequestHeaders，BufferSize 变量名缩写 count；index 代替num，<br>application =&gt;  app<br>average =&gt;  avg<br>curren =&gt;  cur<br>control =&gt;  ctrl<br>config =&gt;  conf<br>delete =&gt;  del<br>document =&gt;  doc<br>dialog =&gt;  dlg<br>error =&gt;  err<br>escpae =&gt;  esc<br>length =&gt;  len<br>message =&gt;  msg<br>password =&gt;  pwd<br>picture =&gt;  pic<br>position =&gt;  pos<br>print =&gt;  prn<br>server =&gt;  srv<br>string =&gt;  str<br>source =&gt;  src<br>temporary =&gt;  temp<br>window =&gt;  win</p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1405678020000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1405678020000,
				"published_by": 2
			},
			{
				"id": "cj914pnyk001ke0hyosgz9giz",
				"title": "熟悉而又陌生的table",
				"slug": "4",
				"markdown": "\n在处处大谈语义化的今天，人们谈起table时心里大多都是很复杂的，一方面是因为使用table确实在布局上能给我们带来很大的方便，避免很多意外的情况和兼容性的问题；另一方面则是不太清楚什么时候该用table，什么时候不该用。下面我们就一起聊一聊关于table的事情二三。（如果有不对的或是不足的地方还请大家指出来和补充^_^）。\n\n## 1\\. 什么时候使用table\n\n在前一混乱的布局时代，人们为了方便布局而泛滥使用table，大约看中的大概是table的这两个好处：同行等高和宽度自动调节。而忽略了标签其自有的语义信息。   当然，也不是说table是完全不好。当我们面对这样一些结构的数据时就可以使用table，如：一个计划、一组规则、一些属性的比较、球赛的比分、日历、财政的数据或员工信息等。所谓当用则用嘛。\n\n## 2.Table-layout\n\n它定义了如何布局一张表的行、列和单元格。\n\nValue：auto，fixed Auto：每列的宽度由其里面的内容决定； Fixed：表格和列的宽度由table, col的宽度或者是第一行每个单元格的宽度决定。第一行之后每行里的单元格不会影响这一列的宽度。说明第一行每列的单元格宽度是起决定性作用的。\n\n据说Fixed之后的表格布局加载会更快，因为每个列的宽度是固定了的了，而不会通过计算表格的内容来决定列的宽度。（还没有数据证实）。 但是，有可能其后单元格中的内容可能与其被设定的宽度并不符合，需要使用overflow来决定溢出的内容是否被clip掉。\n\n2.1如何设定单元格宽度后，让其里面的内容不溢出？\n\n(1)设定table为固定布局：\n\n<pre>table-layout: fixed;\nwidth:100%;/* must have this set */</pre>\n\n(2)设定每列的宽度，可用<col>或者设定class类的方式\n\n(3)为tr，td进行如下样式设定\n\n<pre>th td{\n    white-space: nowrap;(必须要有)\n    overflow: hidden(必须要有);\n    text-overflow:ellipsis;\n}</pre>\n\n2.2 Overflow和text-overflow都是不可被继承的\n\nText-overflow，可取的值有： clip :不显示省略标记（…），而是简单的裁切 ellipsis :当对象内文本溢出时显示省略标记（…），省略标记插入的位置是最后一个字符。 ellipsis-word :当对象内文本溢出时显示省略标记（…），省略标记插入的位置是最后一个词（word）。\n\n2.3 需要注意的问题         如果某行中的某个单元格中的内容为空，在套模板时，我们有时会通过判断后将整个<td>都不显示，那么就会出现第二幅图的情况，table的结构被打乱了。比较好的做法是，保留<td>结构，而让其内容为空就可以了。\n\n## 3\\. table中常用的标签\n\n大多数的标签大家都比较熟悉，其中有几个是值得注意的：\n\n(1) tfoot。 我们基本较少使用，该标签书写的顺序不是在tbody之后，而是在thead和tbody之间，但却是在呈现在表格的底部，像下面这样，\n\n它的使用场景是，通过重复表头的内容使得，在一个内容很长的表，也容易让人们看到每一列对应的标题是什么。\n\n(2) col,colgroup         这两个标签一般是配合使用的,<colgroup><col></col>…..</colgroup>,即使源码里不用colgroup包裹col，页面加载的时候也会被自动包裹上。这个主要是通<col>影响第一行，而第一行又会影响表格其他的行。         有时我们需要保持表格每一列的样式基本统一，就可以将共同的样式都放在对应的col上，而不用给th，td加上相同的类名，这样不仅语义上更好，代码结构上也会更清晰。\n\n## 4.常用到的css属性\n\n(1)border-collapse 可取的值separated(默认的)，Collapsed Separated：每个单元格之间都是分开的，之间的距离由border-spacing来决定。 Collapsed：这种模式下，合并边框；如果左右两个单元格边框都有颜色，则上面单元格的下边框压了下面单元格的上边框，左面压了右面的。         *只有在sepatrated模式下border-spacing才有用。可用来设定垂直与水平之间不同的间隔。         当然了，你必须要显示的设置th或者td的border,如border:1px solid black;这样才会看到边框线的出现。再给table设置border-spacing: 2px 5px;，就可以看到如下的效果了\n\n## 5.不怎么常用但有时很有用的标签属性\n\n(1) *span(这个有时会用到)。主要是合并单元格时有用途。 (2) scope Headers和scope都是主要是起到一个关联的作用，对屏幕阅读器用途较大。 由于不会在普通浏览器中产生任何视觉效果，很难判断浏览器是否支持 headers 属性。\n\n## 6.如何将任何元素变成与table有关的布局？\n\n可以通过对元素的display进行设置。\n\n这里没有display:table-th，是因为th仅仅是语义上的作用，其根本表现与td是一样的。 * Display:table-cell;（ie8+） (1)大小不固定元素的垂直居中布局（还有多行文本垂直居中） (2)左固定右自适应布局：左边float右边table-cell\n\n## 7\\. 小tips(待补充)\n\n(1) 对整个table设定text-align：left； Chrome下thead和tbody都会有效； Ie下th依然是居中对齐，td有效.\n\n啰啰嗦嗦的说了这么多，目前本人感觉第2.1,3.2以及第4点最有用的，其余的了解就好。关于第6点，若是能更深入的了解，可能还可以更方便的做很多事。了解了Table的基本用法后再结合js就可以做出很多很酷炫的效果了~\n\n参考文章：\n\nhttp://css-tricks.com/complete-guide-table-element/#not-use\n\nhttp://www.w3school.com.cn/cssref/pr_tab_table-layout.asp\n\nhttp://www.cnblogs.com/StormSpirit/archive/2012/10/24/2736453.html\n\nhttps://developer.mozilla.org/en-US/docs/Web/CSS/table-layout\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>在处处大谈语义化的今天，人们谈起table时心里大多都是很复杂的，一方面是因为使用table确实在布局上能给我们带来很大的方便，避免很多意外的情况和兼容性的问题；另一方面则是不太清楚什么时候该用table，什么时候不该用。下面我们就一起聊一聊关于table的事情二三。（如果有不对的或是不足的地方还请大家指出来和补充^_^）。</p>\n<h2 id=\"1-什么时候使用table\"><a href=\"#1-什么时候使用table\" class=\"headerlink\" title=\"1. 什么时候使用table\"></a>1. 什么时候使用table</h2><p>在前一混乱的布局时代，人们为了方便布局而泛滥使用table，大约看中的大概是table的这两个好处：同行等高和宽度自动调节。而忽略了标签其自有的语义信息。   当然，也不是说table是完全不好。当我们面对这样一些结构的数据时就可以使用table，如：一个计划、一组规则、一些属性的比较、球赛的比分、日历、财政的数据或员工信息等。所谓当用则用嘛。</p>\n<h2 id=\"2-Table-layout\"><a href=\"#2-Table-layout\" class=\"headerlink\" title=\"2.Table-layout\"></a>2.Table-layout</h2><p>它定义了如何布局一张表的行、列和单元格。</p>\n<p>Value：auto，fixed Auto：每列的宽度由其里面的内容决定； Fixed：表格和列的宽度由table, col的宽度或者是第一行每个单元格的宽度决定。第一行之后每行里的单元格不会影响这一列的宽度。说明第一行每列的单元格宽度是起决定性作用的。</p>\n<p>据说Fixed之后的表格布局加载会更快，因为每个列的宽度是固定了的了，而不会通过计算表格的内容来决定列的宽度。（还没有数据证实）。 但是，有可能其后单元格中的内容可能与其被设定的宽度并不符合，需要使用overflow来决定溢出的内容是否被clip掉。</p>\n<p>2.1如何设定单元格宽度后，让其里面的内容不溢出？</p>\n<p>(1)设定table为固定布局：</p>\n<pre>table-layout: fixed;\nwidth:100%;/* must have this set */</pre>\n\n<p>(2)设定每列的宽度，可用<col>或者设定class类的方式</p>\n<p>(3)为tr，td进行如下样式设定</p>\n<pre>th td{\n    white-space: nowrap;(必须要有)\n    overflow: hidden(必须要有);\n    text-overflow:ellipsis;\n}</pre>\n\n<p>2.2 Overflow和text-overflow都是不可被继承的</p>\n<p>Text-overflow，可取的值有： clip :不显示省略标记（…），而是简单的裁切 ellipsis :当对象内文本溢出时显示省略标记（…），省略标记插入的位置是最后一个字符。 ellipsis-word :当对象内文本溢出时显示省略标记（…），省略标记插入的位置是最后一个词（word）。</p>\n<p>2.3 需要注意的问题         如果某行中的某个单元格中的内容为空，在套模板时，我们有时会通过判断后将整个<td>都不显示，那么就会出现第二幅图的情况，table的结构被打乱了。比较好的做法是，保留</td><td>结构，而让其内容为空就可以了。</td></p>\n<h2 id=\"3-table中常用的标签\"><a href=\"#3-table中常用的标签\" class=\"headerlink\" title=\"3. table中常用的标签\"></a>3. table中常用的标签</h2><p>大多数的标签大家都比较熟悉，其中有几个是值得注意的：</p>\n<p>(1) tfoot。 我们基本较少使用，该标签书写的顺序不是在tbody之后，而是在thead和tbody之间，但却是在呈现在表格的底部，像下面这样，</p>\n<p>它的使用场景是，通过重复表头的内容使得，在一个内容很长的表，也容易让人们看到每一列对应的标题是什么。</p>\n<p>(2) col,colgroup         这两个标签一般是配合使用的,<colgroup><col>…..</colgroup>,即使源码里不用colgroup包裹col，页面加载的时候也会被自动包裹上。这个主要是通<col>影响第一行，而第一行又会影响表格其他的行。         有时我们需要保持表格每一列的样式基本统一，就可以将共同的样式都放在对应的col上，而不用给th，td加上相同的类名，这样不仅语义上更好，代码结构上也会更清晰。</p>\n<h2 id=\"4-常用到的css属性\"><a href=\"#4-常用到的css属性\" class=\"headerlink\" title=\"4.常用到的css属性\"></a>4.常用到的css属性</h2><p>(1)border-collapse 可取的值separated(默认的)，Collapsed Separated：每个单元格之间都是分开的，之间的距离由border-spacing来决定。 Collapsed：这种模式下，合并边框；如果左右两个单元格边框都有颜色，则上面单元格的下边框压了下面单元格的上边框，左面压了右面的。         *只有在sepatrated模式下border-spacing才有用。可用来设定垂直与水平之间不同的间隔。         当然了，你必须要显示的设置th或者td的border,如border:1px solid black;这样才会看到边框线的出现。再给table设置border-spacing: 2px 5px;，就可以看到如下的效果了</p>\n<h2 id=\"5-不怎么常用但有时很有用的标签属性\"><a href=\"#5-不怎么常用但有时很有用的标签属性\" class=\"headerlink\" title=\"5.不怎么常用但有时很有用的标签属性\"></a>5.不怎么常用但有时很有用的标签属性</h2><p>(1) *span(这个有时会用到)。主要是合并单元格时有用途。 (2) scope Headers和scope都是主要是起到一个关联的作用，对屏幕阅读器用途较大。 由于不会在普通浏览器中产生任何视觉效果，很难判断浏览器是否支持 headers 属性。</p>\n<h2 id=\"6-如何将任何元素变成与table有关的布局？\"><a href=\"#6-如何将任何元素变成与table有关的布局？\" class=\"headerlink\" title=\"6.如何将任何元素变成与table有关的布局？\"></a>6.如何将任何元素变成与table有关的布局？</h2><p>可以通过对元素的display进行设置。</p>\n<p>这里没有display:table-th，是因为th仅仅是语义上的作用，其根本表现与td是一样的。 * Display:table-cell;（ie8+） (1)大小不固定元素的垂直居中布局（还有多行文本垂直居中） (2)左固定右自适应布局：左边float右边table-cell</p>\n<h2 id=\"7-小tips-待补充\"><a href=\"#7-小tips-待补充\" class=\"headerlink\" title=\"7. 小tips(待补充)\"></a>7. 小tips(待补充)</h2><p>(1) 对整个table设定text-align：left； Chrome下thead和tbody都会有效； Ie下th依然是居中对齐，td有效.</p>\n<p>啰啰嗦嗦的说了这么多，目前本人感觉第2.1,3.2以及第4点最有用的，其余的了解就好。关于第6点，若是能更深入的了解，可能还可以更方便的做很多事。了解了Table的基本用法后再结合js就可以做出很多很酷炫的效果了~</p>\n<p>参考文章：</p>\n<p><a href=\"http://css-tricks.com/complete-guide-table-element/#not-use\" target=\"_blank\" rel=\"external\">http://css-tricks.com/complete-guide-table-element/#not-use</a></p>\n<p><a href=\"http://www.w3school.com.cn/cssref/pr_tab_table-layout.asp\" target=\"_blank\" rel=\"external\">http://www.w3school.com.cn/cssref/pr_tab_table-layout.asp</a></p>\n<p><a href=\"http://www.cnblogs.com/StormSpirit/archive/2012/10/24/2736453.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/StormSpirit/archive/2012/10/24/2736453.html</a></p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout</a></p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1405562100000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1405562100000,
				"published_by": 2
			},
			{
				"id": "cj914pnym001ne0hyzyql32a5",
				"title": "将文档中className有“red”的标签背景色设为红色（百度2014校招前端笔试题）",
				"slug": "5",
				"markdown": "\n<pre>用原生JS实现要求</pre>\n\n考点：\n\n1.原生js中只有getElementById()和getElementsByTagName()两个方法。值得注意的是，IE7中，如果A标签name的值等于B标签id的值，且A标签在B标签前，那么getElementById()获取到的是对A标签的应用。\n\n2\\. 使用DOM API操作css时，一般将css属性名改为js中的驼峰样式即可，但也有特殊的，比如css中的float，因为float在js中是关键字，所以改为floatStyle。\n\n3\\. 可以使用element.style.backgroundColor = \"red\",来写，也可以用element.style.cssText = \"background-color:red;\"， 但是后者是完全重写了element的整个style样式。\n\n4\\. IE7- 使用getAttribute(\"class\")不能获取到element的class属性值，只能通过getAttribute(\"className\")来获得。为了照顾到兼容性问题，可以使用element.className来获取。\n\n```\nwindow.load = function() {\n\t\t\tvar allNode = document.getElementsByTagName(\"*\");\n\t\t\tfor(var i = 0, nodeLen = allNode.length; i < nodeLen; i++)\n\t\t\t{\n\t\t\t\t/*var class1 = allNode[i].getAttribute(\"class\");\n\t\t\t\tvar className = class1 ? class1 : allNode[i].getAttribute(\"className\");*/\n\t\t\t\tvar className = allNode[i].className;\n\t\t\t\tif(className)\n\t\t\t\t{\n\t\t\t\t\tvar classNameOfI = className.split(\" \");\n\t\t\t\t\tfor(var j = 0, classNameLen = classNameOfI.length; j < classNameLen;j++)\n\t\t\t\t\t\tif(classNameOfI[j] == \"red\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tallNode[i].style.backgroundColor = \"red\";\n\t\t\t\t\t\t\tallNode[i].style.fontWeight = \"bold\";\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}();\n```\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<pre>用原生JS实现要求</pre>\n\n<p>考点：</p>\n<p>1.原生js中只有getElementById()和getElementsByTagName()两个方法。值得注意的是，IE7中，如果A标签name的值等于B标签id的值，且A标签在B标签前，那么getElementById()获取到的是对A标签的应用。</p>\n<p>2. 使用DOM API操作css时，一般将css属性名改为js中的驼峰样式即可，但也有特殊的，比如css中的float，因为float在js中是关键字，所以改为floatStyle。</p>\n<p>3. 可以使用element.style.backgroundColor = “red”,来写，也可以用element.style.cssText = “background-color:red;”， 但是后者是完全重写了element的整个style样式。</p>\n<p>4. IE7- 使用getAttribute(“class”)不能获取到element的class属性值，只能通过getAttribute(“className”)来获得。为了照顾到兼容性问题，可以使用element.className来获取。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">window.<span class=\"built_in\">load</span> = function() &#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">var</span> allNode = document.getElementsByTagName(<span class=\"string\">\"*\"</span>);</div><div class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>, nodeLen = allNode.<span class=\"built_in\">length</span>; i &lt; nodeLen; i++)</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">/*var class1 = allNode[i].getAttribute(\"class\");</span></div><div class=\"line\">\t\t\t\tvar className = class1 ? class1 : allNode[i].getAttribute(\"className\");*/</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">var</span> className = allNode[i].className;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(className)</div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"built_in\">var</span> classNameOfI = className.<span class=\"built_in\">split</span>(<span class=\"string\">\" \"</span>);</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(<span class=\"built_in\">var</span> j = <span class=\"number\">0</span>, classNameLen = classNameOfI.<span class=\"built_in\">length</span>; j &lt; classNameLen;j++)</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(classNameOfI[j] == <span class=\"string\">\"red\"</span>)</div><div class=\"line\">\t\t\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\t\t\tallNode[i].<span class=\"built_in\">style</span>.backgroundColor = <span class=\"string\">\"red\"</span>;</div><div class=\"line\">\t\t\t\t\t\t\tallNode[i].<span class=\"built_in\">style</span>.fontWeight = <span class=\"string\">\"bold\"</span>;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;();</div></pre></td></tr></table></figure>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1380813300000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1380813300000,
				"published_by": 2
			},
			{
				"id": "cj914pnyn001qe0hyyolvrx5d",
				"title": "用javascript对象模拟LRUcache缓存池（百度2014校招前端笔试题）",
				"slug": "6",
				"markdown": "\nLUR指的是内存管理中，淘汰页面时选择最近最久未使用的那个。  \n\n```\n/* 利用数组模拟缓存池\n * 每个数组元素是一个对象，{k:v},k->key,v->value\n * key可看为是块号，value可看为是块中的内容\n * 块号可相同，但块中的内容则不一定相同\n */\n\t\tfunction LRUcache(size)\n\t\t{\n\t\t\tthis.size = typeof size === \"number\" ? size : 0;\n\t\t\tif(this.size)\n\t\t\t{\n\t\t\t\tthis.elements = new Array();\n\t\t\t}\n\t\t}\n\n/*flag标记在缓存池中是否已存在与key值相同的块或页\n *flag = 0,不存在，flag = 1 存在\n */\n\t\tLRUcache.prototype.add = function(key,value){\n\n\t\t\tvar i,\n\t\t\t\tflag = 0,\n\t\t\t\tlen = this.elements.length,\n\t\t\t\tkey = typeof key === \"number\" ? key : -1;\n\n\t\t\tif(key != -1)\n\t\t\t{\n\t\t\t\tfor(i = 0;i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tif(this.elements[i].k == key)\n\t\t\t\t\t{\n\t\t\t\t\t\t// 找到已存在的key值块或页，就从缓存池中去除\n\t\t\t\t\t\t// 简单的做法就是用后面的块覆盖它\n\t\t\t\t\t\t// 最后再将较新的块放在缓存池的顶部，即数组中的最后一个位置\n\t\t\t\t\t\tfor(j = i ;j < len - 1; j++)\n\t\t\t\t\t\t\tthis.elements[j] = this.elements[j + 1];\n\t\t\t\t\t\tthis.elements[j] = {k:key,v:value};\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag)\n\t\t\t\t{\n\t\t\t\t\t// 如果此时缓存池已满且即将放入的块是新的，则队头出一项\n\t\t\t\t\t// 将新的块压入缓存池中\n\t\t\t\t\tif(len == this.size)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.elements.shift();\t\t\n\t\t\t\t\t}\n\t\t\t\t\tthis.elements.push({k:key,v:value});\t\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tLRUcache.prototype.get = function(key){\n\n\t\t\tvar i,\n\t\t\t\tlen = this.elements.length,\n\t\t\t\tkey = typeof key == \"number\" ? key : -1;\n\n\t\t\tif(key != -1)\n\t\t\t{\n\t\t\t\tfor(i = 0; i < len; i++)\n\t\t\t\t{\n\t\t\t\t\tif(this.elements[i].k == key)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = this.elements[i].v;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(j = i ;j < len - 1; j++)\n\t\t\t\t\t\tthis.elements[j] = this.elements[j + 1];\n\t\t\t\t\t\n\t\t\t\t\t\t// 找到key块，并移动过元素后，将数组中多余的队尾元素弹出\n\t\t\t\t\t\tthis.elements.pop();\n\t\t\t\t\t\treturn tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n测试用例：\n\nvar l = new LRUcache(3);\n\n\t\tl.add(3,1);\n\t\tl.add(5,2);\n\t\tl.add(1,3);\n\t\tl.add(2,4);\n\t\tl.add(3,5);\n\t\tl.add(1,6);\n\t\tl.add(5,7);\n\t\tl.add(\"5\",8);\n\n\t\tfor(var i = 0, len = l.elements.length; i < len; i++)\n\t\t\tconsole.log(l.elements[i]);\n\n\t\tconsole.log(l.get(1));\n\t\tconsole.log(l.get(\"a\"));\n\n\t\tconsole.log(l);\n```\n\n结果：\n<img src = 'http://p3.qhimg.com/t01f2762c3d922eef35.png'>\n\n值得注意的点：\n\n1\\. var test = [{\"a\":1,\"b\":\"jack\"}];，表示的是test为一个数组，数组中有一个元素，这个元素的类型为一个对象是{\"a\":1,\"b\":\"jack\"}.\n\n2\\. var pp = {\"element\" : [1,2,3,4]},表示的是pp是一个对象，对象中有一个属性element,这个属性是一个数组，为[1,2,3,4],可以通过pp.element[0]...来访问数组其中的元素。\n\n3\\. 读取对象属性时，如果对象内部的键值为字符串类型，比如\"name\",那么可以test1.name,或者test1[\"name\"];\n\n如果内部的键值为number类型，则只能是test1[1];\n\n4\\. typeof 对象.属性，（属性就是那个键值），键值对应的值的类型是什么，typeof出来的就是什么。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>LUR指的是内存管理中，淘汰页面时选择最近最久未使用的那个。  </p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 利用数组模拟缓存池</span></div><div class=\"line\"> * 每个数组元素是一个对象，&#123;k:v&#125;,k-&gt;key,v-&gt;value</div><div class=\"line\"> * key可看为是块号，value可看为是块中的内容</div><div class=\"line\"> * 块号可相同，但块中的内容则不一定相同</div><div class=\"line\"> */</div><div class=\"line\">\t\tfunction LRUcache(<span class=\"built_in\">size</span>)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.<span class=\"built_in\">size</span> = typeof <span class=\"built_in\">size</span> === <span class=\"string\">\"number\"</span> ? <span class=\"built_in\">size</span> : <span class=\"number\">0</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.<span class=\"built_in\">size</span>)</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.elements = <span class=\"keyword\">new</span> <span class=\"keyword\">Array</span>();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*flag标记在缓存池中是否已存在与key值相同的块或页</span></div><div class=\"line\"> *flag = 0,不存在，flag = 1 存在</div><div class=\"line\"> */</div><div class=\"line\">\t\tLRUcache.prototype.<span class=\"built_in\">add</span> = function(<span class=\"built_in\">key</span>,value)&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tvar i,</div><div class=\"line\">\t\t\t\tflag = <span class=\"number\">0</span>,</div><div class=\"line\">\t\t\t\tlen = <span class=\"keyword\">this</span>.elements.length,</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">key</span> = typeof <span class=\"built_in\">key</span> === <span class=\"string\">\"number\"</span> ? <span class=\"built_in\">key</span> : <span class=\"number\">-1</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> != <span class=\"number\">-1</span>)</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>;i &lt; len; i++)</div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.elements[i].k == <span class=\"built_in\">key</span>)</div><div class=\"line\">\t\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 找到已存在的key值块或页，就从缓存池中去除</span></div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 简单的做法就是用后面的块覆盖它</span></div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 最后再将较新的块放在缓存池的顶部，即数组中的最后一个位置</span></div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">for</span>(j = i ;j &lt; len - <span class=\"number\">1</span>; j++)</div><div class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">this</span>.elements[j] = <span class=\"keyword\">this</span>.elements[j + <span class=\"number\">1</span>];</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">this</span>.elements[j] = &#123;k:<span class=\"built_in\">key</span>,v:value&#125;;</div><div class=\"line\">\t\t\t\t\t\tflag = <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(!flag)</div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果此时缓存池已满且即将放入的块是新的，则队头出一项</span></div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// 将新的块压入缓存池中</span></div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(len == <span class=\"keyword\">this</span>.<span class=\"built_in\">size</span>)</div><div class=\"line\">\t\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">this</span>.elements.shift();\t\t</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.elements.push(&#123;k:<span class=\"built_in\">key</span>,v:value&#125;);\t</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\"></div><div class=\"line\">\t\tLRUcache.prototype.<span class=\"built_in\">get</span> = function(<span class=\"built_in\">key</span>)&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tvar i,</div><div class=\"line\">\t\t\t\tlen = <span class=\"keyword\">this</span>.elements.length,</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">key</span> = typeof <span class=\"built_in\">key</span> == <span class=\"string\">\"number\"</span> ? <span class=\"built_in\">key</span> : <span class=\"number\">-1</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(<span class=\"built_in\">key</span> != <span class=\"number\">-1</span>)</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; len; i++)</div><div class=\"line\">\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.elements[i].k == <span class=\"built_in\">key</span>)</div><div class=\"line\">\t\t\t\t\t&#123;</div><div class=\"line\">\t\t\t\t\t\tvar tmp = <span class=\"keyword\">this</span>.elements[i].v;</div><div class=\"line\">\t\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">for</span>(j = i ;j &lt; len - <span class=\"number\">1</span>; j++)</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">this</span>.elements[j] = <span class=\"keyword\">this</span>.elements[j + <span class=\"number\">1</span>];</div><div class=\"line\">\t\t\t\t\t</div><div class=\"line\">\t\t\t\t\t\t<span class=\"comment\">// 找到key块，并移动过元素后，将数组中多余的队尾元素弹出</span></div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">this</span>.elements.pop();</div><div class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">return</span> tmp;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">测试用例：</div><div class=\"line\"></div><div class=\"line\">var l = <span class=\"keyword\">new</span> LRUcache(<span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">\t\tl.<span class=\"built_in\">add</span>(<span class=\"number\">3</span>,<span class=\"number\">1</span>);</div><div class=\"line\">\t\tl.<span class=\"built_in\">add</span>(<span class=\"number\">5</span>,<span class=\"number\">2</span>);</div><div class=\"line\">\t\tl.<span class=\"built_in\">add</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</div><div class=\"line\">\t\tl.<span class=\"built_in\">add</span>(<span class=\"number\">2</span>,<span class=\"number\">4</span>);</div><div class=\"line\">\t\tl.<span class=\"built_in\">add</span>(<span class=\"number\">3</span>,<span class=\"number\">5</span>);</div><div class=\"line\">\t\tl.<span class=\"built_in\">add</span>(<span class=\"number\">1</span>,<span class=\"number\">6</span>);</div><div class=\"line\">\t\tl.<span class=\"built_in\">add</span>(<span class=\"number\">5</span>,<span class=\"number\">7</span>);</div><div class=\"line\">\t\tl.<span class=\"built_in\">add</span>(<span class=\"string\">\"5\"</span>,<span class=\"number\">8</span>);</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">for</span>(var i = <span class=\"number\">0</span>, len = l.elements.length; i &lt; len; i++)</div><div class=\"line\">\t\t\tconsole.<span class=\"built_in\">log</span>(l.elements[i]);</div><div class=\"line\"></div><div class=\"line\">\t\tconsole.<span class=\"built_in\">log</span>(l.<span class=\"built_in\">get</span>(<span class=\"number\">1</span>));</div><div class=\"line\">\t\tconsole.<span class=\"built_in\">log</span>(l.<span class=\"built_in\">get</span>(<span class=\"string\">\"a\"</span>));</div><div class=\"line\"></div><div class=\"line\">\t\tconsole.<span class=\"built_in\">log</span>(l);</div></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"http://p3.qhimg.com/t01f2762c3d922eef35.png\"></p>\n<p>值得注意的点：</p>\n<p>1. var test = [{“a”:1,”b”:”jack”}];，表示的是test为一个数组，数组中有一个元素，这个元素的类型为一个对象是{“a”:1,”b”:”jack”}.</p>\n<p>2. var pp = {“element” : [1,2,3,4]},表示的是pp是一个对象，对象中有一个属性element,这个属性是一个数组，为[1,2,3,4],可以通过pp.element[0]…来访问数组其中的元素。</p>\n<p>3. 读取对象属性时，如果对象内部的键值为字符串类型，比如”name”,那么可以test1.name,或者test1[“name”];</p>\n<p>如果内部的键值为number类型，则只能是test1[1];</p>\n<p>4. typeof 对象.属性，（属性就是那个键值），键值对应的值的类型是什么，typeof出来的就是什么。</p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1380804300000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1380804300000,
				"published_by": 2
			},
			{
				"id": "cj914pnyp001te0hyrvw4ie9p",
				"title": "emmet使用方法简介",
				"slug": "7",
				"markdown": "\n作为一名前端开发，需要写大量的html标签，还要闭合这些标签，面对大工作量时，一个标签一个标签的写就显得效率很低。而emmet的出现恰恰可以有效提高我们的工作效率。\n\nEmmet的前身为zend coding，前端开发的神器。下面是我目前用到的一些emmet语法。将将算是入个门吧。\n\n首先，我是在sublime text2中通过包安装了emmet。\n\n之后，同通过快捷键ctrl+alt+enter打开emmet命令行。\n\n再然后，你就可以按照emmet的语法自由发挥了。但是要注意在命令之间不能有空格。\n\n1.生成文档结构\n\nhtml:5 或者 ! 生成 HTML5 结构\n\nhtml:xt 生成 HTML4 过渡型\n\nhtml:4s 生成 HTML4 严格型\n\n2.基本语法\n\n\\#:  id\n\n.:   class\n\n\\>： 后代元素\n\n+： 同级兄弟元素\n\n^:   上一级元素\n\n():   分组\n\n\\*: 生成几个元素 li*5 会生成5个li标签\n\n$: 排序\n\n$@- :倒序\n\n$@4：序号从4开始\n\n3.将图片资源转换成 data url 形式\n\n将光标移动到 background: url() 中的图片位置的地方，按下 Ctrl+’（就是那个引号） 即可将图片编码成 data url 格式。\n\n4.选择标签的快捷键\n\n使用 Shift+Ctrl+. 和 Shift+Ctrl+,分别向下或者向上移动，选取的是一整块，先从标签开始，再是整个属性，再是属性值。\n\n我在这里呢，只写了能基本满足要求的简单语法，http://blog.wpjam.com/m/emmet/ 这里面介绍的很详细，更多的功能，你还可以看官方的文档http://docs.emmet.io/actions/。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>作为一名前端开发，需要写大量的html标签，还要闭合这些标签，面对大工作量时，一个标签一个标签的写就显得效率很低。而emmet的出现恰恰可以有效提高我们的工作效率。</p>\n<p>Emmet的前身为zend coding，前端开发的神器。下面是我目前用到的一些emmet语法。将将算是入个门吧。</p>\n<p>首先，我是在sublime text2中通过包安装了emmet。</p>\n<p>之后，同通过快捷键ctrl+alt+enter打开emmet命令行。</p>\n<p>再然后，你就可以按照emmet的语法自由发挥了。但是要注意在命令之间不能有空格。</p>\n<p>1.生成文档结构</p>\n<p>html:5 或者 ! 生成 HTML5 结构</p>\n<p>html:xt 生成 HTML4 过渡型</p>\n<p>html:4s 生成 HTML4 严格型</p>\n<p>2.基本语法</p>\n<p>#:  id</p>\n<p>.:   class</p>\n<p>>： 后代元素</p>\n<p>+： 同级兄弟元素</p>\n<p>^:   上一级元素</p>\n<p>():   分组</p>\n<p>*: 生成几个元素 li*5 会生成5个li标签</p>\n<p>$: 排序</p>\n<p>$@- :倒序</p>\n<p>$@4：序号从4开始</p>\n<p>3.将图片资源转换成 data url 形式</p>\n<p>将光标移动到 background: url() 中的图片位置的地方，按下 Ctrl+’（就是那个引号） 即可将图片编码成 data url 格式。</p>\n<p>4.选择标签的快捷键</p>\n<p>使用 Shift+Ctrl+. 和 Shift+Ctrl+,分别向下或者向上移动，选取的是一整块，先从标签开始，再是整个属性，再是属性值。</p>\n<p>我在这里呢，只写了能基本满足要求的简单语法，<a href=\"http://blog.wpjam.com/m/emmet/\" target=\"_blank\" rel=\"external\">http://blog.wpjam.com/m/emmet/</a> 这里面介绍的很详细，更多的功能，你还可以看官方的文档<a href=\"http://docs.emmet.io/actions/。\" target=\"_blank\" rel=\"external\">http://docs.emmet.io/actions/。</a></p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1379174160000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1379174160000,
				"published_by": 2
			},
			{
				"id": "cj914pnyr001we0hyh2mcn193",
				"title": "stack和heap的区别",
				"slug": "8",
				"markdown": "\n我们在面试或是笔试的时候都会被问到stack和heap的区别。这里做一个简单的介绍。\n\n首先，这里说的heap不是数据结构的堆，数据结构里的堆是一种数据结构，是二叉树的一种。stack也不是数据结构的栈，数据结构里的栈是一种数据结构，是一种先进后出的结构。而今天我们所讲的stack，heap指的是变量在内存中所存放的位置。\n\n一般情况下，变量在内存中存放的位置有3种：\n\n1\\. 栈（stack）：函数的形参，函数中的局部变量等由编译器自动释放分配的变量。\n\n2\\. 堆(heap) ：内容由程序员自己控制，比如通过malloc，new所开辟的内存空间。\n\n3\\. 静态区域：包括全局变量和静态变量都存在这儿。\n\n从申请动作来讲：\n\n1.stack：是由系统自动分配，比如程序中声明int b;则系统就在内存中自动为b分配一个空间存储。\n\n2\\. heap：是由程序员自己申请，并指明需要多大的空间。\n\n从系统响应来说：\n\n1.stack：只要系统中的stack还没满，并且可以满足申请的大小，那么就会为程序分配空间，否则会出现栈溢出的现在。\n\n2.heap：在os中会有一个管理空闲地址的链表，当程序员提出申请时，系统就会在这个链表中找到第一个满足申请大小的地址块，分给程序，并将剩余的空闲地址重新挂在链表上。很显然这样容易造成内存碎片，很浪费啊。。\n\n从可以申请空间的大小来说：\n\n1\\. stack：stack给变量分配空间时总是从高地址向低地址分配，是一块连续地址的内存空间。在windows下stack的大小为1M。\n\n2\\. heap：heap不连续的空闲内存地址组成的链表，分配空间时是由低地址向高地址扩展。heap的大小受到虚拟内存(把内存扩展到硬盘上）的限制。\n\n从申请效率来说：\n\n1.stack：由于是系统自动分配，因此速度比较快。\n\n2\\. heap：由malloc或new分配内存，速度较慢。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>我们在面试或是笔试的时候都会被问到stack和heap的区别。这里做一个简单的介绍。</p>\n<p>首先，这里说的heap不是数据结构的堆，数据结构里的堆是一种数据结构，是二叉树的一种。stack也不是数据结构的栈，数据结构里的栈是一种数据结构，是一种先进后出的结构。而今天我们所讲的stack，heap指的是变量在内存中所存放的位置。</p>\n<p>一般情况下，变量在内存中存放的位置有3种：</p>\n<p>1. 栈（stack）：函数的形参，函数中的局部变量等由编译器自动释放分配的变量。</p>\n<p>2. 堆(heap) ：内容由程序员自己控制，比如通过malloc，new所开辟的内存空间。</p>\n<p>3. 静态区域：包括全局变量和静态变量都存在这儿。</p>\n<p>从申请动作来讲：</p>\n<p>1.stack：是由系统自动分配，比如程序中声明int b;则系统就在内存中自动为b分配一个空间存储。</p>\n<p>2. heap：是由程序员自己申请，并指明需要多大的空间。</p>\n<p>从系统响应来说：</p>\n<p>1.stack：只要系统中的stack还没满，并且可以满足申请的大小，那么就会为程序分配空间，否则会出现栈溢出的现在。</p>\n<p>2.heap：在os中会有一个管理空闲地址的链表，当程序员提出申请时，系统就会在这个链表中找到第一个满足申请大小的地址块，分给程序，并将剩余的空闲地址重新挂在链表上。很显然这样容易造成内存碎片，很浪费啊。。</p>\n<p>从可以申请空间的大小来说：</p>\n<p>1. stack：stack给变量分配空间时总是从高地址向低地址分配，是一块连续地址的内存空间。在windows下stack的大小为1M。</p>\n<p>2. heap：heap不连续的空闲内存地址组成的链表，分配空间时是由低地址向高地址扩展。heap的大小受到虚拟内存(把内存扩展到硬盘上）的限制。</p>\n<p>从申请效率来说：</p>\n<p>1.stack：由于是系统自动分配，因此速度比较快。</p>\n<p>2. heap：由malloc或new分配内存，速度较慢。</p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1379037240000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1379037240000,
				"published_by": 2
			},
			{
				"id": "cj914pnyt001ze0hyvnpqpzue",
				"title": "设计师要懂心理学",
				"slug": "9",
				"markdown": "\n作为一枚前端工程师，有必要关注网页布局和用户体验的种种。所以，看完《设计师要懂心理学》后，做了简短的归纳，分类没有按照人们心理学的类别，而是从前端的角度。\n\n页面布局\n\n1.      屏幕上的小闪动容易让人分心，重要的内容周围别放动画或闪烁元素。\n\n2.      人会不自主的寻找规律，因此可以利用间隔和分组创造规律。\n\n3.      多用二维元素，抽象元素，可以让人更快，更轻松的识别物体，大脑以二维形式接收信息，三维图形会减慢识别和理解的速度。\n\n4.      如果网页上的人眼看着旁边的物品或位置，人们往往也会看向同一位置。\n\n5.      略微侧向俯视是想象物体的标准。\n\n6.      人们习惯了网页的顶部是无关内容，所以人们往往先看屏幕的中心位置。\n\n7.      物体会暗示人们的动作。比如突起的按钮，人们会有欲望按下去。现在超链接设计的不是那么明显，没有蓝色的下划线。\n\n8.      人们认为相邻物体必然相关。因此，图片和周围文字的间隙大小应该控制好。无关图片的文字靠的太近，会给用户错觉。\n\n如果想使用线或框分割内容，先尝试是否可以调整间距就能达到效果，这样还能使页面具有简洁的效果。\n\n无关内容间距要大，相关内容间距要小。\n\n9.      网站设计要便于浏览而不是阅读。要留有适当的空白，看起来网站更加轻松。\n\n配色方案\n\n10.  设计配色方案时，要考虑所有人都能够正常识别的颜色。同时还要注意颜色的特定含义。\n\n字体\n\n11.  难以阅读的字体会使文本内容也变难。\n\n12.  对于英文来说，尽量选择x高度较大的字体，同样的字号，x高度大的字体看上去更大。比如Tahoma，而times new roman则显得最小\n\n13.  短行分栏，长行阅读的更快。多页文字，每行45个字符。\n\n14.  如果字体很小，人们眯着眼皱着眉阅读，那么很有可能让他们无法赶到快乐或友好，进而影响他们接下来的行为。因此，有必要考虑用户使用产品时你所制造出的情绪。\n\n记忆\n\n15.  尽量让用户再认，别回忆信息。因此，填写表单或是神马的填错的时候不要一下清空。\n\n16.  设计时应提供重要信息或者查找这些信息的便捷方式。\n\n17.  渐进呈现的设计理念\n\n每次只展示用户当前所需要的信息。适量的信息。\n\n18.  心智游移\n\n利用超链接实现不同主题治安警的快速切换，并建立提示用户位置的信息反馈，以便用户可以回到原来的位置继续浏览。比如面包屑\n\n19.  用简短的视频是较好的示范方法，用图片和截屏作为示范。\n\n用户心理体验\n\n20.  人们天生爱分类，要对事物定义准确，并了解怎样分类方式对用户最合理。\n\n21.  使用进度条，让用户知道等待多长时间\n\n22.  将长步骤划分成几个小步骤，避免用户感到过了很长时间。让他们认为当前目标可以完成，且不会太难。\n\n23.  持续给用户反馈。尽量少干扰。\n\n注意力\n\n24.  人们会自动过滤信息。可以使用色彩，大小，动画，视频或声音来吸引他们的注意力。\n\n25.  习惯性动作可能是好事，也可能做错事，注意权衡。比如，默认收货地址。要允许修改上一步操作，甚至是整套操作。\n\n动力\n\n26.  人越接近目标越容易被激励。比如，积分卡，给用户时已经有2个了，再集10个就可以换购或是什么，那么此时用户更有动力完成任务。但完成目标后，人们对任务就没有什么兴趣了。\n\n27.  每邀请3-5个好友就有奖励。每完成一项任务就有奖励。\n\n28.  显示用户完成目标的进度；想办法帮用户建立目标，并可以追踪进程。比如群发邮件还差几步完成，或者自己处于学习阶段的哪一阶段，取得多少进步，多少经验值，显示积分和学习进度。\n\n用户习惯\n\n29.  共同做一件事会把人们联系在一起。线上的交互行为大多是异步的，或者说不是实时的，比如微博，facebook等等，这些可以满足其他的设计需求，但无法代替同步活动带来的快乐。\n\n30.  可以用流媒体视频直播或实时视频音频连接，制造同步活动的机会。\n\n31.  线上社交遵循线下社交的原则，因此有必要给用户持续的反馈，以及简化一些浏览网站的步骤，注册步骤，信息完善步骤。\n\n32.  故事比数字更有说服力。想办法提供那些可以激发情感和引起共鸣的信息。\n\n33.  人们更喜欢忙碌，因此在人们等待的时候给他们一些乐趣。\n\n34.  事情越难实现，人们越喜欢。比如加入某一论坛或社区需要邀请码或是什么，人们会觉得特别来之不易，从而更加重视这个社区；小米手机，饥饿销售，F码。\n\n35.  允许人们犯错。确保错误提示内容包括：用户做了什么，解释出现了什么问题，怎样去修正；信息要直白，尽量用主动语态。\n\n36.  要预先想好可能会发生什么错误，设计产品时尽量避免这些错误。\n\n37.  Less is more。选择会麻痹思维过程。选择过多，用户购买的购买的数量反而少了。如果可能将选择的方案限制为三四种，然后选择渐进方式。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>作为一枚前端工程师，有必要关注网页布局和用户体验的种种。所以，看完《设计师要懂心理学》后，做了简短的归纳，分类没有按照人们心理学的类别，而是从前端的角度。</p>\n<p>页面布局</p>\n<ol>\n<li><p>屏幕上的小闪动容易让人分心，重要的内容周围别放动画或闪烁元素。</p>\n</li>\n<li><p>人会不自主的寻找规律，因此可以利用间隔和分组创造规律。</p>\n</li>\n<li><p>多用二维元素，抽象元素，可以让人更快，更轻松的识别物体，大脑以二维形式接收信息，三维图形会减慢识别和理解的速度。</p>\n</li>\n<li><p>如果网页上的人眼看着旁边的物品或位置，人们往往也会看向同一位置。</p>\n</li>\n<li><p>略微侧向俯视是想象物体的标准。</p>\n</li>\n<li><p>人们习惯了网页的顶部是无关内容，所以人们往往先看屏幕的中心位置。</p>\n</li>\n<li><p>物体会暗示人们的动作。比如突起的按钮，人们会有欲望按下去。现在超链接设计的不是那么明显，没有蓝色的下划线。</p>\n</li>\n<li><p>人们认为相邻物体必然相关。因此，图片和周围文字的间隙大小应该控制好。无关图片的文字靠的太近，会给用户错觉。</p>\n</li>\n</ol>\n<p>如果想使用线或框分割内容，先尝试是否可以调整间距就能达到效果，这样还能使页面具有简洁的效果。</p>\n<p>无关内容间距要大，相关内容间距要小。</p>\n<ol>\n<li>网站设计要便于浏览而不是阅读。要留有适当的空白，看起来网站更加轻松。</li>\n</ol>\n<p>配色方案</p>\n<ol>\n<li>设计配色方案时，要考虑所有人都能够正常识别的颜色。同时还要注意颜色的特定含义。</li>\n</ol>\n<p>字体</p>\n<ol>\n<li><p>难以阅读的字体会使文本内容也变难。</p>\n</li>\n<li><p>对于英文来说，尽量选择x高度较大的字体，同样的字号，x高度大的字体看上去更大。比如Tahoma，而times new roman则显得最小</p>\n</li>\n<li><p>短行分栏，长行阅读的更快。多页文字，每行45个字符。</p>\n</li>\n<li><p>如果字体很小，人们眯着眼皱着眉阅读，那么很有可能让他们无法赶到快乐或友好，进而影响他们接下来的行为。因此，有必要考虑用户使用产品时你所制造出的情绪。</p>\n</li>\n</ol>\n<p>记忆</p>\n<ol>\n<li><p>尽量让用户再认，别回忆信息。因此，填写表单或是神马的填错的时候不要一下清空。</p>\n</li>\n<li><p>设计时应提供重要信息或者查找这些信息的便捷方式。</p>\n</li>\n<li><p>渐进呈现的设计理念</p>\n</li>\n</ol>\n<p>每次只展示用户当前所需要的信息。适量的信息。</p>\n<ol>\n<li>心智游移</li>\n</ol>\n<p>利用超链接实现不同主题治安警的快速切换，并建立提示用户位置的信息反馈，以便用户可以回到原来的位置继续浏览。比如面包屑</p>\n<ol>\n<li>用简短的视频是较好的示范方法，用图片和截屏作为示范。</li>\n</ol>\n<p>用户心理体验</p>\n<ol>\n<li><p>人们天生爱分类，要对事物定义准确，并了解怎样分类方式对用户最合理。</p>\n</li>\n<li><p>使用进度条，让用户知道等待多长时间</p>\n</li>\n<li><p>将长步骤划分成几个小步骤，避免用户感到过了很长时间。让他们认为当前目标可以完成，且不会太难。</p>\n</li>\n<li><p>持续给用户反馈。尽量少干扰。</p>\n</li>\n</ol>\n<p>注意力</p>\n<ol>\n<li><p>人们会自动过滤信息。可以使用色彩，大小，动画，视频或声音来吸引他们的注意力。</p>\n</li>\n<li><p>习惯性动作可能是好事，也可能做错事，注意权衡。比如，默认收货地址。要允许修改上一步操作，甚至是整套操作。</p>\n</li>\n</ol>\n<p>动力</p>\n<ol>\n<li><p>人越接近目标越容易被激励。比如，积分卡，给用户时已经有2个了，再集10个就可以换购或是什么，那么此时用户更有动力完成任务。但完成目标后，人们对任务就没有什么兴趣了。</p>\n</li>\n<li><p>每邀请3-5个好友就有奖励。每完成一项任务就有奖励。</p>\n</li>\n<li><p>显示用户完成目标的进度；想办法帮用户建立目标，并可以追踪进程。比如群发邮件还差几步完成，或者自己处于学习阶段的哪一阶段，取得多少进步，多少经验值，显示积分和学习进度。</p>\n</li>\n</ol>\n<p>用户习惯</p>\n<ol>\n<li><p>共同做一件事会把人们联系在一起。线上的交互行为大多是异步的，或者说不是实时的，比如微博，facebook等等，这些可以满足其他的设计需求，但无法代替同步活动带来的快乐。</p>\n</li>\n<li><p>可以用流媒体视频直播或实时视频音频连接，制造同步活动的机会。</p>\n</li>\n<li><p>线上社交遵循线下社交的原则，因此有必要给用户持续的反馈，以及简化一些浏览网站的步骤，注册步骤，信息完善步骤。</p>\n</li>\n<li><p>故事比数字更有说服力。想办法提供那些可以激发情感和引起共鸣的信息。</p>\n</li>\n<li><p>人们更喜欢忙碌，因此在人们等待的时候给他们一些乐趣。</p>\n</li>\n<li><p>事情越难实现，人们越喜欢。比如加入某一论坛或社区需要邀请码或是什么，人们会觉得特别来之不易，从而更加重视这个社区；小米手机，饥饿销售，F码。</p>\n</li>\n<li><p>允许人们犯错。确保错误提示内容包括：用户做了什么，解释出现了什么问题，怎样去修正；信息要直白，尽量用主动语态。</p>\n</li>\n<li><p>要预先想好可能会发生什么错误，设计产品时尽量避免这些错误。</p>\n</li>\n<li><p>Less is more。选择会麻痹思维过程。选择过多，用户购买的购买的数量反而少了。如果可能将选择的方案限制为三四种，然后选择渐进方式。</p>\n</li>\n</ol>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1378974420000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1378974420000,
				"published_by": 2
			},
			{
				"id": "cj914pnx80006e0hyna2dhwvw",
				"title": "Web前端优化需要注意的点",
				"slug": "10",
				"markdown": "\n关键在于：如何提高页面访问速度；如何减少服务器负载和带宽压力；\n\n最重要的就是：减少HTTP请求连接数！！Yahoo 14条啊！！\n\n1.      cache：包括数据库表的缓存，浏览器缓存，服务器端缓存（代理服务器缓存，CDN缓存，反向代理服务器缓存），web应用程序缓存（HTML5，manifest）\n\n2.      css sprite: 在文件大小与建立连接数之间找到一个平衡。动态css sprite（将需要的图片动态拼接成一个大图）\n\n3.      信息无障碍：标签语义化，注意标签属性的使用。关注的人群不仅仅是健全的人，不应该忽略特殊人群。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>关键在于：如何提高页面访问速度；如何减少服务器负载和带宽压力；</p>\n<p>最重要的就是：减少HTTP请求连接数！！Yahoo 14条啊！！</p>\n<ol>\n<li><p>cache：包括数据库表的缓存，浏览器缓存，服务器端缓存（代理服务器缓存，CDN缓存，反向代理服务器缓存），web应用程序缓存（HTML5，manifest）</p>\n</li>\n<li><p>css sprite: 在文件大小与建立连接数之间找到一个平衡。动态css sprite（将需要的图片动态拼接成一个大图）</p>\n</li>\n<li><p>信息无障碍：标签语义化，注意标签属性的使用。关注的人群不仅仅是健全的人，不应该忽略特殊人群。</p>\n</li>\n</ol>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1373554860000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1373554860000,
				"published_by": 2
			},
			{
				"id": "cj914pnxc0008e0hyhn1vr89l",
				"title": "对前端开发这个工作的认识",
				"slug": "11",
				"markdown": "\n1.      最开始的阶段，前端开发相当与是给房子装修，由美工提供设计图纸，后端工程师构建基础框架搭建毛坯房，然后前端开发工程师按照走线等等合理布局，将图纸上的样式实现。\n\n2.      随着web 的不断发展，由最开始的静态网页，到后来需要局部更新数据的需求，促使我们需要精确的从服务器端取出数据并显示在页面上。也就是与后台动态进行交互，这是以前简单的页面制作所达不到的。同时，现在前端需要做大量的web优化工作，比如css,js压缩优化,cache,来提高页面访问速度，提供良好的用户体验和减轻服务器端的压力以及带宽压力。\n\n3.      随着“云”的不断发展，web开始从web page发展到web app，web game。就是将客户端的响应及时的特点和web相结合，富javascript应用，比如chrome OS，Q+。同时前端在趋向于single-page javascript application的发展，比如微博，豆瓣的阿尔法城，就是在单一页面完成大量的交互。\n\n4.      还有现在响应式web设计，这是一种技术，可以让网站无论在什么终端，什么样式的设备都可以被访问到。\n\n5.      所以，现在前端的这些工作不仅仅进行显示页面，而是更多的进行应用的开发，有着复杂的操作逻辑和业务逻辑。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<ol>\n<li><p>最开始的阶段，前端开发相当与是给房子装修，由美工提供设计图纸，后端工程师构建基础框架搭建毛坯房，然后前端开发工程师按照走线等等合理布局，将图纸上的样式实现。</p>\n</li>\n<li><p>随着web 的不断发展，由最开始的静态网页，到后来需要局部更新数据的需求，促使我们需要精确的从服务器端取出数据并显示在页面上。也就是与后台动态进行交互，这是以前简单的页面制作所达不到的。同时，现在前端需要做大量的web优化工作，比如css,js压缩优化,cache,来提高页面访问速度，提供良好的用户体验和减轻服务器端的压力以及带宽压力。</p>\n</li>\n<li><p>随着“云”的不断发展，web开始从web page发展到web app，web game。就是将客户端的响应及时的特点和web相结合，富javascript应用，比如chrome OS，Q+。同时前端在趋向于single-page javascript application的发展，比如微博，豆瓣的阿尔法城，就是在单一页面完成大量的交互。</p>\n</li>\n<li><p>还有现在响应式web设计，这是一种技术，可以让网站无论在什么终端，什么样式的设备都可以被访问到。</p>\n</li>\n<li><p>所以，现在前端的这些工作不仅仅进行显示页面，而是更多的进行应用的开发，有着复杂的操作逻辑和业务逻辑。</p>\n</li>\n</ol>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1373554800000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1373554800000,
				"published_by": 2
			},
			{
				"id": "cj914pnxi000ae0hy3sdh00lq",
				"title": "FF、IE6-常见问题大不同",
				"slug": "12",
				"markdown": "\n1. PNG透明度 IE6中支持PNG透明度的方法，AlphaImageLoader过滤器 filter:progid:DXImageTransform.Microsoft.AlphaImageLoader (src='/img/my-image.png',sizingMethod='crop'); background:none; IE PNG fix:使用Microsoft专有的CSS扩展-行为(behavior)，下载合适的.htc文件并在IE6专有的样式表中引用。img, div{behavior:url(iepngfix.htc);}\n\n2. 列表项上下的额外空间\nul中的li在IE6-会添加额外的空间。需要将列表项li上的display属性设置为inline。ul li{display:inline;}\n\n3. IE早期版本和Opera使用margin-left控制列表缩进，Safari和FF等大多选择padding-left控制。所以先要初始ul{margin:0;padding:0;list-style-type:none;} \n\n4. button IE6，IE7处理button提交元素本身的内容，其他浏览器提交value属性的内容。如果页面上有多个button，IE6提交所有按钮的内容。如果希望在一个页面上使用多个按钮，就需要保证它们的功能相同，因为IE老版本中无法判断点击了哪个按钮。 \n\n5. 盒模型和元素大小 IE考虑元素内容的大小，而不是元素本身（整体）的大小。在符合标准的浏览器中，如果元素的内容太大，只会超出框外，而在IE下，整个元素会扩展。 \n\n6. 双外边距浮动bug IE6-,使任何浮动元素上的外边距加倍，仅仅是水平方向的。 display:inline; \n\n7. 3像素文本偏移 文本与一个浮动元素相邻时会出现这问题。 不希望文本环绕浮动元素，会在段落加一个margin-left，并使它的值等于浮动元素的宽度。 修复：给包含文本的元素设置任意高度，*height：1%。然后外边距重新设置为0，*margin-left：0；如果浮动元素不是图像，那么，给浮动元素加一个负的右外边距：margin-right：-3px。 如果浮动元素是图像，那么在IE5.X下，图像的左右都出现了-3px的间距，所以最后一步:margin:0,3px; 而IE6下的图像外边距没改变。所以，margin：0；\n\n8. 重复字符 在某些情况下，一系列浮动元素的最后一个元素中的最后几个字符会在浮动元素下面重复出现。 \n当在一系列浮动元素的第一个和最后一个元素之间有多个注释时，出现。 解决办法，在HTML代码中删除注释 \n\n9. 藏猫猫BUG 一个浮动元素后面跟着一些不浮动的元素，然后又跟着一个清理元素，并且这些所有元素都包含在一个设置了背景色或图像，没有设置宽度或高度的父元素中。 如果清理元素碰到了浮动元素，中间的非浮动元素隐藏到了父元素的背景色或图像后。 解决办法：避免清理元素和浮动元素接触；给容器设置尺寸；给容器指定line-height \n\n10. 相对容器中的绝对定位 IE6-，相对定位的容易没有获得layout，绝对定位的元素相对于窗口进行定位了。\n解决办法：给相对定位的容器设定width或height；给容器设定任意高度，height：1%\n\n11. 让IE6支持min-width和max-width属性\nmin-width:200px;\nmax-width:400px;\n_width:expression(this.scrollWidth>400？\"400px\"：this.scrollWidth < 200?\"200px\":\"auto\";\n\n12. IE6/7，border:none边框依然存在\nborder:none;浏览器对border-width和border-color没有渲染，不占内存；而border:0，占用了内存值。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<ol>\n<li><p>PNG透明度 IE6中支持PNG透明度的方法，AlphaImageLoader过滤器 filter:progid:DXImageTransform.Microsoft.AlphaImageLoader (src=’/img/my-image.png’,sizingMethod=’crop’); background:none; IE PNG fix:使用Microsoft专有的CSS扩展-行为(behavior)，下载合适的.htc文件并在IE6专有的样式表中引用。img, div{behavior:url(iepngfix.htc);}</p>\n</li>\n<li><p>列表项上下的额外空间<br>ul中的li在IE6-会添加额外的空间。需要将列表项li上的display属性设置为inline。ul li{display:inline;}</p>\n</li>\n<li><p>IE早期版本和Opera使用margin-left控制列表缩进，Safari和FF等大多选择padding-left控制。所以先要初始ul{margin:0;padding:0;list-style-type:none;} </p>\n</li>\n<li><p>button IE6，IE7处理button提交元素本身的内容，其他浏览器提交value属性的内容。如果页面上有多个button，IE6提交所有按钮的内容。如果希望在一个页面上使用多个按钮，就需要保证它们的功能相同，因为IE老版本中无法判断点击了哪个按钮。 </p>\n</li>\n<li><p>盒模型和元素大小 IE考虑元素内容的大小，而不是元素本身（整体）的大小。在符合标准的浏览器中，如果元素的内容太大，只会超出框外，而在IE下，整个元素会扩展。 </p>\n</li>\n<li><p>双外边距浮动bug IE6-,使任何浮动元素上的外边距加倍，仅仅是水平方向的。 display:inline; </p>\n</li>\n<li><p>3像素文本偏移 文本与一个浮动元素相邻时会出现这问题。 不希望文本环绕浮动元素，会在段落加一个margin-left，并使它的值等于浮动元素的宽度。 修复：给包含文本的元素设置任意高度，<em>height：1%。然后外边距重新设置为0，</em>margin-left：0；如果浮动元素不是图像，那么，给浮动元素加一个负的右外边距：margin-right：-3px。 如果浮动元素是图像，那么在IE5.X下，图像的左右都出现了-3px的间距，所以最后一步:margin:0,3px; 而IE6下的图像外边距没改变。所以，margin：0；</p>\n</li>\n<li><p>重复字符 在某些情况下，一系列浮动元素的最后一个元素中的最后几个字符会在浮动元素下面重复出现。<br>当在一系列浮动元素的第一个和最后一个元素之间有多个注释时，出现。 解决办法，在HTML代码中删除注释 </p>\n</li>\n<li><p>藏猫猫BUG 一个浮动元素后面跟着一些不浮动的元素，然后又跟着一个清理元素，并且这些所有元素都包含在一个设置了背景色或图像，没有设置宽度或高度的父元素中。 如果清理元素碰到了浮动元素，中间的非浮动元素隐藏到了父元素的背景色或图像后。 解决办法：避免清理元素和浮动元素接触；给容器设置尺寸；给容器指定line-height </p>\n</li>\n<li><p>相对容器中的绝对定位 IE6-，相对定位的容易没有获得layout，绝对定位的元素相对于窗口进行定位了。<br>解决办法：给相对定位的容器设定width或height；给容器设定任意高度，height：1%</p>\n</li>\n<li><p>让IE6支持min-width和max-width属性<br>min-width:200px;<br>max-width:400px;<br>_width:expression(this.scrollWidth&gt;400？”400px”：this.scrollWidth &lt; 200?”200px”:”auto”;</p>\n</li>\n<li><p>IE6/7，border:none边框依然存在<br>border:none;浏览器对border-width和border-color没有渲染，不占内存；而border:0，占用了内存值。</p>\n</li>\n</ol>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1370918940000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1370918940000,
				"published_by": 2
			},
			{
				"id": "cj914pnxo000fe0hy6ebm3fwm",
				"title": "Web前端开发修炼之道-HTML篇",
				"slug": "13",
				"markdown": "\n1. 标签的语义化 先确定HTML，确定语义的标签，再来选用合适的CSS。浏览器会根据标签的语义给定一个默认的样式。\n\n2. 表单 表单域要用fieldset标签包起来，并用legend标签说明表单的用途。每一个input标签对应的说明文本都要用label标签，并通过为input设置id属性，在label标签中设置“for = someID” 来让说明文本和相应的input关联起来。 如：\n```\n<form action = \"\" method =\"\" class = \"fieldset\"> \n\t<filedset> <legend>XXXX</legend> <p><label for = \"name\"> XXX:<input type = \"text\" id = \"name/></p> </filedset> \n</form>\n```\n\n3. 表格 表格标题要用caption，表头要用thead包围，主题用tbody包围，表头和一般单元格要去分开，表头用th，一般表格用td。 如：\n```\n<table> \n\t<caption>XXXX</caption> \n\t<thead> <tr><th>XXXX</th><th>XXXX</th></tr> </thead> \n\t<tbody> <tr><td>XXXX</td><td>XXXX</td></tr> </tbody> \n</table>\n```\n\n4. 注意: 尽可能少的使用无语义标签div和span语义不明确既可用div又可用p时，用p，默认有上下间距。div不能在p中，div、p不能在a中。\n\n5. XHTML与HTML的区别 在XHTML中要严格，但在HTML中不严格要求，应该尽量按照XHTML规范来编写： 1.标签名必须都小写2.属性名称小写，属性值写在双引号中,属性-值必须用完整的形式，属性=“值”3.标记严格嵌套4.标记必须封闭，空元素标记也要封闭`<img /><br />`\n\n6. 区分内容标记和结构标记。内容标记中不能嵌套结构标记。`<p>中不能嵌套<table>`\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<ol>\n<li><p>标签的语义化 先确定HTML，确定语义的标签，再来选用合适的CSS。浏览器会根据标签的语义给定一个默认的样式。</p>\n</li>\n<li><p>表单 表单域要用fieldset标签包起来，并用legend标签说明表单的用途。每一个input标签对应的说明文本都要用label标签，并通过为input设置id属性，在label标签中设置“for = someID” 来让说明文本和相应的input关联起来。 如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;form action = <span class=\"string\">\"\"</span> method =<span class=\"string\">\"\"</span> <span class=\"class\"><span class=\"keyword\">class</span> </span>= <span class=\"string\">\"fieldset\"</span>&gt; </div><div class=\"line\">\t<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">filedset</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span>XXXX<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span> = <span class=\"string\">\"name\"</span>&gt;</span> XXX:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span> = <span class=\"string\">\"text\"</span> <span class=\"attr\">id</span> = <span class=\"string\">\"name/&gt;&lt;/p&gt; &lt;/filedset&gt; </span></span></span></div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>表格 表格标题要用caption，表头要用thead包围，主题用tbody包围，表头和一般单元格要去分开，表头用th，一般表格用td。 如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span> </div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">caption</span>&gt;</span>XXXX<span class=\"tag\">&lt;/<span class=\"name\">caption</span>&gt;</span> </div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>XXXX<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>XXXX<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span> </div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>XXXX<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>XXXX<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>注意: 尽可能少的使用无语义标签div和span语义不明确既可用div又可用p时，用p，默认有上下间距。div不能在p中，div、p不能在a中。</p>\n</li>\n<li><p>XHTML与HTML的区别 在XHTML中要严格，但在HTML中不严格要求，应该尽量按照XHTML规范来编写： 1.标签名必须都小写2.属性名称小写，属性值写在双引号中,属性-值必须用完整的形式，属性=“值”3.标记严格嵌套4.标记必须封闭，空元素标记也要封闭<code>&lt;img /&gt;&lt;br /&gt;</code></p>\n</li>\n<li><p>区分内容标记和结构标记。内容标记中不能嵌套结构标记。<code>&lt;p&gt;中不能嵌套&lt;table&gt;</code></p>\n</li>\n</ol>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1370589180000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1370589180000,
				"published_by": 2
			},
			{
				"id": "cj914pnxr000ie0hyxig1c9ge",
				"title": "Web前端开发修炼之道-CSS篇2（转+改）",
				"slug": "14",
				"markdown": "\n1. `display:inline-block和hasLayout display:block,inline,list-item,table-cell,inline-bloack`等等。\n为了兼容IE6、IE7(不支持display:inline:block)，我们真正能使用的display类型只有inline,block和none. display:inline-block集块级元素和行内元素的特点于一身。\n为了使IE6、IE7实现display:inline-block效果，可以在行内元素(如span)中定义display：inline-block，以触发hasLayout,可以使用vertical-align:-10px(具体数值还要自己调)和其他实现浏览器效果一样。对块元素使用display:inline-block不能实现应有的效果。它只能对行内元素实现display:inline-block；还要用到针对IE的hack,*vertical-align。\n\n2. relative、absolute和float position可能的取值：relative、absolute、static(默认的)、fixed（相对浏览器窗口的绝对定位）、inherit。\nposition:relative，z-index>0,但会保留自己在z-index:0层的占位，left等是相对于自己在z-index:0层的位置。\nposition:absolute,完全脱离文档流，在z-index:0层不保留位置，left等值相对于距离自己最近的一个设置了relative或absolute的祖先元素，如果都有没有，就是相对于body的。\nfloat让元素仍然在z-index:0层左右浮动。会改变正常的文档流排列。\nposition:absolute和float会隐式的改变display类型，不论之前是什么类型的元素（display:none除外），只要设置了postion:absolute、float；left和float:right中任意一个，都会让元素以display:inline-block显示，这也就是IE6下使用float产生双边距可以使用display:inline去除position:relative不会隐式改变display的类型。 \n\n3. 水平居中文本、图片等行内元素的水平居中可以使用text-align:center。\n确定宽度的块级元素的水平居中可以使用margin:0 auto;\n不确定宽度的块级元素的水平居中\n（1）.讲内容放入table标签，这是table标签margin:0 auto;\n（2）将块级元素使用display:inline变成行内元素，在通过text-align:center实现；\n（3）再父元素之外再加一个div然后对这个div设置width，height，position：relative，然后对父元素设置position:absolute和left:50%,子元素设置成position:reletive和left:-50%.\n（4）设置父元素的width：fit-content;然后再对父元素margin-left:auto;margin-right:auto;对子元素float:left;(5)对父元素设置display:box;box-orient:horizontal;box-pack:center;对子元素float：left; \n\n5. 竖直居中, 父元素高度不确定的文本、图片和块级元素竖直居中是通过给父容器设置上下边距实现的。\n对父元素padding-bottom和padding-top设置相同的值。\n父元素高度确定的单行文本竖直居中，是通过给父元素设置line-hignt等于父元素hight高度实现的。\n父元素高度确定的多行文本、图片和块级元素竖直居中\n（1）直接使用表格，直接将文字放在tr中\n（2）对于支持display:table-cell的IE8和ff用display:table-cell和vertacil-align:middle实现居中。\n对于不支持则使用IE hackIE hack： 最外层div，position：absolute； 内层div（包含文字）height:100px;position：absolute;top:50%；margin-top:-(height/2);必须要设置高度。 \n或者： 用3层嵌套，2个外div，1个内div（包含文字） #outer{position:relative;}   #middle{position:absolute;top:50%;}   #inner{position:relative;top:-50%;}。不用设置inner文字的高度。\n\n6. 水平垂直居中 `<div class = \"conter\"> 中间是块级元素 </div>`\n 最外div，display：box；box-orient:horizontal;box:pack:center;box-align:center; \n\n7. 网格布局同级下，哪块内容重要，在HTML就优先写到前面。用于布局个人偏好子选择器 \n\n8. Z-index的相关问题及flash和IE6下的select元素 除了x,y轴，还有一个Z轴，z轴在元素设置position为reletive或absolute或被激活，其大小有z-index设置，z-index越大，元素位置越靠上。\nz可以为负值，在body之下负边距也可造成元素位置重叠z-index只对非窗口的元素有效，而flash默认是窗口模式，我们要将flash中的womde设置成opaque或transpartent。\n窗口类型，优先于非窗口类型的显示在页面最顶端。\nselect元素在IE6下也是默认以窗口形式显示的，这是IE6的一个Bug。\n解决办法：用一个与div同样大小的ifream放在div之下，select之上，用ifream遮住select。\n具体就是：设置div的z-index：2；ifream的z-index：1；同时ifream的frameborder=“0”否则在FF下会有边框\n\n8. 插入png图片 IE6的png图片不支持透明，可以使用IE下私有的滤镜解决。 \n\n9. 使用IETest进行多IE版本调试。\n\n10. 清除浮动 为了让浮动元素的父容易能根据浮动元素的高度而自适应高度。\n有3种办法： 让父容器同时浮动，`<div class=\"fl\"><div class = \"fl\"></div></div>`;\n让浮动元素后面紧跟一个用于清除浮动的空标签, `<div><div class=\"fl\"></div><div class=\"cb\"></div><div>`给父容器挂一个特殊class，直接从父容器清除浮动元素的浮动，\n```\n<div class=\"classfix\"><div class=\"fl\"></div></div>\n.classfix:after{content:\".\";dispaly:block;height:0;clear:both;visibility:hidden;} .classfix{display:inline-block;} *html .classfix{height:1%;} .clearfix{dispaly:block;}\n```\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<ol>\n<li><p><code>display:inline-block和hasLayout display:block,inline,list-item,table-cell,inline-bloack</code>等等。<br>为了兼容IE6、IE7(不支持display:inline:block)，我们真正能使用的display类型只有inline,block和none. display:inline-block集块级元素和行内元素的特点于一身。<br>为了使IE6、IE7实现display:inline-block效果，可以在行内元素(如span)中定义display：inline-block，以触发hasLayout,可以使用vertical-align:-10px(具体数值还要自己调)和其他实现浏览器效果一样。对块元素使用display:inline-block不能实现应有的效果。它只能对行内元素实现display:inline-block；还要用到针对IE的hack,*vertical-align。</p>\n</li>\n<li><p>relative、absolute和float position可能的取值：relative、absolute、static(默认的)、fixed（相对浏览器窗口的绝对定位）、inherit。<br>position:relative，z-index&gt;0,但会保留自己在z-index:0层的占位，left等是相对于自己在z-index:0层的位置。<br>position:absolute,完全脱离文档流，在z-index:0层不保留位置，left等值相对于距离自己最近的一个设置了relative或absolute的祖先元素，如果都有没有，就是相对于body的。<br>float让元素仍然在z-index:0层左右浮动。会改变正常的文档流排列。<br>position:absolute和float会隐式的改变display类型，不论之前是什么类型的元素（display:none除外），只要设置了postion:absolute、float；left和float:right中任意一个，都会让元素以display:inline-block显示，这也就是IE6下使用float产生双边距可以使用display:inline去除position:relative不会隐式改变display的类型。 </p>\n</li>\n<li><p>水平居中文本、图片等行内元素的水平居中可以使用text-align:center。<br>确定宽度的块级元素的水平居中可以使用margin:0 auto;<br>不确定宽度的块级元素的水平居中<br>（1）.讲内容放入table标签，这是table标签margin:0 auto;<br>（2）将块级元素使用display:inline变成行内元素，在通过text-align:center实现；<br>（3）再父元素之外再加一个div然后对这个div设置width，height，position：relative，然后对父元素设置position:absolute和left:50%,子元素设置成position:reletive和left:-50%.<br>（4）设置父元素的width：fit-content;然后再对父元素margin-left:auto;margin-right:auto;对子元素float:left;(5)对父元素设置display:box;box-orient:horizontal;box-pack:center;对子元素float：left; </p>\n</li>\n<li><p>竖直居中, 父元素高度不确定的文本、图片和块级元素竖直居中是通过给父容器设置上下边距实现的。<br>对父元素padding-bottom和padding-top设置相同的值。<br>父元素高度确定的单行文本竖直居中，是通过给父元素设置line-hignt等于父元素hight高度实现的。<br>父元素高度确定的多行文本、图片和块级元素竖直居中<br>（1）直接使用表格，直接将文字放在tr中<br>（2）对于支持display:table-cell的IE8和ff用display:table-cell和vertacil-align:middle实现居中。<br>对于不支持则使用IE hackIE hack： 最外层div，position：absolute； 内层div（包含文字）height:100px;position：absolute;top:50%；margin-top:-(height/2);必须要设置高度。<br>或者： 用3层嵌套，2个外div，1个内div（包含文字） #outer{position:relative;}   #middle{position:absolute;top:50%;}   #inner{position:relative;top:-50%;}。不用设置inner文字的高度。</p>\n</li>\n<li><p>水平垂直居中 <code>&lt;div class = &quot;conter&quot;&gt; 中间是块级元素 &lt;/div&gt;</code><br>最外div，display：box；box-orient:horizontal;box:pack:center;box-align:center; </p>\n</li>\n<li><p>网格布局同级下，哪块内容重要，在HTML就优先写到前面。用于布局个人偏好子选择器 </p>\n</li>\n<li><p>Z-index的相关问题及flash和IE6下的select元素 除了x,y轴，还有一个Z轴，z轴在元素设置position为reletive或absolute或被激活，其大小有z-index设置，z-index越大，元素位置越靠上。<br>z可以为负值，在body之下负边距也可造成元素位置重叠z-index只对非窗口的元素有效，而flash默认是窗口模式，我们要将flash中的womde设置成opaque或transpartent。<br>窗口类型，优先于非窗口类型的显示在页面最顶端。<br>select元素在IE6下也是默认以窗口形式显示的，这是IE6的一个Bug。<br>解决办法：用一个与div同样大小的ifream放在div之下，select之上，用ifream遮住select。<br>具体就是：设置div的z-index：2；ifream的z-index：1；同时ifream的frameborder=“0”否则在FF下会有边框</p>\n</li>\n<li><p>插入png图片 IE6的png图片不支持透明，可以使用IE下私有的滤镜解决。 </p>\n</li>\n<li><p>使用IETest进行多IE版本调试。</p>\n</li>\n<li><p>清除浮动 为了让浮动元素的父容易能根据浮动元素的高度而自适应高度。<br>有3种办法： 让父容器同时浮动，<code>&lt;div class=&quot;fl&quot;&gt;&lt;div class = &quot;fl&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code>;<br>让浮动元素后面紧跟一个用于清除浮动的空标签, <code>&lt;div&gt;&lt;div class=&quot;fl&quot;&gt;&lt;/div&gt;&lt;div class=&quot;cb&quot;&gt;&lt;/div&gt;&lt;div&gt;</code>给父容器挂一个特殊class，直接从父容器清除浮动元素的浮动，</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"classfix\"</span>&gt;&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"fl\"</span>&gt;&lt;/<span class=\"keyword\">div</span>&gt;&lt;/<span class=\"keyword\">div</span>&gt;</div><div class=\"line\">.classfix:<span class=\"keyword\">after</span>&#123;content:<span class=\"string\">\".\"</span>;dispaly:block;height:<span class=\"number\">0</span>;clear:both;visibility:hidden;&#125; .classfix&#123;display:inline-block;&#125; *html .classfix&#123;height:<span class=\"number\">1</span>%;&#125; .clearfix&#123;dispaly:block;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1370585940000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1370585940000,
				"published_by": 2
			},
			{
				"id": "cj914pnxu000ne0hycz7zrwft",
				"title": "Web前端开发修炼之道-CSS篇（转+改）",
				"slug": "15",
				"markdown": "\n模块拆分原则： \n1.模块与模块之间尽量不要包含相同的部分，如果有相同的部分，应将它们提取出来，拆分成一个独立的模块. \n2.模块应在保证数量尽可能少的原则下，做到尽可能的简单，以提高重用性。 \n\nCSS调用： \n1.将相同的部分抽取出来单独成为一个calss \n2.多用组合，少用继承 \n3.多使用`<div calss=\"a b c\"></a>`,少使用`<div class=\"a_b_c\"></div>` \n\n上下边距(Margin)： \n1.如果不确定模块的上下margin特别稳定，最好不要讲它写到模块的类里，而使用类的组合，单独为上下margin挂用于边距的原子类(例如mt10、mt20)。模块最好不要混用margin-top和margin-botton，统一使用margin-top或margin-botton. \n2.连着的margin-top和margin-botton会合并取两者最大的值。margin-left和margin-right则不会有这样的问题。\n\n低权重原则 \n1.CSS选择符是有权重的，当不同选择符的样式设置有冲突时，会采用高的选择符设置样式。 \n2.权重规则：HTML标签的权重是1，class的权重是10，id的权重是100，有important标识的权重最大。例如p的权重是1，“div em\"权重就是1+1=2，\"strong.demo\"的权重是1+10=11，\"#test .red\"的权重是100+10=110. \n3.如果CSS选择符权重相同，那么样式会遵循就近原则，那个选择符最后定义，就采用那个选择符的样式。 4.\"就近原则\"指的是选择符定义的先后顺序，而不是挂class名的先后顺序。 \n5.为了保证样式容易被覆盖，提高可维护性，CSS选择符需要保证权证尽可能低。 \n\nCSS sprise \n1.是否使用CSS sprise主要取决于网站的流量。最大的好处是减少HTTP请求数，减轻服务器的压力，但“降低开发效率”，“增大维护难度”。 \n\nID和Class \n1.一般情况下，多使用clsss,少使用id \n\nCSS hack \n1.IE条件注释法 `<!--[if IE 6]> CSS内容 <![endif]-->` \n2.选择符前缀法 '*' 前缀最对IE6有效, '+前缀只对IE7有效 \n3.样式属性前缀法 '_' 只在IE6下生效, '*'(这是一个星号)在IE6和IE7生效 \n`<style> .test{width:80px;_width:70px;_*width:60px} </style>` \n4.超链接的顺序 LoVe HAte \n5.hasLayout haslayout 是Windows Internet Explorer渲染引擎的一个内部组成部分。hasLayout属性是微软特有的过时属性，在IE8、IE9中，hasLayout属性已经被废弃。 \n\nhaslayout 问题引起的常见 bug： \nIE6 及更低版本的双空白边浮动 bug \nbug 修复: display:inline; \n\nIE5-6/win 的 3 像素偏移 \nbug bug 修复: _height:1%; \n\nIE6 的躲躲猫(peek-a-boo) bug \nbug 修复: _height:1%; 使用\"zoom:1\"可以触发hasLayout. \n\n6.块级元素和行内元素的区别 \n常见块级元素：div、p、form、ul、ol、li等。 \n常见行内元素：sapn、strong、em等。 \n块级元素即使设置了宽度，仍然是独占一行的，宽度自动填满其父元素宽度。\n行内元素不会独占一行，其宽度仅仅随元素的内容而变化。相邻的行内元素会排列在同一行里，直到一行排不下去，才会换行。 \n块级元素可以设置margin和padding属性。行内元素的margin和padding属性只有水平边距，没有竖直边距。行内元素竖直方向的padding虽然增大了面积，但并没有和相邻元素拉开距离。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>模块拆分原则：<br>1.模块与模块之间尽量不要包含相同的部分，如果有相同的部分，应将它们提取出来，拆分成一个独立的模块.<br>2.模块应在保证数量尽可能少的原则下，做到尽可能的简单，以提高重用性。 </p>\n<p>CSS调用：<br>1.将相同的部分抽取出来单独成为一个calss<br>2.多用组合，少用继承<br>3.多使用<code>&lt;div calss=&quot;a b c&quot;&gt;&lt;/a&gt;</code>,少使用<code>&lt;div class=&quot;a_b_c&quot;&gt;&lt;/div&gt;</code> </p>\n<p>上下边距(Margin)：<br>1.如果不确定模块的上下margin特别稳定，最好不要讲它写到模块的类里，而使用类的组合，单独为上下margin挂用于边距的原子类(例如mt10、mt20)。模块最好不要混用margin-top和margin-botton，统一使用margin-top或margin-botton.<br>2.连着的margin-top和margin-botton会合并取两者最大的值。margin-left和margin-right则不会有这样的问题。</p>\n<p>低权重原则<br>1.CSS选择符是有权重的，当不同选择符的样式设置有冲突时，会采用高的选择符设置样式。<br>2.权重规则：HTML标签的权重是1，class的权重是10，id的权重是100，有important标识的权重最大。例如p的权重是1，“div em”权重就是1+1=2，”strong.demo”的权重是1+10=11，”#test .red”的权重是100+10=110.<br>3.如果CSS选择符权重相同，那么样式会遵循就近原则，那个选择符最后定义，就采用那个选择符的样式。 4.”就近原则”指的是选择符定义的先后顺序，而不是挂class名的先后顺序。<br>5.为了保证样式容易被覆盖，提高可维护性，CSS选择符需要保证权证尽可能低。 </p>\n<p>CSS sprise<br>1.是否使用CSS sprise主要取决于网站的流量。最大的好处是减少HTTP请求数，减轻服务器的压力，但“降低开发效率”，“增大维护难度”。 </p>\n<p>ID和Class<br>1.一般情况下，多使用clsss,少使用id </p>\n<p>CSS hack<br>1.IE条件注释法 <code>&lt;!--[if IE 6]&gt; CSS内容 &lt;![endif]--&gt;</code><br>2.选择符前缀法 ‘<em>‘ 前缀最对IE6有效, ‘+前缀只对IE7有效<br>3.样式属性前缀法 ‘_’ 只在IE6下生效, ‘</em>‘(这是一个星号)在IE6和IE7生效<br><code>&lt;style&gt; .test{width:80px;_width:70px;_*width:60px} &lt;/style&gt;</code><br>4.超链接的顺序 LoVe HAte<br>5.hasLayout haslayout 是Windows Internet Explorer渲染引擎的一个内部组成部分。hasLayout属性是微软特有的过时属性，在IE8、IE9中，hasLayout属性已经被废弃。 </p>\n<p>haslayout 问题引起的常见 bug：<br>IE6 及更低版本的双空白边浮动 bug<br>bug 修复: display:inline; </p>\n<p>IE5-6/win 的 3 像素偏移<br>bug bug 修复: _height:1%; </p>\n<p>IE6 的躲躲猫(peek-a-boo) bug<br>bug 修复: _height:1%; 使用”zoom:1”可以触发hasLayout. </p>\n<p>6.块级元素和行内元素的区别<br>常见块级元素：div、p、form、ul、ol、li等。<br>常见行内元素：sapn、strong、em等。<br>块级元素即使设置了宽度，仍然是独占一行的，宽度自动填满其父元素宽度。<br>行内元素不会独占一行，其宽度仅仅随元素的内容而变化。相邻的行内元素会排列在同一行里，直到一行排不下去，才会换行。<br>块级元素可以设置margin和padding属性。行内元素的margin和padding属性只有水平边距，没有竖直边距。行内元素竖直方向的padding虽然增大了面积，但并没有和相邻元素拉开距离。</p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1370579400000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1370579400000,
				"published_by": 2
			},
			{
				"id": "cj914pnxw000qe0hyei7hvwng",
				"title": "【Node.js】环境配置及调试方法",
				"slug": "16",
				"markdown": "\nNode.js可以在不同的操作系统下运行。这里先简单介绍下在windows下的环境配置。\n\n1.首先，下载安装包并安装。在http://nodejs.org，点击download连接，选择windows instraller。\n\n  Node.js会被自动安装在C:\\Program Files\\nodejs中，并会在系统的PATH环境变量中增加了该目录。同时还自动附带了npm(Node包管理器)。此时，可以通过cmd，直接输入node，就会进入Node.js交互模式。\n\n2.运行一个简单的js文件\n\n首先在E盘下建立一个Nodejs文件夹，在这个文件夹下在新建一个文本，保存格式为.js文件。这里我命名为HelloWorld.js。\n\n然后在HelloWorld.js中只有一句简单的代码， console.log('hello world');\n\n接着，在cmd中，进入到Nodejs文件夹下。输入命令：node HelloWorld.js(不区分大小写).此时就可以在控制台中看到输出的结果。\n\n3.基于Chrome浏览器的Node.js的调试方法\n\n首先使用Node Inspector ，它是一个可在webkit内核浏览器下进行nodejs调试的工具，因此只能用在Chrome浏览器中。\n\n先通过npm来安装node-inspector\n\n在cmd打开的命令行中输入\n\n<pre>npm install -g node-inspector </pre>\n\n安装好了之后呢，同样的就在Nodejs文件目录下，以debug的方式打开需要调试的文件，在出现了监听端口的信息后。\n\n重新打开一个命令行窗口，输入\n\n<pre>node-inspector</pre>\n\n这个时候呢，就可以打开chrome浏览器，然后输入http://127.0.0.1:8080/debug?port=5858，就会出现这样一个调试窗口\n\n4.基于Nodejs内建的调试器\n\n在代码中需要断点的地方手动添加一句\n\ndebugger；\n\n然后同样地以debug的方式打开文件，node --debug app.js\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>Node.js可以在不同的操作系统下运行。这里先简单介绍下在windows下的环境配置。</p>\n<p>1.首先，下载安装包并安装。在<a href=\"http://nodejs.org，点击download连接，选择windows\" target=\"_blank\" rel=\"external\">http://nodejs.org，点击download连接，选择windows</a> instraller。</p>\n<p>  Node.js会被自动安装在C:\\Program Files\\nodejs中，并会在系统的PATH环境变量中增加了该目录。同时还自动附带了npm(Node包管理器)。此时，可以通过cmd，直接输入node，就会进入Node.js交互模式。</p>\n<p>2.运行一个简单的js文件</p>\n<p>首先在E盘下建立一个Nodejs文件夹，在这个文件夹下在新建一个文本，保存格式为.js文件。这里我命名为HelloWorld.js。</p>\n<p>然后在HelloWorld.js中只有一句简单的代码， console.log(‘hello world’);</p>\n<p>接着，在cmd中，进入到Nodejs文件夹下。输入命令：node HelloWorld.js(不区分大小写).此时就可以在控制台中看到输出的结果。</p>\n<p>3.基于Chrome浏览器的Node.js的调试方法</p>\n<p>首先使用Node Inspector ，它是一个可在webkit内核浏览器下进行nodejs调试的工具，因此只能用在Chrome浏览器中。</p>\n<p>先通过npm来安装node-inspector</p>\n<p>在cmd打开的命令行中输入</p>\n<pre>npm install -g node-inspector </pre>\n\n<p>安装好了之后呢，同样的就在Nodejs文件目录下，以debug的方式打开需要调试的文件，在出现了监听端口的信息后。</p>\n<p>重新打开一个命令行窗口，输入</p>\n<pre>node-inspector</pre>\n\n<p>这个时候呢，就可以打开chrome浏览器，然后输入<a href=\"http://127.0.0.1:8080/debug?port=5858，就会出现这样一个调试窗口\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8080/debug?port=5858，就会出现这样一个调试窗口</a></p>\n<p>4.基于Nodejs内建的调试器</p>\n<p>在代码中需要断点的地方手动添加一句</p>\n<p>debugger；</p>\n<p>然后同样地以debug的方式打开文件，node –debug app.js</p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1368759840000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1368759840000,
				"published_by": 2
			},
			{
				"id": "cj914pny2000te0hygp2nid6f",
				"title": "【JavaScript高级程序设计】对象的创建与继承",
				"slug": "17",
				"markdown": "\n关于JS面向对象的部分中，关于对象的创建和继承的各种方法，以及这些方法之间的区别和适用场景是经常被问到的。\n\n首先，关于对象的创建。 \n\n1.最简单的方法，大括号创建，var o = {}；或者是用对象字面量方法，var 0 = {name:\"jack\",age = 10}; 问题：当使用相同接口创建很多对象时，会产生大量重复的代码。\n\n2.工厂模式方法：将创建对象的细节封装起来，这样可以解决创建多个相似对象的问题。\n\n```\nfunction createA(){ \n\tvar o = new Object();\n\to.name = \"jack\"; \n\t o.age = 10;      \n\treturn o;  \n}      \nvar A = createA(); \n```\n\n问题：带来了对象识别问题，不能知道一个对象的类型。也就是说用instansOf()方法无法确定对象的类型。 注意：不能用new来调用创建对象的函数，并且在函数的内部要返回那个Object对象。\n\n3.构造函数方法\n```\nfunction Person(name,age){          \n\tthis.name = name;          \n\tthis.age = age;          \n\tthis.sayName = function (){              \n\t\talert(this.name);          \n\t}      \n}          \nvar person = new Person(\"jack\",10);\n```\n通过检查实例的constructor属性，或者使用instanceof()方法可以确定对象的类型。 \n问题：每个方法都要在每个实例上创建；创建多个完成相同任务的Function实例是没必要的。             如果把这样的Funtion从构造函数中移除来，则函数会变成为全局环境中的成员，破坏了封装性。 \n\n4.原型模式 \n原型:是指向一个对象的，这个对象包含由所有实例共享的方法和属性。\n```\nfunction Person(){   }      \nPerson.prototype.name = \"jack\";      \nPerson.prototype.age = 10;      \nPerson.prototype.sayName = function (){          \n\talert(this.name);      \n}  \nvar wang = new Person();  \n```\n注意：所有的实例保存的仅是指向对象原型的指针。所有实例共享原型的属性和方法。实例可以重写属性，覆盖原型对象中的相同属性，但是并不改变原型中的这个属性。 可以使用hasOwnPropertyp()来判断，当属性存在于对象中时返回true。`if (wang.hasOwnProperty(\"name\")) {alert(true);} `\n比如:\n``` \nvar wang = new Person();\n\tconsole.log(wang.age); //10\n\twang.age = 20;\n\tconsole.log(wang.age); //20\n\tvar li = new Person();\n\tconsole.log(li.age);   //10\n```\n\n问题：省略了为构造函数传参，所有实例在默认情况下都取得相同的属性值。尤其当属性为引用值时，会相互干扰。 \n5.组合构造函数和原型模式 将实例属性在构造函数中定义。 所有实例共享的属性和方法在原型中定义。 \n```\nfunction Person(name,age){          \n\tthis.name = name;          \n\tthis.age = age;      \n}          \nPerson.prototype = {          \n\tconstructor: Person,          \n\tsayName: function(){              \n\t\talert(this.name);          \n\t}      \n};      \nvar wang = new Person(\"jack\",10);     \nwang.sayName();      \nvar li = new Person(\"nike\", 10);      \nli.sayName();  \n```\n\n说完了对象的创建，再说一下对象的继承。 \n1.原型链继承 每一个构造函数中都有一个指针prototype，这个指针指向原型对象，而原型对象中又都有一个属性constructor，指向这个构造函数。同时每个实例中都有一个指向原型对象的指针。\n```\n function SuperType(){      } \n  SuperType.prototype.getSuperValue = function(){      };  \n function subType(){      }  \n subType.prototype = new SuperType();//重写了subType的原型,此时constructor指向superType的原型对象  \n subType.prototype.getSubValue = function(){      };  \n```\n\n注意：新加的子类原型方法，应该在继承了父亲原型之后。            使用原型链方法继承时，不能用对象字面量来创建原型方法，这样会重写子类原型，使得constructor指向Object。 \n问题：\na.由于包含引用型的原型属性会被所有实例共享。所以，如果父类的构造函数中有一个引用型数组，则对父类的每一个实例间无影响。 但是子类的原型是父类的一个实例。子类的所有实例都会共享这个属性\nb.创建子类实例时无法向父类的构造函数传参。 \n\n2.借用构造函数  \n```\nfunction superType(name){      \n\tthis.name = name;      \n\tthis.colors = [\"black\",\"green\"];  \n}  \nfunction subType(){      \n\tsuperType.call(this,\"jack\");      \n\tthis.age = 10;  \n}  \n```\n\n在调用subType()时，会借调superType()的所有代码，子类的实例创建实例自己的colors副本。 \n问题：方法都在构造函数中定义，没有了函数的复用。\n同时，在父类原型中定义的方法和属性，子类无法继承到。 \n\n3.组合继承 通过原型链来实现对原型属性和方法的继承；借用构造函数来实现对实例属性的继承。 \n问题：无论在什么情况下，都会调用2次父类构造函数。 \n```\nfunction superType(name){\n\t\t\tthis.name = name;\n\t\t}\n\t\tsuperType.prototype.getSuperValue = function(){\n\n\t\t};\n\t\tfunction subType(name,age){\n\t\t\tsuperType.call(this,name);\n\t\t\tthis.age = age;\n\t\t}\n\t\tsubType.prototype = new superType();\n\t\tsubType.prototype.constructor = subType;\n\t\tsubType.prototype.sayAge = function(){\n\n\t\t}\n```\n\n4.原型式继承 \n基于现有的对象，再创建一个新对象。 \n适用场景：只想让一个对象与另一个对象保持相似的情况下。 \n```\nfunction object(o){      \n\tfunction F(){} //创建临时性的构造函数      \n\tF.prototype = o;//将传入的对象作为这个构造函数的原型      \n\treturn new F();//返回这个临时类型的新实例  \n}  \n```\n\nobject()对传入的对象进行了浅复制。 \n`person1 = object(Person); person2 = object(Person);` 相当于创建了2个person的副本。 \n\n5.寄生式继承 \n与创建对象的工厂模式类似 \n```\nfunction another(o){\n\t\t\tvar clone = object(o);\n\t\t\tclone.sayHi = function(){\n\n\t\t\t};\n\t\t\treturn clone;\n\t\t}\n```\n\n问题：无法做到函数的复用。 \n\n6.寄生组合式 \n这是最有效的一种继承方式。只调用了一次superType()构造函数，同时还没有改变原型链。 \n首先创建如下函数：\n```\nfunction ip(subType,superType){      \n\tvar prototype = object(superType.prototype);      \n\tprototype.constructor = subType;      \n\tsubType.prototype = prototype;  \n}  \n```\n\n然后使用时，与组合继承类似，但是不同的是将`subType.prototype = new superType();subType.prototype.constructor = subType;`这两句代码换成，`ip(subType,superType);`\n 最后，理解对象的创建和继承，关键是理解构造函数，原型对象以及实例之间的关系。这个稍后上图。 \n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>关于JS面向对象的部分中，关于对象的创建和继承的各种方法，以及这些方法之间的区别和适用场景是经常被问到的。</p>\n<p>首先，关于对象的创建。 </p>\n<p>1.最简单的方法，大括号创建，var o = {}；或者是用对象字面量方法，var 0 = {name:”jack”,age = 10}; 问题：当使用相同接口创建很多对象时，会产生大量重复的代码。</p>\n<p>2.工厂模式方法：将创建对象的细节封装起来，这样可以解决创建多个相似对象的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createA</span>(<span class=\"params\"></span>)</span>&#123; </div><div class=\"line\">\t<span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\">\to.name = <span class=\"string\">\"jack\"</span>; </div><div class=\"line\">\t o.age = <span class=\"number\">10</span>;      </div><div class=\"line\">\t<span class=\"keyword\">return</span> o;  </div><div class=\"line\">&#125;      </div><div class=\"line\"><span class=\"keyword\">var</span> A = createA();</div></pre></td></tr></table></figure>\n<p>问题：带来了对象识别问题，不能知道一个对象的类型。也就是说用instansOf()方法无法确定对象的类型。 注意：不能用new来调用创建对象的函数，并且在函数的内部要返回那个Object对象。</p>\n<p>3.构造函数方法<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">(name,age)</span></span>&#123;          </div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;          </div><div class=\"line\">\t<span class=\"keyword\">this</span>.age = age;          </div><div class=\"line\">\t<span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;              </div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name);          </div><div class=\"line\">\t&#125;      </div><div class=\"line\">&#125;          </div><div class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"jack\"</span>,<span class=\"number\">10</span>);</div></pre></td></tr></table></figure></p>\n<p>通过检查实例的constructor属性，或者使用instanceof()方法可以确定对象的类型。<br>问题：每个方法都要在每个实例上创建；创建多个完成相同任务的Function实例是没必要的。             如果把这样的Funtion从构造函数中移除来，则函数会变成为全局环境中的成员，破坏了封装性。 </p>\n<p>4.原型模式<br>原型:是指向一个对象的，这个对象包含由所有实例共享的方法和属性。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">()</span></span>&#123;   &#125;      </div><div class=\"line\">Person.prototype.name = <span class=\"string\">\"jack\"</span>;      </div><div class=\"line\">Person.prototype.age = <span class=\"number\">10</span>;      </div><div class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;          </div><div class=\"line\">\talert(<span class=\"keyword\">this</span>.name);      </div><div class=\"line\">&#125;  </div><div class=\"line\"><span class=\"keyword\">var</span> wang = <span class=\"keyword\">new</span> Person();</div></pre></td></tr></table></figure></p>\n<p>注意：所有的实例保存的仅是指向对象原型的指针。所有实例共享原型的属性和方法。实例可以重写属性，覆盖原型对象中的相同属性，但是并不改变原型中的这个属性。 可以使用hasOwnPropertyp()来判断，当属性存在于对象中时返回true。<code>if (wang.hasOwnProperty(&quot;name&quot;)) {alert(true);}</code><br>比如:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> wang = <span class=\"keyword\">new</span> Person();</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(wang.age); <span class=\"comment\">//10</span></div><div class=\"line\">\twang.age = <span class=\"number\">20</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(wang.age); <span class=\"comment\">//20</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> li = <span class=\"keyword\">new</span> Person();</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(li.age);   <span class=\"comment\">//10</span></div></pre></td></tr></table></figure></p>\n<p>问题：省略了为构造函数传参，所有实例在默认情况下都取得相同的属性值。尤其当属性为引用值时，会相互干扰。<br>5.组合构造函数和原型模式 将实例属性在构造函数中定义。 所有实例共享的属性和方法在原型中定义。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">(name,age)</span></span>&#123;          </div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;          </div><div class=\"line\">\t<span class=\"keyword\">this</span>.age = age;      </div><div class=\"line\">&#125;          </div><div class=\"line\">Person.prototype = &#123;          </div><div class=\"line\">\tconstructor: Person,          </div><div class=\"line\">\tsayName: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;              </div><div class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name);          </div><div class=\"line\">\t&#125;      </div><div class=\"line\">&#125;;      </div><div class=\"line\"><span class=\"keyword\">var</span> wang = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"jack\"</span>,<span class=\"number\">10</span>);     </div><div class=\"line\">wang.sayName();      </div><div class=\"line\"><span class=\"keyword\">var</span> li = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"nike\"</span>, <span class=\"number\">10</span>);      </div><div class=\"line\">li.sayName();</div></pre></td></tr></table></figure></p>\n<p>说完了对象的创建，再说一下对象的继承。<br>1.原型链继承 每一个构造函数中都有一个指针prototype，这个指针指向原型对象，而原型对象中又都有一个属性constructor，指向这个构造函数。同时每个实例中都有一个指向原型对象的指针。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span><span class=\"params\">()</span></span>&#123;      &#125; </div><div class=\"line\"> SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;      &#125;;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subType</span><span class=\"params\">()</span></span>&#123;      &#125;  </div><div class=\"line\">subType.prototype = <span class=\"keyword\">new</span> SuperType();<span class=\"comment\">//重写了subType的原型,此时constructor指向superType的原型对象  </span></div><div class=\"line\">subType.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;      &#125;;</div></pre></td></tr></table></figure></p>\n<p>注意：新加的子类原型方法，应该在继承了父亲原型之后。            使用原型链方法继承时，不能用对象字面量来创建原型方法，这样会重写子类原型，使得constructor指向Object。<br>问题：<br>a.由于包含引用型的原型属性会被所有实例共享。所以，如果父类的构造函数中有一个引用型数组，则对父类的每一个实例间无影响。 但是子类的原型是父类的一个实例。子类的所有实例都会共享这个属性<br>b.创建子类实例时无法向父类的构造函数传参。 </p>\n<p>2.借用构造函数<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">superType</span><span class=\"params\">(name)</span></span>&#123;      </div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name;      </div><div class=\"line\">\t<span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"black\"</span>,<span class=\"string\">\"green\"</span>];  </div><div class=\"line\">&#125;  </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subType</span><span class=\"params\">()</span></span>&#123;      </div><div class=\"line\">\tsuperType.call(<span class=\"keyword\">this</span>,<span class=\"string\">\"jack\"</span>);      </div><div class=\"line\">\t<span class=\"keyword\">this</span>.age = <span class=\"number\">10</span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在调用subType()时，会借调superType()的所有代码，子类的实例创建实例自己的colors副本。<br>问题：方法都在构造函数中定义，没有了函数的复用。<br>同时，在父类原型中定义的方法和属性，子类无法继承到。 </p>\n<p>3.组合继承 通过原型链来实现对原型属性和方法的继承；借用构造函数来实现对实例属性的继承。<br>问题：无论在什么情况下，都会调用2次父类构造函数。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">superType</span><span class=\"params\">(name)</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tsuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subType</span><span class=\"params\">(name,age)</span></span>&#123;</div><div class=\"line\">\t\t\tsuperType.call(<span class=\"keyword\">this</span>,name);</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.age = age;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tsubType.prototype = <span class=\"keyword\">new</span> superType();</div><div class=\"line\">\t\tsubType.prototype.constructor = subType;</div><div class=\"line\">\t\tsubType.prototype.sayAge = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure></p>\n<p>4.原型式继承<br>基于现有的对象，再创建一个新对象。<br>适用场景：只想让一个对象与另一个对象保持相似的情况下。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span><span class=\"params\">(o)</span></span>&#123;      </div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span><span class=\"params\">()</span></span>&#123;&#125; <span class=\"comment\">//创建临时性的构造函数      </span></div><div class=\"line\">\tF.prototype = o;<span class=\"comment\">//将传入的对象作为这个构造函数的原型      </span></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();<span class=\"comment\">//返回这个临时类型的新实例  </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>object()对传入的对象进行了浅复制。<br><code>person1 = object(Person); person2 = object(Person);</code> 相当于创建了2个person的副本。 </p>\n<p>5.寄生式继承<br>与创建对象的工厂模式类似<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">another</span><span class=\"params\">(o)</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> <span class=\"keyword\">clone</span> = object(o);</div><div class=\"line\">\t\t\t<span class=\"keyword\">clone</span>.sayHi = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t&#125;;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">clone</span>;</div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure></p>\n<p>问题：无法做到函数的复用。 </p>\n<p>6.寄生组合式<br>这是最有效的一种继承方式。只调用了一次superType()构造函数，同时还没有改变原型链。<br>首先创建如下函数：<br><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"title\">function</span> ip(subType,superType)&#123;      </div><div class=\"line\">\tvar proto<span class=\"keyword\">type</span> = object(superType.prototype);      </div><div class=\"line\">\tproto<span class=\"keyword\">type</span>.constructor = subType;      </div><div class=\"line\">\tsubType.proto<span class=\"keyword\">type</span> = prototype;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后使用时，与组合继承类似，但是不同的是将<code>subType.prototype = new superType();subType.prototype.constructor = subType;</code>这两句代码换成，<code>ip(subType,superType);</code><br> 最后，理解对象的创建和继承，关键是理解构造函数，原型对象以及实例之间的关系。这个稍后上图。 </p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1367993280000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1367993280000,
				"published_by": 2
			},
			{
				"id": "cj914pny5000we0hynj32a8ly",
				"title": "字符串匹配【KMP算法】",
				"slug": "18",
				"markdown": "\n看到一个最直接，浅而易见的讲解。\n\n直接上地址：http://www.admin10000.com/document/1974.html",
				"html": "<p>看到一个最直接，浅而易见的讲解。</p>\n<p>直接上地址：<a href=\"http://www.admin10000.com/document/1974.html\" target=\"_blank\" rel=\"external\">http://www.admin10000.com/document/1974.html</a></p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1367914620000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1367914620000,
				"published_by": 2
			},
			{
				"id": "cj914pny7000ze0hyl8rcjfa1",
				"title": "字符串匹配【Boyer-Moore算法】",
				"slug": "19",
				"markdown": "\n直接上地址，http://www.admin10000.com/document/1989.html\n\n两个关键词：坏字符；好后缀",
				"html": "<p>直接上地址，<a href=\"http://www.admin10000.com/document/1989.html\" target=\"_blank\" rel=\"external\">http://www.admin10000.com/document/1989.html</a></p>\n<p>两个关键词：坏字符；好后缀</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1367914020000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1367914020000,
				"published_by": 2
			},
			{
				"id": "cj914pny90015e0hyfzxdbryd",
				"title": "【JS】大整数相加，相乘",
				"slug": "20",
				"markdown": "\n1. 首先，对于大整数，是指超过规定类型的整数，它一般的存储类型为字符串类型char。所以大整数的加、乘，实际上就是模拟手工运算。做每一位的运算。\n在JS中，需要将字符串中的每一位字符利用parseInt()转成整数，再做加减，否则最后的结果是字符串的连接。\n\n2. 其次，对于大整数加法，考虑的比较简单，因为每一位若是有进位，则最多进位是1。需要考虑的特殊情况是，在最高位如果有进位，则需要再最高位的下一位加1；同时还需要考虑，当两个数是不同位数时，需要考虑较短的数加完之后，剩下较长数自身与进位之间的累加。\n\n3. 对于大整数乘法，因为相乘之后的进位会有大于1的情况，所以不能简单的用进位标志来表示，而是利用Math.floor(temp / 10)来取得进了几位。如果该位上的数大于10，那么就做除法，将进位叠加到下一位上，自己的位置上保留对10取余的数。\n\n大整数相加：\n```\n<script type='text/javascript'>\n    function add(a , b){\n        var addFlag,str1,str2,na,nb,Maxlen = [],Minlen = [],result = [];\n\n        addFlag = 0;\n\n        str1 = a.split(\"\");\n        str2 = b.split(\"\");\n        na = str1.length;\n        nb = str2.length;\n\n        //保证Maxlen总是指向长度最长的那个\n       if(na >= nb )\n       {\n            Maxlen = str1;\n            Minlen = str2;\n       }else{\n            Maxlen = str2;\n            Minlen = str1;\n       }\n\n        for(var i = Maxlen.length - 1;i >= 0;i--)\n        {\n\n            if(Minlen.length > i)\n                temp = parseInt(Maxlen[i]) + parseInt(Minlen[i]) + addFlag;\n            else\n            //如果长度较短的数组所有位被加完了，那么就只剩下较长数组自身与进位间的累加\n                temp = parseInt(Maxlen[i]) + addFlag;\n\n            if(temp > 9)\n            {\n                result[i] = temp - 10;\n                //最高位若有进位，需在再在最高位的下一位加1\n                    if(i == (Maxlen.length - 1)) result[Maxlen.length] = 1;\n                addFlag = 1;\n            }else{\n                result.push(temp);\n                addFlag = 0;\n            }\n        }\n        return result.reverse().join(\"\");\n    }\n    var c = add(\"92395\",\"5556789\");\n    console.log(c);\n    </script>\n```\n\n大整数相乘：\n```\nfunction multi(a,b){\n        var str1,str2,len1,len2,maxlen,result = [];\n\n        str1 = a.split(\"\").reverse();\n        str2 = b.split(\"\").reverse();\n        len1 = str1.length;\n        len2 = str2.length;\n\n//因为要在下一步做累加，如果不初始化为0，result[]中的值会变为NaN\n//因为未初始化的数组中的值为undefined\n        for(var i = 0;i < len1;i++)\n            for(var j = 0;j < len2;j++)\n                result[i + j] = 0;\n\n        for(var i = 0;i < len1;i++)\n            for(var j = 0;j < len2;j++)\n    //根据乘法的手动计算方式，在上下相同位上会有相加\n                result[i + j] += parseInt(str1[i]) * parseInt(str2[j]);\n\n        var n = result.length;\n        for(var k = 0;k < n;k++)\n        {\n            var temp = result[k];\n            if(temp >= 10)\n            {\n                result[k] = temp % 10;\n                //JS中的\"/\"不是除法取整，会取得小数，所以要用Math.floor()\n                result[k + 1] +=  Math.floor(temp / 10);\n            }\n        }\n        return result.reverse().join(\"\");\n    }\n    var d = multi(\"144444\",\"12223344\");\n    console.log(d);\n    </script>\n```\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<ol>\n<li><p>首先，对于大整数，是指超过规定类型的整数，它一般的存储类型为字符串类型char。所以大整数的加、乘，实际上就是模拟手工运算。做每一位的运算。<br>在JS中，需要将字符串中的每一位字符利用parseInt()转成整数，再做加减，否则最后的结果是字符串的连接。</p>\n</li>\n<li><p>其次，对于大整数加法，考虑的比较简单，因为每一位若是有进位，则最多进位是1。需要考虑的特殊情况是，在最高位如果有进位，则需要再最高位的下一位加1；同时还需要考虑，当两个数是不同位数时，需要考虑较短的数加完之后，剩下较长数自身与进位之间的累加。</p>\n</li>\n<li><p>对于大整数乘法，因为相乘之后的进位会有大于1的情况，所以不能简单的用进位标志来表示，而是利用Math.floor(temp / 10)来取得进了几位。如果该位上的数大于10，那么就做除法，将进位叠加到下一位上，自己的位置上保留对10取余的数。</p>\n</li>\n</ol>\n<p>大整数相加：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">'text/javascript'</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a , b</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> addFlag,str1,str2,na,nb,Maxlen = [],Minlen = [],result = [];</div><div class=\"line\"></div><div class=\"line\">        addFlag = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        str1 = a.split(<span class=\"string\">\"\"</span>);</div><div class=\"line\">        str2 = b.split(<span class=\"string\">\"\"</span>);</div><div class=\"line\">        na = str1.length;</div><div class=\"line\">        nb = str2.length;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">//保证Maxlen总是指向长度最长的那个</span></div><div class=\"line\">       <span class=\"keyword\">if</span>(na &gt;= nb )</div><div class=\"line\">       &#123;</div><div class=\"line\">            Maxlen = str1;</div><div class=\"line\">            Minlen = str2;</div><div class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            Maxlen = str2;</div><div class=\"line\">            Minlen = str1;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = Maxlen.length - <span class=\"number\">1</span>;i &gt;= <span class=\"number\">0</span>;i--)</div><div class=\"line\">        &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span>(Minlen.length &gt; i)</div><div class=\"line\">                temp = <span class=\"built_in\">parseInt</span>(Maxlen[i]) + <span class=\"built_in\">parseInt</span>(Minlen[i]) + addFlag;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"comment\">//如果长度较短的数组所有位被加完了，那么就只剩下较长数组自身与进位间的累加</span></div><div class=\"line\">                temp = <span class=\"built_in\">parseInt</span>(Maxlen[i]) + addFlag;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span>(temp &gt; <span class=\"number\">9</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                result[i] = temp - <span class=\"number\">10</span>;</div><div class=\"line\">                <span class=\"comment\">//最高位若有进位，需在再在最高位的下一位加1</span></div><div class=\"line\">                    <span class=\"keyword\">if</span>(i == (Maxlen.length - <span class=\"number\">1</span>)) result[Maxlen.length] = <span class=\"number\">1</span>;</div><div class=\"line\">                addFlag = <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                result.push(temp);</div><div class=\"line\">                addFlag = <span class=\"number\">0</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result.reverse().join(<span class=\"string\">\"\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> c = add(<span class=\"string\">\"92395\"</span>,<span class=\"string\">\"5556789\"</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(c);</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>大整数相乘：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multi</span>(<span class=\"params\">a,b</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> str1,str2,len1,len2,maxlen,result = [];</div><div class=\"line\"></div><div class=\"line\">        str1 = a.split(<span class=\"string\">\"\"</span>).reverse();</div><div class=\"line\">        str2 = b.split(<span class=\"string\">\"\"</span>).reverse();</div><div class=\"line\">        len1 = str1.length;</div><div class=\"line\">        len2 = str2.length;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//因为要在下一步做累加，如果不初始化为0，result[]中的值会变为NaN</span></div><div class=\"line\"><span class=\"comment\">//因为未初始化的数组中的值为undefined</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; len1;i++)</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>;j &lt; len2;j++)</div><div class=\"line\">                result[i + j] = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i &lt; len1;i++)</div><div class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>;j &lt; len2;j++)</div><div class=\"line\">    <span class=\"comment\">//根据乘法的手动计算方式，在上下相同位上会有相加</span></div><div class=\"line\">                result[i + j] += <span class=\"built_in\">parseInt</span>(str1[i]) * <span class=\"built_in\">parseInt</span>(str2[j]);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">var</span> n = result.length;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>;k &lt; n;k++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> temp = result[k];</div><div class=\"line\">            <span class=\"keyword\">if</span>(temp &gt;= <span class=\"number\">10</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                result[k] = temp % <span class=\"number\">10</span>;</div><div class=\"line\">                <span class=\"comment\">//JS中的\"/\"不是除法取整，会取得小数，所以要用Math.floor()</span></div><div class=\"line\">                result[k + <span class=\"number\">1</span>] +=  <span class=\"built_in\">Math</span>.floor(temp / <span class=\"number\">10</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result.reverse().join(<span class=\"string\">\"\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> d = multi(<span class=\"string\">\"144444\"</span>,<span class=\"string\">\"12223344\"</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(d);</div><div class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1366705860000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1366705860000,
				"published_by": 2
			},
			{
				"id": "cj914pnya0018e0hy91pynnik",
				"title": "【面试-概率】喝茶，喝咖啡",
				"slug": "21",
				"markdown": "\n问：一个办公室里喜欢喝茶的有70%，喜欢喝咖啡85%，那同时喜欢喝咖啡和喝茶的有多少？\n\n答：其实这个有一个区间，最大值的和最小值。\n\n最大值就是大概率的喝咖啡的人把较小概率的喝茶的人全部包括了。即取两者较小的概率70%。\n\n最小值，就是大概率的喝咖啡的人要最大程度的覆盖不喜欢喝茶的人，即85%-30%=55%.\n\nPS:这是腾讯面试比较常问的一道题，以前有遇到过，但是这次自己被问到的时候，还是懵了。。。面试官提示了好多次还是没想出来。。。。T_T。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>问：一个办公室里喜欢喝茶的有70%，喜欢喝咖啡85%，那同时喜欢喝咖啡和喝茶的有多少？</p>\n<p>答：其实这个有一个区间，最大值的和最小值。</p>\n<p>最大值就是大概率的喝咖啡的人把较小概率的喝茶的人全部包括了。即取两者较小的概率70%。</p>\n<p>最小值，就是大概率的喝咖啡的人要最大程度的覆盖不喜欢喝茶的人，即85%-30%=55%.</p>\n<p>PS:这是腾讯面试比较常问的一道题，以前有遇到过，但是这次自己被问到的时候，还是懵了。。。面试官提示了好多次还是没想出来。。。。T_T。</p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1366696080000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1366696080000,
				"published_by": 2
			},
			{
				"id": "cj914pnyb001be0hyl9wizqul",
				"title": "【自制】网站发布流程",
				"slug": "22",
				"markdown": "\n这是在2012年7月的时候，自己发布一个小型网站的流程。现在搬到这里来。\n\n1.注册一个域名\n\n可以在美橙网等注册一个域名，往往要花钱。\n\n2.域名解析\n\n要先租用主机，然后再在你注册域名的网站同时进行域名解析\n\n注意：两个记录类型都是A记录，@是可以在地址栏直接访问域名，www是在地址栏里“www.aaa.com”的形式访问域名。\n\n3.租用虚拟主机\n\n这个可以有免费的，如主机屋，但是在网页下方会有广告。（这样说来也不能算是免费的了）\n\n4.将主机与你的域名绑定，当出现下图之后说明已绑定成功，并解析成功。\n\n这说明，ping 域名，然后是从你主机的IP返回消息，就说明已成功。这时候就可以将你的代码上传到你的虚拟主机上。\n\n5.把网站加到白名单中（很多虚拟主机提供商还提供免备案的，那这一步就可以略过了）\n\n在租用虚拟主机的网站，要求将网站加到白名单中。这个可以自己操作，是实名信息的登记，并且还要传照片。或者可以找客服帮助。时间大概是半个小时。之后如果可以可以直接通过浏览器访问到域名，就说明已经成功了。\n\n6.使用FTP上传工具，上传代码到虚拟主机的web目录下。如：FlashFXP工具。\n\n7\\. 如果你的代码要用到数据库，那么还要在你虚拟主机的网站那儿开通MYSQL的数据库，这个也是可以免费的。注意在连接MYSQL的代码中，hostname，不能写虚拟主机的IP，要写127.0.0.1。否则会报错，提示不能直接访问数据库服务器。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>这是在2012年7月的时候，自己发布一个小型网站的流程。现在搬到这里来。</p>\n<p>1.注册一个域名</p>\n<p>可以在美橙网等注册一个域名，往往要花钱。</p>\n<p>2.域名解析</p>\n<p>要先租用主机，然后再在你注册域名的网站同时进行域名解析</p>\n<p>注意：两个记录类型都是A记录，@是可以在地址栏直接访问域名，www是在地址栏里“www.aaa.com”的形式访问域名。</p>\n<p>3.租用虚拟主机</p>\n<p>这个可以有免费的，如主机屋，但是在网页下方会有广告。（这样说来也不能算是免费的了）</p>\n<p>4.将主机与你的域名绑定，当出现下图之后说明已绑定成功，并解析成功。</p>\n<p>这说明，ping 域名，然后是从你主机的IP返回消息，就说明已成功。这时候就可以将你的代码上传到你的虚拟主机上。</p>\n<p>5.把网站加到白名单中（很多虚拟主机提供商还提供免备案的，那这一步就可以略过了）</p>\n<p>在租用虚拟主机的网站，要求将网站加到白名单中。这个可以自己操作，是实名信息的登记，并且还要传照片。或者可以找客服帮助。时间大概是半个小时。之后如果可以可以直接通过浏览器访问到域名，就说明已经成功了。</p>\n<p>6.使用FTP上传工具，上传代码到虚拟主机的web目录下。如：FlashFXP工具。</p>\n<p>7. 如果你的代码要用到数据库，那么还要在你虚拟主机的网站那儿开通MYSQL的数据库，这个也是可以免费的。注意在连接MYSQL的代码中，hostname，不能写虚拟主机的IP，要写127.0.0.1。否则会报错，提示不能直接访问数据库服务器。</p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1366009980000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1366009980000,
				"published_by": 2
			},
			{
				"id": "cj914pnyd001ee0hyf4lah9pc",
				"title": "【2013】第一次",
				"slug": "23",
				"markdown": "\n4月的武汉，像疯了般，气温达到30度，在这炎热的不知是春还是夏的季节里，开始自己的技术博客第一篇文章。也会慢慢把自己平时积累的一些笔记和资料搬到这里来。\n\n版权声明：本文为博主原创文章，未经博主允许不得转载。",
				"html": "<p>4月的武汉，像疯了般，气温达到30度，在这炎热的不知是春还是夏的季节里，开始自己的技术博客第一篇文章。也会慢慢把自己平时积累的一些笔记和资料搬到这里来。</p>\n<p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p>\n",
				"image": null,
				"featured": 0,
				"page": 0,
				"status": "published",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1366009620000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1366009620000,
				"published_by": 2
			},
			{
				"id": "cj914pnxh0009e0hydem3z45a",
				"title": "",
				"markdown": "function ShowSuggestBox(arg){\n\t\t\tthis.arg = arg;\n\t\t\t// 初始化实例\n\t\t\tthis.init(arg); \n\t\t};\n\n\n\t\tShowSuggestBox.prototype = {\n\t\t\t// 类初始化\n\t\t\tinit : function (arg){\n\t\t\t\t// 保存当前选中的节点\n\t\t\t\tthis.selectedNode = null;\n\t\t\t\t// 保存li节点\n\t\t\t\tthis.elLi = null,\n\t\t\t\t// 创建UL节点  \n\t\t\t\tthis.elUl = $('<ul class=\"mh-ui-suggest mh-ui-suggest-none\"></ul>');\n\t\t\t\t// Body节点\n\t\t\t\tthis.elBody = $('body');\n\t\t\t\t// 触发sug的input\n\t\t\t\tthis.triggerInput = $('.'+arg.sugInputName);\n\t\t\t\t// 保存input的值\n\t\t\t\tthis.caseInputValue = this.triggerInput.val();\n\t\t\t\t// 选中class \n\t\t\t\tthis.selClass = 'mh-ui-suggest-sel';\n\t\t\t\t// 事件\n\t\t\t\tthis.addEvent();\n\t\t\t},\n\n\n\t\t\t// 事件\n\t\t\taddEvent : function (){\n\t\t\t\tvar t = this;\n\t\t\t\t// 当前表单\n\t\t\t\tvar input = this.triggerInput;\n\t\t\t\t// 异步延迟ID\n\t\t\t\tvar setTimeId;\n\n\t\t\t\t// 监听输入事件\n\t\t\t\tinput.on('input propertychange', function (e){\n\t\t\t\t\tvar el = $(this);\n\t\t\t\t\t\n\t\t\t\t\t// 清除延迟ID\n\t\t\t\t\tsetTimeId && clearTimeout(setTimeId);\n\t\t\t\t\t// 延迟请求 避免覆盖\n\t\t\t\t\tsetTimeId = setTimeout(function (){\n\t\t\t\t\t\t// Sug列表\n\t\t\t\t\t\tt.showSug(el);\n\t\t\t\t\t}, 0);\n\t\t\t\t});\n\n\t\t\t\tinput.on('blur', function (e){\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t// 关闭其他sug列表\n\t\t\t\t\tt.removeSug(e);\n\t\t\t\t});\n\n\t\t\t\t// 监听上下箭头\n\t\t\t\tinput.on('keydown', function (e){\n\t\t\t\t\t// 移动背景位置\n\t\t\t\t\tt.sugPoit(e);\n\t\t\t\t});\n\n\t\t\t\t// Sug划过背景\n\t\t\t\tthis.elUl.on('mouseover', function (e){\n\t\t\t\t\tt.mouserBack(e);\n\t\t\t\t});\n\n\t\t\t\t// 点击Sug节点\n\t\t\t\tthis.elUl.on('click', function (e){\n\t\t\t\t\tt.setInputValue(e);\n\t\t\t\t});\n\n\t\t\t\t// 关闭事件\n\t\t\t\tthis.elBody.on('click', function (){\n\t\t\t\t\tt.removeSug();\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\t// 展现sug列表\n\t\t\tshowSug : function (el){\n\t\t\t\tvar t = this;\n\t\t\t\t// URL\n\t\t\t\tvar url = this.arg.url;\n\t\t\t\t// callbackName\n\t\t\t\tvar jsonpCallback = this.arg.jsonpCallback;\n\t\t\t\t// 参数\n\t\t\t\tvar data = this.arg.data;\n\t\t\t\t// 输入框的Value\n\t\t\t\tvar iValue = el.val();\n\t\t\t\t// 修正input BUG\n\t\t\t\t// 中文输入下 点击其他节点时触发input事件\n\t\t\t\tif(iValue==this.caseInputValue) return false;\n\t\t\t\t// 重置input的值\n\t\t\t\tthis.caseInputValue = iValue;\n\t\t\t\t\n\t\t\t\t//为参数赋值\n\t\t\t\tdata[t.arg.query] = iValue;\n\n\t\t\t\t// XHR\n\t\t\t\tvar ajax = function (){\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl : url,\n\t\t\t\t\t\ttype : 'POST',\n\t\t\t\t\t\tdata : data,\n\t\t\t\t\t\tdataType : 'jsonp',\n\t\t\t\t\t\tjsonpCallback: jsonpCallback,\n\t\t\t\t\t\tsuccess : function (data){\n\t\t\t\t\t\t\tvar dataResult = data[t.arg.result];\n\n\t\t\t\t\t\t\tif(dataResult.length){\n\t\t\t\t\t\t\t\tt.joinHTML(data[t.arg.result], el);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tt.removeSug();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\t// 输入框是否有值 调用ajax || 隐藏sug\n\t\t\t\tiValue ? ajax() : t.removeSug();\n\t\t\t},\n\n\n\t\t\t// HTML\n\t\t\tjoinHTML : function (data, el){\n\t\t\t\tif(data && data.length){\n\t\t\t\t\t// 拼接HTML\n\t\t\t\t\t// 拼html代码\n\t\t\t\t\tvar elLi = this.createHTML(data);\n\t\t\t\t\t// 获取位置\n\t\t\t\t\tvar clickClient = this.getPoin(el);\n\t\t\t\t\t// 修正值\n\t\t\t\t\tvar top = 0, left = 0;\n\t\t\t\t\t// 获取修正值\n\t\t\t\t\tvar correctedPosition = this.arg.correctedPosition || 0;\n\t\t\t\t\t\n\t\t\t\t\tif(correctedPosition){\n\t\t\t\t\t\ttop = correctedPosition.top;\n\t\t\t\t\t\tleft = correctedPosition.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sug列表位置\n\t\t\t\t\t// 为了防止以外Bug 此处每次都计算Sug位置\n\t\t\t\t\tthis.elUl.removeClass('mh-ui-suggest-none').css({\n\t\t\t\t\t\t// 用offsetHeight原生方法 避免outerHeight被重写\n\t\t\t\t\t\ttop : clickClient.top + el[0].offsetHeight + top + 'px',\n\t\t\t\t\t\tleft : clickClient.left + left + 'px'\n\t\t\t\t\t});\n\n\t\t\t\t\t// 保存所有的li节点\n\t\t\t\t\tthis.elLi = $('li', this.elUl);\n\n\t\t\t\t\t// 每次初始化sug列表时 初始化默认划过的节点\n\t\t\t\t\tthis.selectedNode = this.elLi.eq(0);\n\n\t\t\t\t\t// 插入到页面\n\t\t\t\t\tthis.elBody.append(elLi);\n\t\t\t\t}else{\n\t\t\t\t\t// 删除Sug列表\n\t\t\t\t\tthis.removeSug();\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// Sug列表\n\t\t\tcreateHTML : function (data){\n\t\t\t\tvar t = this;\n\t\t\t\t// html数组\n\t\t\t\tvar arrHtml = [];\n\t\t\t\t// 计数 大于7退出\n\t\t\t\tvar dataNum = 0;\n\n\t\t\t\t/* 显示的数据字段名\n\t\t\t\t   根据显示的字段数量有不同的拼接方式\n\t\t\t\t */\n\t\t\t\tvar dataName = t.arg.dataName;\n\t\t\t\tvar lengthName = dataName.length;\n\t\t\t\tvar dataLen = data.length;\n\n\t\t\t\t// 显示一个字段\n\t\t\t\tif(lengthName == 1){\n\t\t\t\t\t$.each(data, function (k, v){\n\t\t\t\t\t\tif(dataNum >= dataLen) return false;\n\t\t\t\t\t\tarrHtml.push('<li class=\"gclearfix '+( dataNum++ == 0 ? t.selClass : '')+'\">'); \n\t\t\t\t\t\tarrHtml.push('<span class=\"js-name\">'+ v[dataName[0]]+'</span>');\n\t\t\t\t\t\tarrHtml.push('</li>');\n\t\t\t\t\t});\n\t\t\t\t/*\n\t\t\t\t\t显示>=2个字段\n\t\t\t\t\t这里以地铁几号线为例的，可根据实际情况改写\n\t\t\t\t*/\n\t\t\t\t}else{\n\t\t\t\t\t$.each(data, function (k, v){\n\t\t\t\t\t\tvar name = v[dataName[0]],\n\t\t\t\t\t\t\tlineNums = v[dataName[1]].split(\",\").reverse(),\n\t\t\t\t\t\t\tlineLen = lineNums.length,\n\t\t\t\t\t\t\tspanTag = '';\n\n\t\t\t\t\t\tfor(var j = 0; j < lineLen; j++){\n\t\t\t\t\t\t\tvar num = lineNums[j];\n\t\t\t\t\t\t\tspanTag += '<span class=\"line-ico '+subwayIcon[num]['bg']+'\">'+subwayIcon[num]['showNum']+'</span>';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 大于7条退出\n\t\t\t\t\t\tif(i >= dataLen) return false;\n\t\t\t\t\t\tarrHtml.push('<li class=\"gclearfix '+(dataNum++==0?t.selClass:'')+'\">');\n\t\t\t\t\t\tarrHtml.push('<span class=\"js-name\">'+name+'</span><em>'+spanTag+'</em>');\n\t\t\t\t\t\tarrHtml.push('</li>');\n\t\t\t\t\t});  \n\t\t\t\t}\n\t\t\t\treturn this.elUl.html(arrHtml.join(''));\n\t\t\t},\n\n\t\t\t// Sug划过背景\n\t\t\tmouserBack : function (e){\n\t\t\t\t// 当前划过节点\n\t\t\t\tvar mouseNode = $(e.target);\n\t\t\t\t// 判断划过的是否是sug节点\n\t\t\t\tvar ul = mouseNode.parents('.mh-ui-suggest');\n\t\t\t\t// 选中的class\n\t\t\t\tvar selClass = this.selClass;\n\t\t\t\t// 标签名\n\t\t\t\tvar elName = mouseNode[0].nodeName;\n\t\t\t\tvar li;\n\n\t\t\t\tif(ul){\n\t\t\t\t\tif(elName == 'UL') return false;\n\n\t\t\t\t\tif(elName == 'LI'){\n\t\t\t\t\t\tli = mouseNode;\n\t\t\t\t\t}else if(elName=='EM' || elName=='SPAN'){\n\t\t\t\t\t\tli = mouseNode.parents('li');\n\t\t\t\t\t}\n\t\t\t\t\t// 删除缓存节点class\n\t\t\t\t\tthis.selectedNode.removeClass(this.selClass);\n\n\t\t\t\t\tli.addClass(selClass);\n\t\t\t\t\t// 重新赋值保存当前选中的节点\n\t\t\t\t\tthis.selectedNode = li;\n\t\t\t\t};\n\t\t\t},\n\n\n\t\t\t// 点击sug节点 内容输入到input框\n\t\t\tsetInputValue : function (e){ \n\t\t\t\t// 触发的当前节点\n\t\t\t\tvar target = $(e.target);\n\t\t\t\t// 判断点击的是否是sug节点\n\t\t\t\tvar isUL = target.parents('.mh-ui-suggest');\n\t\t\t\t// 获得选中的class\n\t\t\t\tvar selClass = this.selClass;\n\t\t\t\t// 标签名\n\t\t\t\tvar elName = target[0].nodeName;\n\t\t\t\t// 获取点击节点文本\n\t\t\t\tvar text;\n\t\t\t\t// 获取包含整个icon的html\n\t\t\t\tvar icoHtml;\n\n\t\t\t\tif(isUL){\n\t\t\t\t\tvar targetLi = target.parent(),\n\t\t\t\t\t\ttext = $('.js-name', targetLi).text(),\n\t\t\t\t\t\ticoHtml = $('em',targetLi).html();\n\t\t\t\t\tthis.triggerInput.val(text);\n\t\t\t\t\tthis.triggerInput.siblings('.mh-ico-wrap').append(icoHtml);\n\t\t\t\t}\n\t\t\t\t// 隐藏sug\n\t\t\t\tthis.removeSug();\n\t\t\t},\n\n\n\t\t\t// 上下箭头 回车 方法\n\t\t\tsugPoit : function (e){\n\t\t\t\t// 键值\n\t\t\t\tvar code = e.keyCode,\n\t\t\t\t\tsugShow =$('.mh-ui-suggest').hasClass('mh-ui-suggest-none');\n\n\t\t\t\t// 回车事件\n\t\t\t\tif(code==13){\n\t\t\t\t\tthis.enter(e);\n\n\t\t\t\t// 上下事件\n\t\t\t\t}else if(code==38 || code==40){\n\t\t\t\t\tthis.arrow(code, e);\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// 上下箭头方法\n\t\t\tarrow : function (code, e){\n\t\t\t\te.stopPropagation();\n\n\t\t\t\tvar t = this, el;\n\t\t\t\t// 上次保存的节点\n\t\t\t\tvar selectedNode = t.selectedNode;\n\t\t\t\t// 选中的class\n\t\t\t\tselClass = t.selClass;\n\t\t\t\t\n\t\t\t\tif(code == 38){\n\t\t\t\t\tel = selectedNode.prev();\n\t\t\t\t\tif(el[0]){\n\t\t\t\t\t\tel.addClass(selClass)\n\t\t\t\t\t}else{\n\t\t\t\t\t\t(el=t.elLi.eq(t.elLi.length-1)).addClass(selClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(code == 40){\n\t\t\t\t\tel = selectedNode.next();\n\t\t\t\t\tif(el[0]){\n\t\t\t\t\t\tel.addClass(selClass)\n\t\t\t\t\t}else{\n\t\t\t\t\t\t(el=t.elLi.eq(0)).addClass(selClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 删除上一次li节点的背景\n\t\t\t\tt.elLi.length != 1 && selectedNode.removeClass(selClass);\n\n\t\t\t\t// 重写保存的默认li\n\t\t\t\tt.selectedNode = el;\n\t\t\t},\n\n\n\t\t\t// 回车方法\n\t\t\tenter : function (e){\n\t\t\t\te.preventDefault();\n\t\t\t\tif(this.selectedNode.parent().hasClass('mh-ui-suggest-none')){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar text = $('.js-name', this.selectedNode).text(),\n\t\t\t\t\ticoHtml = $('em', this.selectedNode).html(),\n\t\t\t\t\ticoWrap = this.triggerInput.siblings('.mh-ico-wrap');\n\n\t\t\t\tthis.triggerInput.val(text);\n\t\t\t\tif(icoWrap.html() == ''){\n\t\t\t\t\ticoWrap.append(icoHtml);\n\t\t\t\t}\n\t\t\t\t// 隐藏sug\n\t\t\t\tthis.removeSug();\n\t\t\t},\n\n\t\t\t// 获取点击位置\n\t\t\tgetPoin : function (el){\n\t\t\t\tvar clickClient = el.offset();\n\t\t\t\treturn {\n\t\t\t\t\ttop : clickClient.top,\n\t\t\t\t\tleft : clickClient.left\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// 删除Sug列表\n\t\t\tremoveSug : function (e){\n\t\t\t\t// 隐藏Sug列表\n\t\t\t\t$('.mh-ui-suggest').addClass('mh-ui-suggest-none');\n\t\t\t\t$('.mh-ui-suggest li').removeClass('mh-ui-suggest-sel');\n\t\t\t}\n\t\t};",
				"html": "function ShowSuggestBox(arg){\n\t\t\tthis.arg = arg;\n\t\t\t// 初始化实例\n\t\t\tthis.init(arg); \n\t\t};\n\n\n\t\tShowSuggestBox.prototype = {\n\t\t\t// 类初始化\n\t\t\tinit : function (arg){\n\t\t\t\t// 保存当前选中的节点\n\t\t\t\tthis.selectedNode = null;\n\t\t\t\t// 保存li节点\n\t\t\t\tthis.elLi = null,\n\t\t\t\t// 创建UL节点  \n\t\t\t\tthis.elUl = $('<ul class=\"mh-ui-suggest mh-ui-suggest-none\"></ul>');\n\t\t\t\t// Body节点\n\t\t\t\tthis.elBody = $('body');\n\t\t\t\t// 触发sug的input\n\t\t\t\tthis.triggerInput = $('.'+arg.sugInputName);\n\t\t\t\t// 保存input的值\n\t\t\t\tthis.caseInputValue = this.triggerInput.val();\n\t\t\t\t// 选中class \n\t\t\t\tthis.selClass = 'mh-ui-suggest-sel';\n\t\t\t\t// 事件\n\t\t\t\tthis.addEvent();\n\t\t\t},\n\n\n\t\t\t// 事件\n\t\t\taddEvent : function (){\n\t\t\t\tvar t = this;\n\t\t\t\t// 当前表单\n\t\t\t\tvar input = this.triggerInput;\n\t\t\t\t// 异步延迟ID\n\t\t\t\tvar setTimeId;\n\n\t\t\t\t// 监听输入事件\n\t\t\t\tinput.on('input propertychange', function (e){\n\t\t\t\t\tvar el = $(this);\n\t\t\t\t\t\n\t\t\t\t\t// 清除延迟ID\n\t\t\t\t\tsetTimeId && clearTimeout(setTimeId);\n\t\t\t\t\t// 延迟请求 避免覆盖\n\t\t\t\t\tsetTimeId = setTimeout(function (){\n\t\t\t\t\t\t// Sug列表\n\t\t\t\t\t\tt.showSug(el);\n\t\t\t\t\t}, 0);\n\t\t\t\t});\n\n\t\t\t\tinput.on('blur', function (e){\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t// 关闭其他sug列表\n\t\t\t\t\tt.removeSug(e);\n\t\t\t\t});\n\n\t\t\t\t// 监听上下箭头\n\t\t\t\tinput.on('keydown', function (e){\n\t\t\t\t\t// 移动背景位置\n\t\t\t\t\tt.sugPoit(e);\n\t\t\t\t});\n\n\t\t\t\t// Sug划过背景\n\t\t\t\tthis.elUl.on('mouseover', function (e){\n\t\t\t\t\tt.mouserBack(e);\n\t\t\t\t});\n\n\t\t\t\t// 点击Sug节点\n\t\t\t\tthis.elUl.on('click', function (e){\n\t\t\t\t\tt.setInputValue(e);\n\t\t\t\t});\n\n\t\t\t\t// 关闭事件\n\t\t\t\tthis.elBody.on('click', function (){\n\t\t\t\t\tt.removeSug();\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\t// 展现sug列表\n\t\t\tshowSug : function (el){\n\t\t\t\tvar t = this;\n\t\t\t\t// URL\n\t\t\t\tvar url = this.arg.url;\n\t\t\t\t// callbackName\n\t\t\t\tvar jsonpCallback = this.arg.jsonpCallback;\n\t\t\t\t// 参数\n\t\t\t\tvar data = this.arg.data;\n\t\t\t\t// 输入框的Value\n\t\t\t\tvar iValue = el.val();\n\t\t\t\t// 修正input BUG\n\t\t\t\t// 中文输入下 点击其他节点时触发input事件\n\t\t\t\tif(iValue==this.caseInputValue) return false;\n\t\t\t\t// 重置input的值\n\t\t\t\tthis.caseInputValue = iValue;\n\t\t\t\t\n\t\t\t\t//为参数赋值\n\t\t\t\tdata[t.arg.query] = iValue;\n\n\t\t\t\t// XHR\n\t\t\t\tvar ajax = function (){\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl : url,\n\t\t\t\t\t\ttype : 'POST',\n\t\t\t\t\t\tdata : data,\n\t\t\t\t\t\tdataType : 'jsonp',\n\t\t\t\t\t\tjsonpCallback: jsonpCallback,\n\t\t\t\t\t\tsuccess : function (data){\n\t\t\t\t\t\t\tvar dataResult = data[t.arg.result];\n\n\t\t\t\t\t\t\tif(dataResult.length){\n\t\t\t\t\t\t\t\tt.joinHTML(data[t.arg.result], el);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tt.removeSug();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\t// 输入框是否有值 调用ajax || 隐藏sug\n\t\t\t\tiValue ? ajax() : t.removeSug();\n\t\t\t},\n\n\n\t\t\t// HTML\n\t\t\tjoinHTML : function (data, el){\n\t\t\t\tif(data && data.length){\n\t\t\t\t\t// 拼接HTML\n\t\t\t\t\t// 拼html代码\n\t\t\t\t\tvar elLi = this.createHTML(data);\n\t\t\t\t\t// 获取位置\n\t\t\t\t\tvar clickClient = this.getPoin(el);\n\t\t\t\t\t// 修正值\n\t\t\t\t\tvar top = 0, left = 0;\n\t\t\t\t\t// 获取修正值\n\t\t\t\t\tvar correctedPosition = this.arg.correctedPosition || 0;\n\t\t\t\t\t\n\t\t\t\t\tif(correctedPosition){\n\t\t\t\t\t\ttop = correctedPosition.top;\n\t\t\t\t\t\tleft = correctedPosition.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sug列表位置\n\t\t\t\t\t// 为了防止以外Bug 此处每次都计算Sug位置\n\t\t\t\t\tthis.elUl.removeClass('mh-ui-suggest-none').css({\n\t\t\t\t\t\t// 用offsetHeight原生方法 避免outerHeight被重写\n\t\t\t\t\t\ttop : clickClient.top + el[0].offsetHeight + top + 'px',\n\t\t\t\t\t\tleft : clickClient.left + left + 'px'\n\t\t\t\t\t});\n\n\t\t\t\t\t// 保存所有的li节点\n\t\t\t\t\tthis.elLi = $('li', this.elUl);\n\n\t\t\t\t\t// 每次初始化sug列表时 初始化默认划过的节点\n\t\t\t\t\tthis.selectedNode = this.elLi.eq(0);\n\n\t\t\t\t\t// 插入到页面\n\t\t\t\t\tthis.elBody.append(elLi);\n\t\t\t\t}else{\n\t\t\t\t\t// 删除Sug列表\n\t\t\t\t\tthis.removeSug();\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// Sug列表\n\t\t\tcreateHTML : function (data){\n\t\t\t\tvar t = this;\n\t\t\t\t// html数组\n\t\t\t\tvar arrHtml = [];\n\t\t\t\t// 计数 大于7退出\n\t\t\t\tvar dataNum = 0;\n\n\t\t\t\t/* 显示的数据字段名\n\t\t\t\t   根据显示的字段数量有不同的拼接方式\n\t\t\t\t */\n\t\t\t\tvar dataName = t.arg.dataName;\n\t\t\t\tvar lengthName = dataName.length;\n\t\t\t\tvar dataLen = data.length;\n\n\t\t\t\t// 显示一个字段\n\t\t\t\tif(lengthName == 1){\n\t\t\t\t\t$.each(data, function (k, v){\n\t\t\t\t\t\tif(dataNum >= dataLen) return false;\n\t\t\t\t\t\tarrHtml.push('<li class=\"gclearfix '+( dataNum++ == 0 ? t.selClass : '')+'\">'); \n\t\t\t\t\t\tarrHtml.push('<span class=\"js-name\">'+ v[dataName[0]]+'</span>');\n\t\t\t\t\t\tarrHtml.push('</li>');\n\t\t\t\t\t});\n\t\t\t\t/*\n\t\t\t\t\t显示>=2个字段\n\t\t\t\t\t这里以地铁几号线为例的，可根据实际情况改写\n\t\t\t\t*/\n\t\t\t\t}else{\n\t\t\t\t\t$.each(data, function (k, v){\n\t\t\t\t\t\tvar name = v[dataName[0]],\n\t\t\t\t\t\t\tlineNums = v[dataName[1]].split(\",\").reverse(),\n\t\t\t\t\t\t\tlineLen = lineNums.length,\n\t\t\t\t\t\t\tspanTag = '';\n\n\t\t\t\t\t\tfor(var j = 0; j < lineLen; j++){\n\t\t\t\t\t\t\tvar num = lineNums[j];\n\t\t\t\t\t\t\tspanTag += '<span class=\"line-ico '+subwayIcon[num]['bg']+'\">'+subwayIcon[num]['showNum']+'</span>';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 大于7条退出\n\t\t\t\t\t\tif(i >= dataLen) return false;\n\t\t\t\t\t\tarrHtml.push('<li class=\"gclearfix '+(dataNum++==0?t.selClass:'')+'\">');\n\t\t\t\t\t\tarrHtml.push('<span class=\"js-name\">'+name+'</span><em>'+spanTag+'</em>');\n\t\t\t\t\t\tarrHtml.push('</li>');\n\t\t\t\t\t});  \n\t\t\t\t}\n\t\t\t\treturn this.elUl.html(arrHtml.join(''));\n\t\t\t},\n\n\t\t\t// Sug划过背景\n\t\t\tmouserBack : function (e){\n\t\t\t\t// 当前划过节点\n\t\t\t\tvar mouseNode = $(e.target);\n\t\t\t\t// 判断划过的是否是sug节点\n\t\t\t\tvar ul = mouseNode.parents('.mh-ui-suggest');\n\t\t\t\t// 选中的class\n\t\t\t\tvar selClass = this.selClass;\n\t\t\t\t// 标签名\n\t\t\t\tvar elName = mouseNode[0].nodeName;\n\t\t\t\tvar li;\n\n\t\t\t\tif(ul){\n\t\t\t\t\tif(elName == 'UL') return false;\n\n\t\t\t\t\tif(elName == 'LI'){\n\t\t\t\t\t\tli = mouseNode;\n\t\t\t\t\t}else if(elName=='EM' || elName=='SPAN'){\n\t\t\t\t\t\tli = mouseNode.parents('li');\n\t\t\t\t\t}\n\t\t\t\t\t// 删除缓存节点class\n\t\t\t\t\tthis.selectedNode.removeClass(this.selClass);\n\n\t\t\t\t\tli.addClass(selClass);\n\t\t\t\t\t// 重新赋值保存当前选中的节点\n\t\t\t\t\tthis.selectedNode = li;\n\t\t\t\t};\n\t\t\t},\n\n\n\t\t\t// 点击sug节点 内容输入到input框\n\t\t\tsetInputValue : function (e){ \n\t\t\t\t// 触发的当前节点\n\t\t\t\tvar target = $(e.target);\n\t\t\t\t// 判断点击的是否是sug节点\n\t\t\t\tvar isUL = target.parents('.mh-ui-suggest');\n\t\t\t\t// 获得选中的class\n\t\t\t\tvar selClass = this.selClass;\n\t\t\t\t// 标签名\n\t\t\t\tvar elName = target[0].nodeName;\n\t\t\t\t// 获取点击节点文本\n\t\t\t\tvar text;\n\t\t\t\t// 获取包含整个icon的html\n\t\t\t\tvar icoHtml;\n\n\t\t\t\tif(isUL){\n\t\t\t\t\tvar targetLi = target.parent(),\n\t\t\t\t\t\ttext = $('.js-name', targetLi).text(),\n\t\t\t\t\t\ticoHtml = $('em',targetLi).html();\n\t\t\t\t\tthis.triggerInput.val(text);\n\t\t\t\t\tthis.triggerInput.siblings('.mh-ico-wrap').append(icoHtml);\n\t\t\t\t}\n\t\t\t\t// 隐藏sug\n\t\t\t\tthis.removeSug();\n\t\t\t},\n\n\n\t\t\t// 上下箭头 回车 方法\n\t\t\tsugPoit : function (e){\n\t\t\t\t// 键值\n\t\t\t\tvar code = e.keyCode,\n\t\t\t\t\tsugShow =$('.mh-ui-suggest').hasClass('mh-ui-suggest-none');\n\n\t\t\t\t// 回车事件\n\t\t\t\tif(code==13){\n\t\t\t\t\tthis.enter(e);\n\n\t\t\t\t// 上下事件\n\t\t\t\t}else if(code==38 || code==40){\n\t\t\t\t\tthis.arrow(code, e);\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// 上下箭头方法\n\t\t\tarrow : function (code, e){\n\t\t\t\te.stopPropagation();\n\n\t\t\t\tvar t = this, el;\n\t\t\t\t// 上次保存的节点\n\t\t\t\tvar selectedNode = t.selectedNode;\n\t\t\t\t// 选中的class\n\t\t\t\tselClass = t.selClass;\n\t\t\t\t\n\t\t\t\tif(code == 38){\n\t\t\t\t\tel = selectedNode.prev();\n\t\t\t\t\tif(el[0]){\n\t\t\t\t\t\tel.addClass(selClass)\n\t\t\t\t\t}else{\n\t\t\t\t\t\t(el=t.elLi.eq(t.elLi.length-1)).addClass(selClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(code == 40){\n\t\t\t\t\tel = selectedNode.next();\n\t\t\t\t\tif(el[0]){\n\t\t\t\t\t\tel.addClass(selClass)\n\t\t\t\t\t}else{\n\t\t\t\t\t\t(el=t.elLi.eq(0)).addClass(selClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 删除上一次li节点的背景\n\t\t\t\tt.elLi.length != 1 && selectedNode.removeClass(selClass);\n\n\t\t\t\t// 重写保存的默认li\n\t\t\t\tt.selectedNode = el;\n\t\t\t},\n\n\n\t\t\t// 回车方法\n\t\t\tenter : function (e){\n\t\t\t\te.preventDefault();\n\t\t\t\tif(this.selectedNode.parent().hasClass('mh-ui-suggest-none')){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar text = $('.js-name', this.selectedNode).text(),\n\t\t\t\t\ticoHtml = $('em', this.selectedNode).html(),\n\t\t\t\t\ticoWrap = this.triggerInput.siblings('.mh-ico-wrap');\n\n\t\t\t\tthis.triggerInput.val(text);\n\t\t\t\tif(icoWrap.html() == ''){\n\t\t\t\t\ticoWrap.append(icoHtml);\n\t\t\t\t}\n\t\t\t\t// 隐藏sug\n\t\t\t\tthis.removeSug();\n\t\t\t},\n\n\t\t\t// 获取点击位置\n\t\t\tgetPoin : function (el){\n\t\t\t\tvar clickClient = el.offset();\n\t\t\t\treturn {\n\t\t\t\t\ttop : clickClient.top,\n\t\t\t\t\tleft : clickClient.left\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// 删除Sug列表\n\t\t\tremoveSug : function (e){\n\t\t\t\t// 隐藏Sug列表\n\t\t\t\t$('.mh-ui-suggest').addClass('mh-ui-suggest-none');\n\t\t\t\t$('.mh-ui-suggest li').removeClass('mh-ui-suggest-sel');\n\t\t\t}\n\t\t};",
				"image": null,
				"featured": 0,
				"page": 1,
				"status": "draft",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1477974265000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1477974265000,
				"published_by": 2
			},
			{
				"id": "cj914pnxk000de0hytlokmhkx",
				"title": "",
				"markdown": "function ShowSuggestBox(arg){\n\t\t\tthis.arg = arg;\n\t\t\t// 初始化实例\n\t\t\tthis.init(arg); \n\t\t};\n\n\n\t\tShowSuggestBox.prototype = {\n\t\t\t// 类初始化\n\t\t\tinit : function (arg){\n\t\t\t\t// 保存当前选中的节点\n\t\t\t\tthis.saveNextNode = null;\n\t\t\t\t// 保存li节点\n\t\t\t\tthis.elLi = null,\n\t\t\t\t// 创建UL节点  \n\t\t\t\tthis.elUl = $('<ul class=\"mh-ui-suggest mh-ui-suggest-none\"></ul>');\n\t\t\t\t// Body节点\n\t\t\t\tthis.elBody = $('body');\n\t\t\t\t// 触发sug的input\n\t\t\t\tthis.triggerInput = $('.'+arg.sugInputName);\n\t\t\t\t// 保存input的值\n\t\t\t\tthis.caseInputValue = this.triggerInput.val();\n\t\t\t\t// 选中class \n\t\t\t\tthis.selClass = 'mh-ui-suggest-sel';\n\t\t\t\t// 事件\n\t\t\t\tthis.addEvent();\n\t\t\t},\n\n\n\t\t\t// 事件\n\t\t\taddEvent : function (){\n\t\t\t\tvar t = this;\n\t\t\t\t// 当前表单\n\t\t\t\tvar input = this.triggerInput;\n\t\t\t\t// 异步延迟ID\n\t\t\t\tvar setTimeId;\n\n\t\t\t\t// 监听输入事件\n\t\t\t\tinput.on('input propertychange', function (e){\n\t\t\t\t\tvar el = $(this);\n\t\t\t\t\t// 清空input右侧icon\n\t\t\t\t\tel.siblings('.mh-ico-wrap').html('');\n\t\t\t\t\t// \n\t\t\t\t\t\n\t\t\t\t\t$('.js-mh-err-tips').html('');\n\t\t\t\t\t\n\t\t\t\t\t// 清除延迟ID\n\t\t\t\t\tsetTimeId && clearTimeout(setTimeId);\n\t\t\t\t\t// 延迟请求 避免覆盖\n\t\t\t\t\tsetTimeId = setTimeout(function (){\n\t\t\t\t\t\t// Sug列表\n\t\t\t\t\t\tt.showSug(el);\n\t\t\t\t\t}, 0);\n\t\t\t\t});\n\n\t\t\t\tinput.on('click', function (e){\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t// 关闭其他sug列表\n\t\t\t\t\tt.removeSug(e);\n\t\t\t\t});\n\n\t\t\t\t// 监听上下箭头\n\t\t\t\tinput.on('keydown', function (e){\n\t\t\t\t\t// 移动背景位置\n\t\t\t\t\tt.sugPoit(e);\n\t\t\t\t});\n\n\t\t\t\t// Sug划过背景\n\t\t\t\tthis.elUl.on('mouseover', function (e){\n\t\t\t\t\tt.mouserBack(e);\n\t\t\t\t});\n\n\t\t\t\t// 点击Sug节点\n\t\t\t\tthis.elUl.on('click', function (e){\n\t\t\t\t\tt.setInputValue(e);\n\t\t\t\t});\n\n\t\t\t\t// 关闭事件\n\t\t\t\tthis.elBody.on('click', function (){\n\t\t\t\t\tt.removeSug();\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\t// 展现sug列表\n\t\t\tshowSug : function (el){\n\t\t\t\tvar t = this;\n\t\t\t\t// URL\n\t\t\t\tvar url = this.arg.url;\n\t\t\t\t// callbackName\n\t\t\t\tvar jsonpCallback = this.arg.jsonpCallback;\n\t\t\t\t// 输入框的Value\n\t\t\t\tvar iValue = el.val();\n\t\t\t\t// 修正input BUG\n\t\t\t\t// 中文输入下 点击其他节点时触发input事件\n\t\t\t\tif(iValue==this.caseInputValue) return false;\n\t\t\t\t// 重置input的值\n\t\t\t\tthis.caseInputValue = iValue;\n\t\t\t\t// 参数\n\t\t\t\tvar data = this.arg.data;\n\t\t\t\t// 添加城市键值\n\t\t\t\tdata[t.arg.query] = iValue;\n\n\t\t\t\t// XHR\n\t\t\t\tvar ajax = function (){\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl : url,\n\t\t\t\t\t\ttype : 'POST',\n\t\t\t\t\t\tdata : data,\n\t\t\t\t\t\tdataType : 'jsonp',\n\t\t\t\t\t\tjsonpCallback: jsonpCallback,\n\t\t\t\t\t\tsuccess : function (data){\n\t\t\t\t\t\t\tvar dataResult = data[t.arg.result];\n\n\t\t\t\t\t\t\tif(dataResult.length){\n\t\t\t\t\t\t\t\tt.joinHTML(data[t.arg.result], el);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tt.removeSug();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//t.joinHTML(data[t.arg.result], el);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\t// 输入框是否有值 调用ajax || 隐藏sug\n\t\t\t\tiValue ? ajax() : t.removeSug();\n\t\t\t},\n\n\n\t\t\t// HTML\n\t\t\tjoinHTML : function (data, el){\n\t\t\t\tif(data && data.length){\n\t\t\t\t\t// 拼接HTML\n\t\t\t\t\t// 拼html代码\n\t\t\t\t\tvar elLi = this.createHTML(data);\n\t\t\t\t\t// 获取位置\n\t\t\t\t\tvar clickClient = this.getPoin(el);\n\t\t\t\t\t// 修正值\n\t\t\t\t\tvar top = 0, left = 0;\n\t\t\t\t\t// 获取修正值\n\t\t\t\t\tvar correctedPosition = this.arg.correctedPosition;\n\t\t\t\t\t\n\t\t\t\t\tif(correctedPosition){\n\t\t\t\t\t\ttop = correctedPosition.top;\n\t\t\t\t\t\tleft = correctedPosition.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sug列表位置\n\t\t\t\t\t// 为了防止以外Bug 此处每次都计算Sug位置\n\t\t\t\t\tthis.elUl.removeClass('mh-ui-suggest-none').css({\n\t\t\t\t\t\t// 用offsetHeight原生方法 避免outerHeight被重写\n\t\t\t\t\t\ttop : clickClient.top + el[0].offsetHeight + top + 'px',\n\t\t\t\t\t\tleft : clickClient.left + left + 'px'\n\t\t\t\t\t});\n\n\t\t\t\t\t// 保存所有的li节点\n\t\t\t\t\tthis.elLi = $('li', this.elUl);\n\n\t\t\t\t\t// 每次初始化sug列表时 初始化默认划过的节点\n\t\t\t\t\tthis.saveNextNode = this.elLi.eq(0);\n\t\t\t\t\t//console.log(this.saveNextNode.html());\n\n\t\t\t\t\t// 插入到页面\n\t\t\t\t\tthis.elBody.append(elLi);\n\n\t\t\t\t// data为空\n\t\t\t\t}else{\n\t\t\t\t\t// 删除Sug列表\n\t\t\t\t\tthis.removeSug();\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// Sug列表\n\t\t\tcreateHTML : function (data){\n\t\t\t\tvar t = this;\n\t\t\t\t// html数组\n\t\t\t\tvar arr = [];\n\t\t\t\t// 计数 大于7退出\n\t\t\t\tvar i = 0;\n\t\t\t\tvar subwayIcon = t.arg.subwayIcon;\n\t\t\t\t// 显示的数据字段名\n\t\t\t\t// 根据显示的字段数量有不同的拼接方式\n\t\t\t\tvar dataName = t.arg.dataName;\n\t\t\t\t// 获取数据字段长度\n\t\t\t\tvar lengthName = dataName.length;\n\t\t\t\t// 显示总条数 默认7条\n\t\t\t\t//var num = t.arg.num || 7;\n\t\t\t\tvar num = data.length;\n\n\t\t\t\t// 显示一条数据\n\t\t\t\tif(lengthName==1){\n\t\t\t\t\t$.each(data, function (k, v){\n\t\t\t\t\t\t// 大于7条退出\n\t\t\t\t\t\tif(i >= num) return false;\n\t\t\t\t\t\tarr.push('<li class=\"'+(i++==0?t.selClass:'')+'\">'); \n\t\t\t\t\t\tarr.push('<span class=\"mh-ui-suggest-span\">'+v[dataName[0]]+'</span>');\n\t\t\t\t\t\tarr.push('</li>');\n\t\t\t\t\t});\n\n\t\t\t\t// 显示2条数据\n\t\t\t\t}else{\n\t\t\t\t\t$.each(data, function (k, v){\n\t\t\t\t\t\tvar name = v[dataName[0]],\n\t\t\t\t\t\t\tlineNums = v[dataName[1]].split(\",\").reverse(),\n\t\t\t\t\t\t\tlineLen = lineNums.length,\n\t\t\t\t\t\t\tspanTag = '';\n\n\t\t\t\t\t\tfor(var j = 0; j < lineLen; j++){\n\t\t\t\t\t\t\tvar num = lineNums[j];\n\t\t\t\t\t\t\tspanTag += '<span class=\"line-ico '+subwayIcon[num]['bg']+'\">'+subwayIcon[num]['showNum']+'</span>';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 大于7条退出\n\t\t\t\t\t\tif(i >= num) return false;\n\t\t\t\t\t\tarr.push('<li class=\"gclearfix '+(i++==0?t.selClass:'')+'\">');\n\t\t\t\t\t\tarr.push('<span class=\"js-name\">'+name+'</span><em>'+spanTag+'</em>');\n\t\t\t\t\t\tarr.push('</li>');\n\t\t\t\t\t});  \n\t\t\t\t}\n\n\t\t\t\treturn this.elUl.html(arr.join(''));\n\t\t\t},\n\n\n\t\t\t// Sug划过背景\n\t\t\tmouserBack : function (e){\n\t\t\t\t// 当前划过节点\n\t\t\t\tvar mouseNode = $(e.target);\n\t\t\t\t// 判断划过的是否是sug节点\n\t\t\t\tvar ul = mouseNode.parents('.mh-ui-suggest');\n\t\t\t\t// 选中的class\n\t\t\t\tvar selClass = this.selClass;\n\t\t\t\t// 标签名\n\t\t\t\tvar elName = mouseNode[0].nodeName;\n\t\t\t\tvar li;\n\n\t\t\t\tif(ul){\n\t\t\t\t\tif(elName == 'UL') return false;\n\n\t\t\t\t\tif(elName == 'LI'){\n\t\t\t\t\t\tli = mouseNode;\n\t\t\t\t\t}else if(elName=='EM' || elName=='SPAN'){\n\t\t\t\t\t\tli = mouseNode.parents('li');\n\t\t\t\t\t}\n\t\t\t\t\t// 删除缓存节点class\n\t\t\t\t\tthis.saveNextNode.removeClass(this.selClass);\n\t\t\t\t\tli.addClass(selClass);\n\t\t\t\t\t// 重新赋值保存当前选中的节点\n\t\t\t\t\tthis.saveNextNode = li;\n\t\t\t\t};\n\t\t\t},\n\n\n\t\t\t// 点击sug节点 内容输入到input框\n\t\t\tsetInputValue : function (e){ \n\t\t\t\t// 触发的当前节点\n\t\t\t\tvar target = $(e.target);\n\t\t\t\t// 判断点击的是否是sug节点\n\t\t\t\tvar isUL = target.parents('.mh-ui-suggest');\n\t\t\t\t// 获得选中的class\n\t\t\t\tvar selClass = this.selClass;\n\t\t\t\t// 标签名\n\t\t\t\tvar elName = target[0].nodeName;\n\t\t\t\t// 获取点击节点文本\n\t\t\t\tvar text;\n\t\t\t\t// 获取包含整个icon的html\n\t\t\t\tvar icoHtml;\n\n\t\t\t\tif(isUL){\n\t\t\t\t\tvar targetLi = target.parent(),\n\t\t\t\t\t\ttext = $('.js-name', targetLi).text(),\n\t\t\t\t\t\ticoHtml = $('em',targetLi).html();\n\t\t\t\t\tthis.triggerInput.val(text);\n\t\t\t\t\tthis.triggerInput.siblings('.mh-ico-wrap').append(icoHtml);\n\t\t\t\t}\n\t\t\t\t// 隐藏sug\n\t\t\t\tthis.removeSug();\n\t\t\t},\n\n\n\t\t\t// 上下箭头 回车 方法\n\t\t\tsugPoit : function (e){\n\t\t\t\t// 键值\n\t\t\t\tvar code = e.keyCode,\n\t\t\t\t\tsugShow =$('.mh-ui-suggest').hasClass('mh-ui-suggest-none');\n\n\t\t\t\t//sugShow && return;\n\t\t\t\t// 回车事件\n\t\t\t\tif(code==13){\n\t\t\t\t\tthis.enter(e);\n\n\t\t\t\t// 上下事件\n\t\t\t\t}else if(code==38 || code==40){\n\t\t\t\t\tthis.arrow(code, e);\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// 上下箭头方法\n\t\t\tarrow : function (code, e){\n\t\t\t\te.stopPropagation();\n\n\t\t\t\tvar t = this, el;\n\t\t\t\t// 上次保存的节点\n\t\t\t\tvar saveNextNode = t.saveNextNode;\n\t\t\t\t// 选中的class\n\t\t\t\tselClass = t.selClass;\n\t\t\t\t// 向上箭头 获取上一个节点\n\t\t\t\t//code==38 && (el= saveNextNode.prev());\n\n\t\t\t\t// 向下箭头 获取下一个节点\n\t\t\t\t//code==40 && (el= saveNextNode.next());\n\t\t\t\t\n\t\t\t\tif(code == 38){\n\t\t\t\t\tel = saveNextNode.prev();\n\t\t\t\t\tif(el[0]){\n\t\t\t\t\t\tel.addClass(selClass)\n\t\t\t\t\t}else{\n\t\t\t\t\t\t(el=t.elLi.eq(t.elLi.length-1)).addClass(selClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(code == 40){\n\t\t\t\t\tel = saveNextNode.next();\n\t\t\t\t\tif(el[0]){\n\t\t\t\t\t\tel.addClass(selClass)\n\t\t\t\t\t}else{\n\t\t\t\t\t\t(el=t.elLi.eq(0)).addClass(selClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 删除上一次li节点的背景\n\t\t\t\tt.elLi.length != 1 && saveNextNode.removeClass(selClass);\n\n\t\t\t\t// 重写保存的默认li\n\t\t\t\tt.saveNextNode = el;\n\t\t\t},\n\n\n\t\t\t// 回车方法\n\t\t\tenter : function (e){\n\t\t\t\te.preventDefault();\n\n\t\t\t\t// 回车时 给文本框赋值\n\t\t\t\t//this.triggerInput.val($('span', this.saveNextNode).text());\n\t\t\t\t\n\t\t\t\tif(this.saveNextNode.parent().hasClass('mh-ui-suggest-none')){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar text = $('.js-name', this.saveNextNode).text(),\n\t\t\t\t\ticoHtml = $('em', this.saveNextNode).html(),\n\t\t\t\t\ticoWrap = this.triggerInput.siblings('.mh-ico-wrap');\n\n\t\t\t\tthis.triggerInput.val(text);\n\t\t\t\tif(icoWrap.html() == ''){\n\t\t\t\t\ticoWrap.append(icoHtml);\n\t\t\t\t}\n\t\t\t\t// 隐藏sug\n\t\t\t\tthis.removeSug();\n\t\t\t},\n\n\n\t\t\t// 获取点击位置\n\t\t\tgetPoin : function (el){\n\t\t\t\tvar clickClient = el.offset();\n\t\t\t\treturn {\n\t\t\t\t\ttop : clickClient.top,\n\t\t\t\t\tleft : clickClient.left\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// 删除Sug列表\n\t\t\tremoveSug : function (e){\n\t\t\t\t// 隐藏Sug列表\n\t\t\t\t$('.mh-ui-suggest').addClass('mh-ui-suggest-none');\n\t\t\t\t$('.mh-ui-suggest li').removeClass('mh-ui-suggest-sel');\n\t\t\t}\n\t\t};",
				"html": "function ShowSuggestBox(arg){\n\t\t\tthis.arg = arg;\n\t\t\t// 初始化实例\n\t\t\tthis.init(arg); \n\t\t};\n\n\n\t\tShowSuggestBox.prototype = {\n\t\t\t// 类初始化\n\t\t\tinit : function (arg){\n\t\t\t\t// 保存当前选中的节点\n\t\t\t\tthis.saveNextNode = null;\n\t\t\t\t// 保存li节点\n\t\t\t\tthis.elLi = null,\n\t\t\t\t// 创建UL节点  \n\t\t\t\tthis.elUl = $('<ul class=\"mh-ui-suggest mh-ui-suggest-none\"></ul>');\n\t\t\t\t// Body节点\n\t\t\t\tthis.elBody = $('body');\n\t\t\t\t// 触发sug的input\n\t\t\t\tthis.triggerInput = $('.'+arg.sugInputName);\n\t\t\t\t// 保存input的值\n\t\t\t\tthis.caseInputValue = this.triggerInput.val();\n\t\t\t\t// 选中class \n\t\t\t\tthis.selClass = 'mh-ui-suggest-sel';\n\t\t\t\t// 事件\n\t\t\t\tthis.addEvent();\n\t\t\t},\n\n\n\t\t\t// 事件\n\t\t\taddEvent : function (){\n\t\t\t\tvar t = this;\n\t\t\t\t// 当前表单\n\t\t\t\tvar input = this.triggerInput;\n\t\t\t\t// 异步延迟ID\n\t\t\t\tvar setTimeId;\n\n\t\t\t\t// 监听输入事件\n\t\t\t\tinput.on('input propertychange', function (e){\n\t\t\t\t\tvar el = $(this);\n\t\t\t\t\t// 清空input右侧icon\n\t\t\t\t\tel.siblings('.mh-ico-wrap').html('');\n\t\t\t\t\t// \n\t\t\t\t\t\n\t\t\t\t\t$('.js-mh-err-tips').html('');\n\t\t\t\t\t\n\t\t\t\t\t// 清除延迟ID\n\t\t\t\t\tsetTimeId && clearTimeout(setTimeId);\n\t\t\t\t\t// 延迟请求 避免覆盖\n\t\t\t\t\tsetTimeId = setTimeout(function (){\n\t\t\t\t\t\t// Sug列表\n\t\t\t\t\t\tt.showSug(el);\n\t\t\t\t\t}, 0);\n\t\t\t\t});\n\n\t\t\t\tinput.on('click', function (e){\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t// 关闭其他sug列表\n\t\t\t\t\tt.removeSug(e);\n\t\t\t\t});\n\n\t\t\t\t// 监听上下箭头\n\t\t\t\tinput.on('keydown', function (e){\n\t\t\t\t\t// 移动背景位置\n\t\t\t\t\tt.sugPoit(e);\n\t\t\t\t});\n\n\t\t\t\t// Sug划过背景\n\t\t\t\tthis.elUl.on('mouseover', function (e){\n\t\t\t\t\tt.mouserBack(e);\n\t\t\t\t});\n\n\t\t\t\t// 点击Sug节点\n\t\t\t\tthis.elUl.on('click', function (e){\n\t\t\t\t\tt.setInputValue(e);\n\t\t\t\t});\n\n\t\t\t\t// 关闭事件\n\t\t\t\tthis.elBody.on('click', function (){\n\t\t\t\t\tt.removeSug();\n\t\t\t\t});\n\t\t\t},\n\n\n\t\t\t// 展现sug列表\n\t\t\tshowSug : function (el){\n\t\t\t\tvar t = this;\n\t\t\t\t// URL\n\t\t\t\tvar url = this.arg.url;\n\t\t\t\t// callbackName\n\t\t\t\tvar jsonpCallback = this.arg.jsonpCallback;\n\t\t\t\t// 输入框的Value\n\t\t\t\tvar iValue = el.val();\n\t\t\t\t// 修正input BUG\n\t\t\t\t// 中文输入下 点击其他节点时触发input事件\n\t\t\t\tif(iValue==this.caseInputValue) return false;\n\t\t\t\t// 重置input的值\n\t\t\t\tthis.caseInputValue = iValue;\n\t\t\t\t// 参数\n\t\t\t\tvar data = this.arg.data;\n\t\t\t\t// 添加城市键值\n\t\t\t\tdata[t.arg.query] = iValue;\n\n\t\t\t\t// XHR\n\t\t\t\tvar ajax = function (){\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl : url,\n\t\t\t\t\t\ttype : 'POST',\n\t\t\t\t\t\tdata : data,\n\t\t\t\t\t\tdataType : 'jsonp',\n\t\t\t\t\t\tjsonpCallback: jsonpCallback,\n\t\t\t\t\t\tsuccess : function (data){\n\t\t\t\t\t\t\tvar dataResult = data[t.arg.result];\n\n\t\t\t\t\t\t\tif(dataResult.length){\n\t\t\t\t\t\t\t\tt.joinHTML(data[t.arg.result], el);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tt.removeSug();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//t.joinHTML(data[t.arg.result], el);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\t// 输入框是否有值 调用ajax || 隐藏sug\n\t\t\t\tiValue ? ajax() : t.removeSug();\n\t\t\t},\n\n\n\t\t\t// HTML\n\t\t\tjoinHTML : function (data, el){\n\t\t\t\tif(data && data.length){\n\t\t\t\t\t// 拼接HTML\n\t\t\t\t\t// 拼html代码\n\t\t\t\t\tvar elLi = this.createHTML(data);\n\t\t\t\t\t// 获取位置\n\t\t\t\t\tvar clickClient = this.getPoin(el);\n\t\t\t\t\t// 修正值\n\t\t\t\t\tvar top = 0, left = 0;\n\t\t\t\t\t// 获取修正值\n\t\t\t\t\tvar correctedPosition = this.arg.correctedPosition;\n\t\t\t\t\t\n\t\t\t\t\tif(correctedPosition){\n\t\t\t\t\t\ttop = correctedPosition.top;\n\t\t\t\t\t\tleft = correctedPosition.left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sug列表位置\n\t\t\t\t\t// 为了防止以外Bug 此处每次都计算Sug位置\n\t\t\t\t\tthis.elUl.removeClass('mh-ui-suggest-none').css({\n\t\t\t\t\t\t// 用offsetHeight原生方法 避免outerHeight被重写\n\t\t\t\t\t\ttop : clickClient.top + el[0].offsetHeight + top + 'px',\n\t\t\t\t\t\tleft : clickClient.left + left + 'px'\n\t\t\t\t\t});\n\n\t\t\t\t\t// 保存所有的li节点\n\t\t\t\t\tthis.elLi = $('li', this.elUl);\n\n\t\t\t\t\t// 每次初始化sug列表时 初始化默认划过的节点\n\t\t\t\t\tthis.saveNextNode = this.elLi.eq(0);\n\t\t\t\t\t//console.log(this.saveNextNode.html());\n\n\t\t\t\t\t// 插入到页面\n\t\t\t\t\tthis.elBody.append(elLi);\n\n\t\t\t\t// data为空\n\t\t\t\t}else{\n\t\t\t\t\t// 删除Sug列表\n\t\t\t\t\tthis.removeSug();\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// Sug列表\n\t\t\tcreateHTML : function (data){\n\t\t\t\tvar t = this;\n\t\t\t\t// html数组\n\t\t\t\tvar arr = [];\n\t\t\t\t// 计数 大于7退出\n\t\t\t\tvar i = 0;\n\t\t\t\tvar subwayIcon = t.arg.subwayIcon;\n\t\t\t\t// 显示的数据字段名\n\t\t\t\t// 根据显示的字段数量有不同的拼接方式\n\t\t\t\tvar dataName = t.arg.dataName;\n\t\t\t\t// 获取数据字段长度\n\t\t\t\tvar lengthName = dataName.length;\n\t\t\t\t// 显示总条数 默认7条\n\t\t\t\t//var num = t.arg.num || 7;\n\t\t\t\tvar num = data.length;\n\n\t\t\t\t// 显示一条数据\n\t\t\t\tif(lengthName==1){\n\t\t\t\t\t$.each(data, function (k, v){\n\t\t\t\t\t\t// 大于7条退出\n\t\t\t\t\t\tif(i >= num) return false;\n\t\t\t\t\t\tarr.push('<li class=\"'+(i++==0?t.selClass:'')+'\">'); \n\t\t\t\t\t\tarr.push('<span class=\"mh-ui-suggest-span\">'+v[dataName[0]]+'</span>');\n\t\t\t\t\t\tarr.push('</li>');\n\t\t\t\t\t});\n\n\t\t\t\t// 显示2条数据\n\t\t\t\t}else{\n\t\t\t\t\t$.each(data, function (k, v){\n\t\t\t\t\t\tvar name = v[dataName[0]],\n\t\t\t\t\t\t\tlineNums = v[dataName[1]].split(\",\").reverse(),\n\t\t\t\t\t\t\tlineLen = lineNums.length,\n\t\t\t\t\t\t\tspanTag = '';\n\n\t\t\t\t\t\tfor(var j = 0; j < lineLen; j++){\n\t\t\t\t\t\t\tvar num = lineNums[j];\n\t\t\t\t\t\t\tspanTag += '<span class=\"line-ico '+subwayIcon[num]['bg']+'\">'+subwayIcon[num]['showNum']+'</span>';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 大于7条退出\n\t\t\t\t\t\tif(i >= num) return false;\n\t\t\t\t\t\tarr.push('<li class=\"gclearfix '+(i++==0?t.selClass:'')+'\">');\n\t\t\t\t\t\tarr.push('<span class=\"js-name\">'+name+'</span><em>'+spanTag+'</em>');\n\t\t\t\t\t\tarr.push('</li>');\n\t\t\t\t\t});  \n\t\t\t\t}\n\n\t\t\t\treturn this.elUl.html(arr.join(''));\n\t\t\t},\n\n\n\t\t\t// Sug划过背景\n\t\t\tmouserBack : function (e){\n\t\t\t\t// 当前划过节点\n\t\t\t\tvar mouseNode = $(e.target);\n\t\t\t\t// 判断划过的是否是sug节点\n\t\t\t\tvar ul = mouseNode.parents('.mh-ui-suggest');\n\t\t\t\t// 选中的class\n\t\t\t\tvar selClass = this.selClass;\n\t\t\t\t// 标签名\n\t\t\t\tvar elName = mouseNode[0].nodeName;\n\t\t\t\tvar li;\n\n\t\t\t\tif(ul){\n\t\t\t\t\tif(elName == 'UL') return false;\n\n\t\t\t\t\tif(elName == 'LI'){\n\t\t\t\t\t\tli = mouseNode;\n\t\t\t\t\t}else if(elName=='EM' || elName=='SPAN'){\n\t\t\t\t\t\tli = mouseNode.parents('li');\n\t\t\t\t\t}\n\t\t\t\t\t// 删除缓存节点class\n\t\t\t\t\tthis.saveNextNode.removeClass(this.selClass);\n\t\t\t\t\tli.addClass(selClass);\n\t\t\t\t\t// 重新赋值保存当前选中的节点\n\t\t\t\t\tthis.saveNextNode = li;\n\t\t\t\t};\n\t\t\t},\n\n\n\t\t\t// 点击sug节点 内容输入到input框\n\t\t\tsetInputValue : function (e){ \n\t\t\t\t// 触发的当前节点\n\t\t\t\tvar target = $(e.target);\n\t\t\t\t// 判断点击的是否是sug节点\n\t\t\t\tvar isUL = target.parents('.mh-ui-suggest');\n\t\t\t\t// 获得选中的class\n\t\t\t\tvar selClass = this.selClass;\n\t\t\t\t// 标签名\n\t\t\t\tvar elName = target[0].nodeName;\n\t\t\t\t// 获取点击节点文本\n\t\t\t\tvar text;\n\t\t\t\t// 获取包含整个icon的html\n\t\t\t\tvar icoHtml;\n\n\t\t\t\tif(isUL){\n\t\t\t\t\tvar targetLi = target.parent(),\n\t\t\t\t\t\ttext = $('.js-name', targetLi).text(),\n\t\t\t\t\t\ticoHtml = $('em',targetLi).html();\n\t\t\t\t\tthis.triggerInput.val(text);\n\t\t\t\t\tthis.triggerInput.siblings('.mh-ico-wrap').append(icoHtml);\n\t\t\t\t}\n\t\t\t\t// 隐藏sug\n\t\t\t\tthis.removeSug();\n\t\t\t},\n\n\n\t\t\t// 上下箭头 回车 方法\n\t\t\tsugPoit : function (e){\n\t\t\t\t// 键值\n\t\t\t\tvar code = e.keyCode,\n\t\t\t\t\tsugShow =$('.mh-ui-suggest').hasClass('mh-ui-suggest-none');\n\n\t\t\t\t//sugShow && return;\n\t\t\t\t// 回车事件\n\t\t\t\tif(code==13){\n\t\t\t\t\tthis.enter(e);\n\n\t\t\t\t// 上下事件\n\t\t\t\t}else if(code==38 || code==40){\n\t\t\t\t\tthis.arrow(code, e);\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// 上下箭头方法\n\t\t\tarrow : function (code, e){\n\t\t\t\te.stopPropagation();\n\n\t\t\t\tvar t = this, el;\n\t\t\t\t// 上次保存的节点\n\t\t\t\tvar saveNextNode = t.saveNextNode;\n\t\t\t\t// 选中的class\n\t\t\t\tselClass = t.selClass;\n\t\t\t\t// 向上箭头 获取上一个节点\n\t\t\t\t//code==38 && (el= saveNextNode.prev());\n\n\t\t\t\t// 向下箭头 获取下一个节点\n\t\t\t\t//code==40 && (el= saveNextNode.next());\n\t\t\t\t\n\t\t\t\tif(code == 38){\n\t\t\t\t\tel = saveNextNode.prev();\n\t\t\t\t\tif(el[0]){\n\t\t\t\t\t\tel.addClass(selClass)\n\t\t\t\t\t}else{\n\t\t\t\t\t\t(el=t.elLi.eq(t.elLi.length-1)).addClass(selClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(code == 40){\n\t\t\t\t\tel = saveNextNode.next();\n\t\t\t\t\tif(el[0]){\n\t\t\t\t\t\tel.addClass(selClass)\n\t\t\t\t\t}else{\n\t\t\t\t\t\t(el=t.elLi.eq(0)).addClass(selClass);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 删除上一次li节点的背景\n\t\t\t\tt.elLi.length != 1 && saveNextNode.removeClass(selClass);\n\n\t\t\t\t// 重写保存的默认li\n\t\t\t\tt.saveNextNode = el;\n\t\t\t},\n\n\n\t\t\t// 回车方法\n\t\t\tenter : function (e){\n\t\t\t\te.preventDefault();\n\n\t\t\t\t// 回车时 给文本框赋值\n\t\t\t\t//this.triggerInput.val($('span', this.saveNextNode).text());\n\t\t\t\t\n\t\t\t\tif(this.saveNextNode.parent().hasClass('mh-ui-suggest-none')){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar text = $('.js-name', this.saveNextNode).text(),\n\t\t\t\t\ticoHtml = $('em', this.saveNextNode).html(),\n\t\t\t\t\ticoWrap = this.triggerInput.siblings('.mh-ico-wrap');\n\n\t\t\t\tthis.triggerInput.val(text);\n\t\t\t\tif(icoWrap.html() == ''){\n\t\t\t\t\ticoWrap.append(icoHtml);\n\t\t\t\t}\n\t\t\t\t// 隐藏sug\n\t\t\t\tthis.removeSug();\n\t\t\t},\n\n\n\t\t\t// 获取点击位置\n\t\t\tgetPoin : function (el){\n\t\t\t\tvar clickClient = el.offset();\n\t\t\t\treturn {\n\t\t\t\t\ttop : clickClient.top,\n\t\t\t\t\tleft : clickClient.left\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t// 删除Sug列表\n\t\t\tremoveSug : function (e){\n\t\t\t\t// 隐藏Sug列表\n\t\t\t\t$('.mh-ui-suggest').addClass('mh-ui-suggest-none');\n\t\t\t\t$('.mh-ui-suggest li').removeClass('mh-ui-suggest-sel');\n\t\t\t}\n\t\t};",
				"image": null,
				"featured": 0,
				"page": 1,
				"status": "draft",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1477974265000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1477974265000,
				"published_by": 2
			},
			{
				"id": "cj914pnww0001e0hyhxc7xadh",
				"title": "",
				"markdown": "(function(prototype) {\n\tprototype.getContext = (function(_super) {\n\t\treturn function(type) {\n\t\t\tvar backingStore, ratio,\n\t\t\t\tcontext = _super.call(this, type);\n\n\t\t\tif (type === '2d') {\n\n\t\t\t\tbackingStore = context.backingStorePixelRatio ||\n\t\t\t\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\t\t\t\tcontext.oBackingStorePixelRatio || 1;\n\n\t\t\t\tratio = (window.devicePixelRatio || 1) / backingStore;\n\n\t\t\t\tif (ratio > 1) {\n\t\t\t\t\tthis.style.height = this.height + 'px';\n\t\t\t\t\tthis.style.width = this.width + 'px';\n\t\t\t\t\tthis.width *= ratio;\n\t\t\t\t\tthis.height *= ratio;\n\t\t\t\t\tcontext.scale(ratio, ratio);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn context;\n\t\t};\n\t})(prototype.getContext);\n})(HTMLCanvasElement.prototype);\n",
				"html": "(function(prototype) {\n\tprototype.getContext = (function(_super) {\n\t\treturn function(type) {\n\t\t\tvar backingStore, ratio,\n\t\t\t\tcontext = _super.call(this, type);\n\n\t\t\tif (type === '2d') {\n\n\t\t\t\tbackingStore = context.backingStorePixelRatio ||\n\t\t\t\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\t\t\t\tcontext.oBackingStorePixelRatio || 1;\n\n\t\t\t\tratio = (window.devicePixelRatio || 1) / backingStore;\n\n\t\t\t\tif (ratio > 1) {\n\t\t\t\t\tthis.style.height = this.height + 'px';\n\t\t\t\t\tthis.style.width = this.width + 'px';\n\t\t\t\t\tthis.width *= ratio;\n\t\t\t\t\tthis.height *= ratio;\n\t\t\t\t\tcontext.scale(ratio, ratio);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn context;\n\t\t};\n\t})(prototype.getContext);\n})(HTMLCanvasElement.prototype);\n",
				"image": null,
				"featured": 0,
				"page": 1,
				"status": "draft",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1477974264000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1477974264000,
				"published_by": 2
			},
			{
				"id": "cj914pnx10003e0hy71iy6qom",
				"title": "",
				"markdown": "var fs = require('fs');\n\nvar casper = require('casper').create({\n\tclientScripts: [\"jquery.js\"]\n});\n\ncasper.start('http://blog.csdn.net/mine666?viewmode=contents', function() {\n\tthis.echo(this.getTitle());\n});\n\nvar links, index = 0;\nvar baseurl = 'http://blog.csdn.net';\ncasper.then(function() {\n\tlinks = this.evaluate(getLinks);\n\tthis.echo(links.length);\n\n\tfor(var i = 0, linksLen = links.length; i < linksLen; i++){\n\t\tthis.thenOpen(baseurl + links[i], function(){\n\t\t\tvar content = this.evaluate(getContent);\n\t\t\tthis.echo(index);\n\t\t\tvar filePath = fs.pathJoin(fs.workingDirectory, 'html', index + '.html');\n\t\t\tfs.write(filePath, content, 'w');\n\t\t\tthis.echo(index+' saved');\n\t\t\tindex++;\n\t\t});\n\t}\n});\n\nfunction getContent(){\n\tvar title = $('.link_title a').html(),\n\t\tpostdate = $('.link_postdate').html(),\n\t\tcontent = $('#article_content').html();\n\t\n\t\tvar res = '<p>title: ' + title + '</p>'\n\t\t\t\t+ '<p>date: ' + postdate + '</p>'\n\t\t\t\t+ '<p>categories: ' + '\"csdn\"' + '</p>'\n\t\t\t\t+ '<p>tags: ' + '[csdn]' + '</p>'\n\t\t\t\t+ '<p>---</p>'\n\t\t\t\t+ '<br>';\n\treturn res + content;\n}\n\nfunction getLinks(){\n\tvar aList = [];\n\t\n\tvar linkTitles = $('#article_list').find('.link_title');\n\tfor( var i = 0, linkTitlesLen = linkTitles.length; i < linkTitlesLen; i++){\n\t\taList[i] = $(linkTitles[i]).find('a').attr('href');\n\t}\n\treturn aList;\n}\n\ncasper.run();",
				"html": "var fs = require('fs');\n\nvar casper = require('casper').create({\n\tclientScripts: [\"jquery.js\"]\n});\n\ncasper.start('http://blog.csdn.net/mine666?viewmode=contents', function() {\n\tthis.echo(this.getTitle());\n});\n\nvar links, index = 0;\nvar baseurl = 'http://blog.csdn.net';\ncasper.then(function() {\n\tlinks = this.evaluate(getLinks);\n\tthis.echo(links.length);\n\n\tfor(var i = 0, linksLen = links.length; i < linksLen; i++){\n\t\tthis.thenOpen(baseurl + links[i], function(){\n\t\t\tvar content = this.evaluate(getContent);\n\t\t\tthis.echo(index);\n\t\t\tvar filePath = fs.pathJoin(fs.workingDirectory, 'html', index + '.html');\n\t\t\tfs.write(filePath, content, 'w');\n\t\t\tthis.echo(index+' saved');\n\t\t\tindex++;\n\t\t});\n\t}\n});\n\nfunction getContent(){\n\tvar title = $('.link_title a').html(),\n\t\tpostdate = $('.link_postdate').html(),\n\t\tcontent = $('#article_content').html();\n\t\n\t\tvar res = '<p>title: ' + title + '</p>'\n\t\t\t\t+ '<p>date: ' + postdate + '</p>'\n\t\t\t\t+ '<p>categories: ' + '\"csdn\"' + '</p>'\n\t\t\t\t+ '<p>tags: ' + '[csdn]' + '</p>'\n\t\t\t\t+ '<p>---</p>'\n\t\t\t\t+ '<br>';\n\treturn res + content;\n}\n\nfunction getLinks(){\n\tvar aList = [];\n\t\n\tvar linkTitles = $('#article_list').find('.link_title');\n\tfor( var i = 0, linkTitlesLen = linkTitles.length; i < linkTitlesLen; i++){\n\t\taList[i] = $(linkTitles[i]).find('a').attr('href');\n\t}\n\treturn aList;\n}\n\ncasper.run();",
				"image": null,
				"featured": 0,
				"page": 1,
				"status": "draft",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1477974264000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1477974264000,
				"published_by": 2
			},
			{
				"id": "cj914pnxb0007e0hyz6lxs6sr",
				"title": "",
				"markdown": "var fs = require('fs');\nvar path = require('path');\nvar toMarkdown = require('to-markdown');\nvar xss = require('xss');\n\nvar options = {\n\twhiteList: {\n\t\tp: [],\n\t\tpre: [],\n\t\th1: [],\n\t\th2: []\n\t},\n\tstripIgnoreTag: true\n};\n\nvar root = path.dirname( __filename );\nvar srcDir = path.join( root, 'html' );\n\nvar exec = require('child_process').exec;\n\nvar ls = exec('casperjs run.js', function (error, stdout, stderr) {\n\tif (error) {\n\t\tconsole.log(error.stack);\n\t\tconsole.log('Error code: ' + error.code);\n\t}\n\tfs.readdir(srcDir, function(err, files){\n\t\tif(err){\n\t\t\tconsole.log( err );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfiles.forEach(function(filename){\n\t\t\tvar src = path.join( srcDir, filename );\n\t\t\tvar fileData = fs.readFileSync( src ).toString().trim();\n\t\t\tvar html = xss( fileData, options );\n\t\t\tvar mk = toMarkdown( html );\n\n\t\t\tvar destName = filename.split('.')[0] + '.md';\n\t\t\tvar dest = path.join( root, 'md', destName );\n\n\t\t\tfs.writeFile(dest, mk, function (err) {\n\t\t\t\tif (err) throw err;\n\t\t\t\tconsole.log('It\\'s saved!'); //文件被保存\n\t\t\t});\n\t\t});\n\t});\n});\n",
				"html": "var fs = require('fs');\nvar path = require('path');\nvar toMarkdown = require('to-markdown');\nvar xss = require('xss');\n\nvar options = {\n\twhiteList: {\n\t\tp: [],\n\t\tpre: [],\n\t\th1: [],\n\t\th2: []\n\t},\n\tstripIgnoreTag: true\n};\n\nvar root = path.dirname( __filename );\nvar srcDir = path.join( root, 'html' );\n\nvar exec = require('child_process').exec;\n\nvar ls = exec('casperjs run.js', function (error, stdout, stderr) {\n\tif (error) {\n\t\tconsole.log(error.stack);\n\t\tconsole.log('Error code: ' + error.code);\n\t}\n\tfs.readdir(srcDir, function(err, files){\n\t\tif(err){\n\t\t\tconsole.log( err );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfiles.forEach(function(filename){\n\t\t\tvar src = path.join( srcDir, filename );\n\t\t\tvar fileData = fs.readFileSync( src ).toString().trim();\n\t\t\tvar html = xss( fileData, options );\n\t\t\tvar mk = toMarkdown( html );\n\n\t\t\tvar destName = filename.split('.')[0] + '.md';\n\t\t\tvar dest = path.join( root, 'md', destName );\n\n\t\t\tfs.writeFile(dest, mk, function (err) {\n\t\t\t\tif (err) throw err;\n\t\t\t\tconsole.log('It\\'s saved!'); //文件被保存\n\t\t\t});\n\t\t});\n\t});\n});\n",
				"image": null,
				"featured": 0,
				"page": 1,
				"status": "draft",
				"language": "",
				"meta_title": null,
				"meta_description": null,
				"author_id": 2,
				"created_at": 1477974264000,
				"created_by": 2,
				"updated_at": 1452829810000,
				"updated_by": 2,
				"published_at": 1477974264000,
				"published_by": 2
			}
		],
		"tags": [
			{
				"id": "cj914po1w008ne0hynaqs1c1q",
				"name": "July",
				"slug": "July",
				"description": ""
			},
			{
				"id": "cj914po290096e0hy65n8jw2l",
				"name": "Webpack2",
				"slug": "Webpack2",
				"description": ""
			},
			{
				"id": "cj914po2a0099e0hyykwttfsh",
				"name": "IE",
				"slug": "IE",
				"description": ""
			},
			{
				"id": "cj914po1w008ne0hynaqs1c1q",
				"name": "July",
				"slug": "July",
				"description": ""
			},
			{
				"id": "cj914po290096e0hy65n8jw2l",
				"name": "Webpack2",
				"slug": "Webpack2",
				"description": ""
			},
			{
				"id": "cj914po1p0088e0hy7a1rpgn9",
				"name": "range",
				"slug": "range",
				"description": ""
			},
			{
				"id": "cj914po1q008be0hy8nkis019",
				"name": "selection",
				"slug": "selection",
				"description": ""
			},
			{
				"id": "cj914po1q008ce0hyd8x4t4sf",
				"name": "react",
				"slug": "react",
				"description": ""
			},
			{
				"id": "cj914po1r008fe0hykkkzf2cf",
				"name": "redux",
				"slug": "redux",
				"description": ""
			},
			{
				"id": "cj914po1k007pe0hyh4dyilo5",
				"name": "Linux",
				"slug": "Linux",
				"description": ""
			},
			{
				"id": "cj914po1k007se0hynkjr23f1",
				"name": "命令",
				"slug": "命令",
				"description": ""
			},
			{
				"id": "cj914po1q008ce0hyd8x4t4sf",
				"name": "react",
				"slug": "react",
				"description": ""
			},
			{
				"id": "cj914po1r008fe0hykkkzf2cf",
				"name": "redux",
				"slug": "redux",
				"description": ""
			},
			{
				"id": "cj914po1j007me0hygdhh0i5o",
				"name": "小问题",
				"slug": "小问题",
				"description": ""
			},
			{
				"id": "cj914po1m007ye0hyco8kgg3g",
				"name": "调试工具",
				"slug": "调试工具",
				"description": ""
			},
			{
				"id": "cj914po1k007pe0hyh4dyilo5",
				"name": "Linux",
				"slug": "Linux",
				"description": ""
			},
			{
				"id": "cj914po1m007we0hyer5qkcps",
				"name": "自动化",
				"slug": "自动化",
				"description": ""
			},
			{
				"id": "cj914po1m007xe0hyr6u775au",
				"name": "脚本",
				"slug": "脚本",
				"description": ""
			},
			{
				"id": "cj914pnzq003ge0hyu8jogz9y",
				"name": "Casperjs",
				"slug": "Casperjs",
				"description": ""
			},
			{
				"id": "cj914pnzq003ge0hyu8jogz9y",
				"name": "Casperjs",
				"slug": "Casperjs",
				"description": ""
			},
			{
				"id": "cj914pnyy0027e0hy04uka33u",
				"name": "JS",
				"slug": "JS",
				"description": ""
			},
			{
				"id": "cj914pnz6002ie0hyko9lgld8",
				"name": "Dec",
				"slug": "Dec",
				"description": ""
			},
			{
				"id": "cj914pnz8002ne0hyp3ogmzc0",
				"name": "异步编程",
				"slug": "异步编程",
				"description": ""
			},
			{
				"id": "cj914pnz6002ie0hyko9lgld8",
				"name": "Dec",
				"slug": "Dec",
				"description": ""
			},
			{
				"id": "cj914po0x005he0hyg0cne3zy",
				"name": "thinkJs",
				"slug": "thinkJs",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914pnzi002ze0hyaxzzsuem",
				"name": "Nov",
				"slug": "Nov",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914pnzi002ze0hyaxzzsuem",
				"name": "Nov",
				"slug": "Nov",
				"description": ""
			},
			{
				"id": "cj914po0v005be0hyfafar5a5",
				"name": "Oct",
				"slug": "Oct",
				"description": ""
			},
			{
				"id": "cj914po11005ze0hyr7w65ys6",
				"name": "NODE",
				"slug": "NODE",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po120062e0hyo8aj4xx2",
				"name": "HTTP",
				"slug": "HTTP",
				"description": ""
			},
			{
				"id": "cj914po1a006qe0hykjfn8ds4",
				"name": "HTTP2",
				"slug": "HTTP2",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po120062e0hyo8aj4xx2",
				"name": "HTTP",
				"slug": "HTTP",
				"description": ""
			},
			{
				"id": "cj914po1a006qe0hykjfn8ds4",
				"name": "HTTP2",
				"slug": "HTTP2",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po120062e0hyo8aj4xx2",
				"name": "HTTP",
				"slug": "HTTP",
				"description": ""
			},
			{
				"id": "cj914po1a006qe0hykjfn8ds4",
				"name": "HTTP2",
				"slug": "HTTP2",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po120062e0hyo8aj4xx2",
				"name": "HTTP",
				"slug": "HTTP",
				"description": ""
			},
			{
				"id": "cj914po1a006qe0hykjfn8ds4",
				"name": "HTTP2",
				"slug": "HTTP2",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po120062e0hyo8aj4xx2",
				"name": "HTTP",
				"slug": "HTTP",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po120062e0hyo8aj4xx2",
				"name": "HTTP",
				"slug": "HTTP",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po120062e0hyo8aj4xx2",
				"name": "HTTP",
				"slug": "HTTP",
				"description": ""
			},
			{
				"id": "cj914po01003ve0hy7q28pgp0",
				"name": "SVG",
				"slug": "SVG",
				"description": ""
			},
			{
				"id": "cj914po060042e0hyrwexql5o",
				"name": "CSS3",
				"slug": "CSS3",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po0e004ge0hyomgm93m0",
				"name": "CSS",
				"slug": "CSS",
				"description": ""
			},
			{
				"id": "cj914po0a0048e0hyclifawgh",
				"name": "Aug",
				"slug": "Aug",
				"description": ""
			},
			{
				"id": "cj914po27008ue0hyyrc9p7y7",
				"name": "svg",
				"slug": "svg",
				"description": ""
			},
			{
				"id": "cj914po0x005he0hyg0cne3zy",
				"name": "thinkJs",
				"slug": "thinkJs",
				"description": ""
			},
			{
				"id": "cj914po1w008ne0hynaqs1c1q",
				"name": "July",
				"slug": "July",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914po27008xe0hyyf6mt626",
				"name": "May",
				"slug": "May",
				"description": ""
			},
			{
				"id": "cj914po0x005he0hyg0cne3zy",
				"name": "thinkJs",
				"slug": "thinkJs",
				"description": ""
			},
			{
				"id": "cj914po0z005oe0hyi7qxfqc8",
				"name": "Ari",
				"slug": "Ari",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914po1w008oe0hy8ubt9oud",
				"name": "Mar",
				"slug": "Mar",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914po1n0081e0hyueycb8ff",
				"name": "Jua",
				"slug": "Jua",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914po1n0081e0hyueycb8ff",
				"name": "Jua",
				"slug": "Jua",
				"description": ""
			},
			{
				"id": "cj914pnz6002ie0hyko9lgld8",
				"name": "Dec",
				"slug": "Dec",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914pnzi002ze0hyaxzzsuem",
				"name": "Nov",
				"slug": "Nov",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914pnzi002ze0hyaxzzsuem",
				"name": "Nov",
				"slug": "Nov",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914po0v005be0hyfafar5a5",
				"name": "Oct",
				"slug": "Oct",
				"description": ""
			},
			{
				"id": "cj914pnzc002re0hy718f4m9a",
				"name": "css",
				"slug": "css",
				"description": ""
			},
			{
				"id": "cj914po0v005be0hyfafar5a5",
				"name": "Oct",
				"slug": "Oct",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx70005e0hyf29z5cjk",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			}
		],
		"posts_tags": [
			{
				"tag_id": "cj914po1w008ne0hynaqs1c1q",
				"post_id": "cj914po0s0055e0hy78pn1mfz"
			},
			{
				"tag_id": "cj914po290096e0hy65n8jw2l",
				"post_id": "cj914po0s0055e0hy78pn1mfz"
			},
			{
				"tag_id": "cj914po2a0099e0hyykwttfsh",
				"post_id": "cj914po0s0055e0hy78pn1mfz"
			},
			{
				"tag_id": "cj914po1w008ne0hynaqs1c1q",
				"post_id": "cj914po0u0058e0hyp2k82hew"
			},
			{
				"tag_id": "cj914po290096e0hy65n8jw2l",
				"post_id": "cj914po0u0058e0hyp2k82hew"
			},
			{
				"tag_id": "cj914po1p0088e0hy7a1rpgn9",
				"post_id": "cj914po070043e0hyvj526fim"
			},
			{
				"tag_id": "cj914po1q008be0hy8nkis019",
				"post_id": "cj914po070043e0hyvj526fim"
			},
			{
				"tag_id": "cj914po1q008ce0hyd8x4t4sf",
				"post_id": "cj914po080045e0hy30ccl5ts"
			},
			{
				"tag_id": "cj914po1r008fe0hykkkzf2cf",
				"post_id": "cj914po080045e0hy30ccl5ts"
			},
			{
				"tag_id": "cj914po1k007pe0hyh4dyilo5",
				"post_id": "cj914pnzs003me0hyobuv7y0x"
			},
			{
				"tag_id": "cj914po1k007se0hynkjr23f1",
				"post_id": "cj914pnzs003me0hyobuv7y0x"
			},
			{
				"tag_id": "cj914po1q008ce0hyd8x4t4sf",
				"post_id": "cj914po0a0049e0hy6dou6r1y"
			},
			{
				"tag_id": "cj914po1r008fe0hykkkzf2cf",
				"post_id": "cj914po0a0049e0hy6dou6r1y"
			},
			{
				"tag_id": "cj914po1j007me0hygdhh0i5o",
				"post_id": "cj914pnzr003je0hyem0i8q89"
			},
			{
				"tag_id": "cj914po1m007ye0hyco8kgg3g",
				"post_id": "cj914po00003te0hyfzabvnhx"
			},
			{
				"tag_id": "cj914po1k007pe0hyh4dyilo5",
				"post_id": "cj914pnzy003qe0hymzy6ypx4"
			},
			{
				"tag_id": "cj914po1m007we0hyer5qkcps",
				"post_id": "cj914pnzy003qe0hymzy6ypx4"
			},
			{
				"tag_id": "cj914po1m007xe0hyr6u775au",
				"post_id": "cj914pnzy003qe0hymzy6ypx4"
			},
			{
				"tag_id": "cj914pnzq003ge0hyu8jogz9y",
				"post_id": "cj914pnz3002de0hy6wbo9e6j"
			},
			{
				"tag_id": "cj914pnzq003ge0hyu8jogz9y",
				"post_id": "cj914pnz5002ge0hyo5wypjeh"
			},
			{
				"tag_id": "cj914pnyy0027e0hy04uka33u",
				"post_id": "cj914pnyu0022e0hyhvdqlx85"
			},
			{
				"tag_id": "cj914pnz6002ie0hyko9lgld8",
				"post_id": "cj914pnyu0022e0hyhvdqlx85"
			},
			{
				"tag_id": "cj914pnz8002ne0hyp3ogmzc0",
				"post_id": "cj914pnyu0022e0hyhvdqlx85"
			},
			{
				"tag_id": "cj914pnz6002ie0hyko9lgld8",
				"post_id": "cj914po0o004xe0hyk2pjiyvx"
			},
			{
				"tag_id": "cj914po0x005he0hyg0cne3zy",
				"post_id": "cj914po0o004xe0hyk2pjiyvx"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914pnyz002ae0hyja9myrce"
			},
			{
				"tag_id": "cj914pnzi002ze0hyaxzzsuem",
				"post_id": "cj914pnyz002ae0hyja9myrce"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914pnyw0025e0hyte1dvxbj"
			},
			{
				"tag_id": "cj914pnzi002ze0hyaxzzsuem",
				"post_id": "cj914pnyw0025e0hyte1dvxbj"
			},
			{
				"tag_id": "cj914po0v005be0hyfafar5a5",
				"post_id": "cj914pnzi0030e0hy4rmcf1bn"
			},
			{
				"tag_id": "cj914po11005ze0hyr7w65ys6",
				"post_id": "cj914pnzi0030e0hy4rmcf1bn"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914pnzn003ae0hy8t9fvz87"
			},
			{
				"tag_id": "cj914po120062e0hyo8aj4xx2",
				"post_id": "cj914pnzn003ae0hy8t9fvz87"
			},
			{
				"tag_id": "cj914po1a006qe0hykjfn8ds4",
				"post_id": "cj914pnzn003ae0hy8t9fvz87"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914pnzp003ee0hyqzg81nz9"
			},
			{
				"tag_id": "cj914po120062e0hyo8aj4xx2",
				"post_id": "cj914pnzp003ee0hyqzg81nz9"
			},
			{
				"tag_id": "cj914po1a006qe0hykjfn8ds4",
				"post_id": "cj914pnzp003ee0hyqzg81nz9"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914pnzm0037e0hy4kz2dvw4"
			},
			{
				"tag_id": "cj914po120062e0hyo8aj4xx2",
				"post_id": "cj914pnzm0037e0hy4kz2dvw4"
			},
			{
				"tag_id": "cj914po1a006qe0hykjfn8ds4",
				"post_id": "cj914pnzm0037e0hy4kz2dvw4"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914pnzo003ce0hy64qfmldv"
			},
			{
				"tag_id": "cj914po120062e0hyo8aj4xx2",
				"post_id": "cj914pnzo003ce0hy64qfmldv"
			},
			{
				"tag_id": "cj914po1a006qe0hykjfn8ds4",
				"post_id": "cj914pnzo003ce0hy64qfmldv"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914pnzl0034e0hyr0bv420m"
			},
			{
				"tag_id": "cj914po120062e0hyo8aj4xx2",
				"post_id": "cj914pnzl0034e0hyr0bv420m"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914po04003ze0hy1a31gwjr"
			},
			{
				"tag_id": "cj914po120062e0hyo8aj4xx2",
				"post_id": "cj914po04003ze0hy1a31gwjr"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914pnzi0032e0hy2udgbe5n"
			},
			{
				"tag_id": "cj914po120062e0hyo8aj4xx2",
				"post_id": "cj914pnzi0032e0hy2udgbe5n"
			},
			{
				"tag_id": "cj914po01003ve0hy7q28pgp0",
				"post_id": "cj914pnz7002le0hyhcnwt6iw"
			},
			{
				"tag_id": "cj914po060042e0hyrwexql5o",
				"post_id": "cj914pnz7002le0hyhcnwt6iw"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914pnz7002le0hyhcnwt6iw"
			},
			{
				"tag_id": "cj914po0e004ge0hyomgm93m0",
				"post_id": "cj914pnz7002le0hyhcnwt6iw"
			},
			{
				"tag_id": "cj914po0a0048e0hyclifawgh",
				"post_id": "cj914po0k004pe0hyy5y7i48h"
			},
			{
				"tag_id": "cj914po27008ue0hyyrc9p7y7",
				"post_id": "cj914po0k004pe0hyy5y7i48h"
			},
			{
				"tag_id": "cj914po0x005he0hyg0cne3zy",
				"post_id": "cj914po0b004be0hy689w09km"
			},
			{
				"tag_id": "cj914po1w008ne0hynaqs1c1q",
				"post_id": "cj914po0b004be0hy689w09km"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914po0m004se0hyosvl4b18"
			},
			{
				"tag_id": "cj914po27008xe0hyyf6mt626",
				"post_id": "cj914po0m004se0hyosvl4b18"
			},
			{
				"tag_id": "cj914po0x005he0hyg0cne3zy",
				"post_id": "cj914pnzf002ve0hyb43hhybp"
			},
			{
				"tag_id": "cj914po0z005oe0hyi7qxfqc8",
				"post_id": "cj914pnzf002ve0hyb43hhybp"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914po0f004he0hyxvrwreiq"
			},
			{
				"tag_id": "cj914po1w008oe0hy8ubt9oud",
				"post_id": "cj914po0f004he0hyxvrwreiq"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914po02003xe0hye3lxu6s6"
			},
			{
				"tag_id": "cj914po1n0081e0hyueycb8ff",
				"post_id": "cj914po02003xe0hye3lxu6s6"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914po0p0050e0hy901s1587"
			},
			{
				"tag_id": "cj914po1n0081e0hyueycb8ff",
				"post_id": "cj914po0p0050e0hy901s1587"
			},
			{
				"tag_id": "cj914pnz6002ie0hyko9lgld8",
				"post_id": "cj914pnz9002oe0hy450ahhkx"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914pnz9002oe0hy450ahhkx"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914po0c004de0hyai2u1jt7"
			},
			{
				"tag_id": "cj914pnzi002ze0hyaxzzsuem",
				"post_id": "cj914po0c004de0hyai2u1jt7"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914pnzb002pe0hy0fny3782"
			},
			{
				"tag_id": "cj914pnzi002ze0hyaxzzsuem",
				"post_id": "cj914pnzb002pe0hy0fny3782"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914pnzd002se0hyz6ai0as2"
			},
			{
				"tag_id": "cj914po0v005be0hyfafar5a5",
				"post_id": "cj914pnzd002se0hyz6ai0as2"
			},
			{
				"tag_id": "cj914pnzc002re0hy718f4m9a",
				"post_id": "cj914po0h004ke0hyyp4vdkgs"
			},
			{
				"tag_id": "cj914po0v005be0hyfafar5a5",
				"post_id": "cj914po0h004ke0hyyp4vdkgs"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnws0000e0hy6vz33pp5"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnwy0002e0hyj91lyx1j"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pny80012e0hyiq1sm4v1"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnyg001he0hyf5egpfz6"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnyk001ke0hyosgz9giz"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnym001ne0hyzyql32a5"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnyn001qe0hyyolvrx5d"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnyp001te0hyrvw4ie9p"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnyr001we0hyh2mcn193"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnyt001ze0hyvnpqpzue"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnx80006e0hyna2dhwvw"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnxc0008e0hyhn1vr89l"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnxi000ae0hy3sdh00lq"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnxo000fe0hy6ebm3fwm"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnxr000ie0hyxig1c9ge"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnxu000ne0hycz7zrwft"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnxw000qe0hyei7hvwng"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pny2000te0hygp2nid6f"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pny5000we0hynj32a8ly"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pny7000ze0hyl8rcjfa1"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pny90015e0hyfzxdbryd"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnya0018e0hy91pynnik"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnyb001be0hyl9wizqul"
			},
			{
				"tag_id": "cj914pnx70005e0hyf29z5cjk",
				"post_id": "cj914pnyd001ee0hyf4lah9pc"
			}
		],
		"categories": [
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po01003ue0hyxfu1r3xz",
				"name": "总结",
				"slug": "前端/总结",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po01003ue0hyxfu1r3xz",
				"name": "总结",
				"slug": "前端/总结",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po01003ue0hyxfu1r3xz",
				"name": "总结",
				"slug": "前端/总结",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po01003ue0hyxfu1r3xz",
				"name": "总结",
				"slug": "前端/总结",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po01003ue0hyxfu1r3xz",
				"name": "总结",
				"slug": "前端/总结",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnzb002qe0hyyswwmlh4",
				"name": "JS",
				"slug": "前端/JS",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnzu003ne0hymy3v4p6s",
				"name": "ES7",
				"slug": "前端/JS/ES7",
				"parent": "cj914pnzb002qe0hyyswwmlh4",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po01003ue0hyxfu1r3xz",
				"name": "总结",
				"slug": "前端/总结",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnzn0038e0hyldrwi59q",
				"name": "canvas",
				"slug": "前端/canvas",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnzh002we0hy2i7lbc9c",
				"name": "bug解决",
				"slug": "前端/bug解决",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914po0a0047e0hybnbu3u2d",
				"name": "canvas",
				"slug": "前端/bug解决/canvas",
				"parent": "cj914pnzh002we0hy2i7lbc9c",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po050041e0hyauax9foz",
				"name": "工具",
				"slug": "前端/工具",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po0d004ee0hywz2e500o",
				"name": "HTTP",
				"slug": "前端/HTTP",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po0d004ee0hywz2e500o",
				"name": "HTTP",
				"slug": "前端/HTTP",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po0d004ee0hywz2e500o",
				"name": "HTTP",
				"slug": "前端/HTTP",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po0d004ee0hywz2e500o",
				"name": "HTTP",
				"slug": "前端/HTTP",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po0d004ee0hywz2e500o",
				"name": "HTTP",
				"slug": "前端/HTTP",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914po11005we0hymw22mldo",
				"name": "翻译",
				"slug": "前端/HTTP/翻译",
				"parent": "cj914po0d004ee0hywz2e500o",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po0d004ee0hywz2e500o",
				"name": "HTTP",
				"slug": "前端/HTTP",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po0d004ee0hywz2e500o",
				"name": "HTTP",
				"slug": "前端/HTTP",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnzl0033e0hy5f1o3m8o",
				"name": "css学习",
				"slug": "前端/css学习",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po10005re0hy017qj30p",
				"name": "SVG",
				"slug": "前端/SVG",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po01003ue0hyxfu1r3xz",
				"name": "总结",
				"slug": "前端/总结",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnzl0033e0hy5f1o3m8o",
				"name": "css学习",
				"slug": "前端/css学习",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914po01003ue0hyxfu1r3xz",
				"name": "总结",
				"slug": "前端/总结",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnzl0033e0hy5f1o3m8o",
				"name": "css学习",
				"slug": "前端/css学习",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnzl0033e0hy5f1o3m8o",
				"name": "css学习",
				"slug": "前端/css学习",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnzl0033e0hy5f1o3m8o",
				"name": "css学习",
				"slug": "前端/css学习",
				"parent": "cj914pnyy0026e0hy0ltd41j0",
				"description": ""
			},
			{
				"id": "cj914pnyy0026e0hy0ltd41j0",
				"name": "前端",
				"slug": "前端",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			},
			{
				"id": "cj914pnx20004e0hygfyt1gdf",
				"name": "csdn",
				"slug": "csdn",
				"description": ""
			}
		],
		"posts_categories": [
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0s0055e0hy78pn1mfz"
			},
			{
				"category_id": "cj914po01003ue0hyxfu1r3xz",
				"post_id": "cj914po0s0055e0hy78pn1mfz"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0u0058e0hyp2k82hew"
			},
			{
				"category_id": "cj914po01003ue0hyxfu1r3xz",
				"post_id": "cj914po0u0058e0hyp2k82hew"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po070043e0hyvj526fim"
			},
			{
				"category_id": "cj914po01003ue0hyxfu1r3xz",
				"post_id": "cj914po070043e0hyvj526fim"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po080045e0hy30ccl5ts"
			},
			{
				"category_id": "cj914po01003ue0hyxfu1r3xz",
				"post_id": "cj914po080045e0hy30ccl5ts"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0a0049e0hy6dou6r1y"
			},
			{
				"category_id": "cj914po01003ue0hyxfu1r3xz",
				"post_id": "cj914po0a0049e0hy6dou6r1y"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnyu0022e0hyhvdqlx85"
			},
			{
				"category_id": "cj914pnzb002qe0hyyswwmlh4",
				"post_id": "cj914pnyu0022e0hyhvdqlx85"
			},
			{
				"category_id": "cj914pnzu003ne0hymy3v4p6s",
				"post_id": "cj914pnyu0022e0hyhvdqlx85"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0o004xe0hyk2pjiyvx"
			},
			{
				"category_id": "cj914po01003ue0hyxfu1r3xz",
				"post_id": "cj914po0o004xe0hyk2pjiyvx"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnyz002ae0hyja9myrce"
			},
			{
				"category_id": "cj914pnzn0038e0hyldrwi59q",
				"post_id": "cj914pnyz002ae0hyja9myrce"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnyw0025e0hyte1dvxbj"
			},
			{
				"category_id": "cj914pnzh002we0hy2i7lbc9c",
				"post_id": "cj914pnyw0025e0hyte1dvxbj"
			},
			{
				"category_id": "cj914po0a0047e0hybnbu3u2d",
				"post_id": "cj914pnyw0025e0hyte1dvxbj"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzi0030e0hy4rmcf1bn"
			},
			{
				"category_id": "cj914po050041e0hyauax9foz",
				"post_id": "cj914pnzi0030e0hy4rmcf1bn"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzn003ae0hy8t9fvz87"
			},
			{
				"category_id": "cj914po0d004ee0hywz2e500o",
				"post_id": "cj914pnzn003ae0hy8t9fvz87"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzp003ee0hyqzg81nz9"
			},
			{
				"category_id": "cj914po0d004ee0hywz2e500o",
				"post_id": "cj914pnzp003ee0hyqzg81nz9"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzm0037e0hy4kz2dvw4"
			},
			{
				"category_id": "cj914po0d004ee0hywz2e500o",
				"post_id": "cj914pnzm0037e0hy4kz2dvw4"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzo003ce0hy64qfmldv"
			},
			{
				"category_id": "cj914po0d004ee0hywz2e500o",
				"post_id": "cj914pnzo003ce0hy64qfmldv"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzl0034e0hyr0bv420m"
			},
			{
				"category_id": "cj914po0d004ee0hywz2e500o",
				"post_id": "cj914pnzl0034e0hyr0bv420m"
			},
			{
				"category_id": "cj914po11005we0hymw22mldo",
				"post_id": "cj914pnzl0034e0hyr0bv420m"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po04003ze0hy1a31gwjr"
			},
			{
				"category_id": "cj914po0d004ee0hywz2e500o",
				"post_id": "cj914po04003ze0hy1a31gwjr"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzi0032e0hy2udgbe5n"
			},
			{
				"category_id": "cj914po0d004ee0hywz2e500o",
				"post_id": "cj914pnzi0032e0hy2udgbe5n"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnz7002le0hyhcnwt6iw"
			},
			{
				"category_id": "cj914pnzl0033e0hy5f1o3m8o",
				"post_id": "cj914pnz7002le0hyhcnwt6iw"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0k004pe0hyy5y7i48h"
			},
			{
				"category_id": "cj914po10005re0hy017qj30p",
				"post_id": "cj914po0k004pe0hyy5y7i48h"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0b004be0hy689w09km"
			},
			{
				"category_id": "cj914po01003ue0hyxfu1r3xz",
				"post_id": "cj914po0b004be0hy689w09km"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0m004se0hyosvl4b18"
			},
			{
				"category_id": "cj914pnzl0033e0hy5f1o3m8o",
				"post_id": "cj914po0m004se0hyosvl4b18"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzf002ve0hyb43hhybp"
			},
			{
				"category_id": "cj914po01003ue0hyxfu1r3xz",
				"post_id": "cj914pnzf002ve0hyb43hhybp"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0f004he0hyxvrwreiq"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po02003xe0hye3lxu6s6"
			},
			{
				"category_id": "cj914pnzl0033e0hy5f1o3m8o",
				"post_id": "cj914po02003xe0hye3lxu6s6"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0p0050e0hy901s1587"
			},
			{
				"category_id": "cj914pnzl0033e0hy5f1o3m8o",
				"post_id": "cj914po0p0050e0hy901s1587"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnz9002oe0hy450ahhkx"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0c004de0hyai2u1jt7"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzb002pe0hy0fny3782"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914pnzd002se0hyz6ai0as2"
			},
			{
				"category_id": "cj914pnzl0033e0hy5f1o3m8o",
				"post_id": "cj914pnzd002se0hyz6ai0as2"
			},
			{
				"category_id": "cj914pnyy0026e0hy0ltd41j0",
				"post_id": "cj914po0h004ke0hyyp4vdkgs"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnws0000e0hy6vz33pp5"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnwy0002e0hyj91lyx1j"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pny80012e0hyiq1sm4v1"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnyg001he0hyf5egpfz6"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnyk001ke0hyosgz9giz"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnym001ne0hyzyql32a5"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnyn001qe0hyyolvrx5d"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnyp001te0hyrvw4ie9p"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnyr001we0hyh2mcn193"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnyt001ze0hyvnpqpzue"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnx80006e0hyna2dhwvw"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnxc0008e0hyhn1vr89l"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnxi000ae0hy3sdh00lq"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnxo000fe0hy6ebm3fwm"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnxr000ie0hyxig1c9ge"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnxu000ne0hycz7zrwft"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnxw000qe0hyei7hvwng"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pny2000te0hygp2nid6f"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pny5000we0hynj32a8ly"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pny7000ze0hyl8rcjfa1"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pny90015e0hyfzxdbryd"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnya0018e0hy91pynnik"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnyb001be0hyl9wizqul"
			},
			{
				"category_id": "cj914pnx20004e0hygfyt1gdf",
				"post_id": "cj914pnyd001ee0hyf4lah9pc"
			}
		],
		"users": [
			{
				"id": 2,
				"slug": "jiaolongHuang",
				"name": "jiaolongHuang",
				"email": "admin@admin.com"
			}
		],
		"role_users": [
			{
				"user_id": 2,
				"role_id": 3
			}
		]
	}
}